<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Hidden Line Test</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: sans-serif;
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
        }

        canvas {
            display: block;
        }

        #svg-overlay {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }
    </style>
</head>

<body>
    <div id="info">
        <div>Press SPACE to compute hidden lines</div>
        <div id="stats"></div>
    </div>
    <svg id="svg-overlay" xmlns="http://www.w3.org/2000/svg"></svg>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
        import { computeHiddenLines } from '../src/hidden-line.js';

        let scene, camera, renderer, controls, mesh;

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x222222);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(5, 5, 5);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            // Create test geometry - a simple box
            const geometry = new THREE.BoxGeometry(2, 2, 2);
            const material = new THREE.MeshBasicMaterial({
                color: 0x44aa88,
                wireframe: false,
                transparent: true,
                opacity: 0.3
            });
            mesh = new THREE.Mesh(geometry, material);
            scene.add(mesh);

            // Note: wireframe removed - it was interfering with raycaster

            // Light
            const light = new THREE.DirectionalLight(0xffffff, 1);
            light.position.set(5, 5, 5);
            scene.add(light);
            scene.add(new THREE.AmbientLight(0x404040));

            // Setup SVG overlay
            const svg = document.getElementById('svg-overlay');
            svg.setAttribute('width', window.innerWidth);
            svg.setAttribute('height', window.innerHeight);

            // Event listeners
            window.addEventListener('resize', onResize);
            window.addEventListener('keydown', onKeyDown);

            animate();
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);

            const svg = document.getElementById('svg-overlay');
            svg.setAttribute('width', window.innerWidth);
            svg.setAttribute('height', window.innerHeight);
        }

        function onKeyDown(e) {
            if (e.code === 'Space') {
                computeAndDraw();
            }
        }

        function computeAndDraw() {
            console.log('Computing hidden lines...');
            const startTime = performance.now();

            // Update mesh matrix
            mesh.updateMatrixWorld(true);

            const result = computeHiddenLines(mesh, camera, scene, {
                smoothThreshold: 0.99,
                gridSize: 16,
                occlusionEpsilon: 0.05,
                skipOcclusion: false,  // Now test occlusion with fixes
                width: window.innerWidth,
                height: window.innerHeight
            });

            const elapsed = performance.now() - startTime;
            document.getElementById('stats').textContent =
                `Computed ${result.edges.length} visible edges in ${elapsed.toFixed(1)}ms`;

            // Draw to SVG
            drawToSVG(result.edges);
        }

        function drawToSVG(edges) {
            const svg = document.getElementById('svg-overlay');
            svg.innerHTML = '';

            const halfWidth = window.innerWidth / 2;
            const halfHeight = window.innerHeight / 2;

            let pathD = '';

            for (const edge of edges) {
                const x1 = edge.a.x + halfWidth;
                const y1 = edge.a.y + halfHeight;
                const x2 = edge.b.x + halfWidth;
                const y2 = edge.b.y + halfHeight;

                pathD += `M${x1},${y1}L${x2},${y2}`;
            }

            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', pathD);
            path.setAttribute('stroke', edge => edge.isProfile ? '#ff0000' : '#00ff00');
            path.setAttribute('stroke', '#00ff00');
            path.setAttribute('stroke-width', '2');
            path.setAttribute('fill', 'none');
            svg.appendChild(path);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>

</html>