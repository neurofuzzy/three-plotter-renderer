{"version":3,"file":"three-plotter-renderer.umd.js","sources":["../src/gpu-silhouette.js","../src/perspective-hatch.js","../src/geom/geom.js","../src/analyzer.js","../src/optimize.js","../src/hidden-line.js","../src/plotter-renderer.js"],"sourcesContent":["/**\n * GPU Normal-Region Polygon Extraction\n * \n * Renders quantized normals to texture, uses connected component labeling\n * to find contiguous regions with same normal, then traces boundaries.\n * \n * This approach is:\n * - Fast (GPU parallel rendering)\n * - 3D-aware (normals from actual geometry)\n * - Produces clean polygons grouped by normal direction\n */\n\nimport {\n    WebGLRenderTarget,\n    MeshNormalMaterial,\n    MeshDepthMaterial,\n    ShaderMaterial,\n    RGBADepthPacking,\n    NearestFilter,\n    Vector2,\n    Vector3\n} from 'three';\n\n/**\n * @typedef {Object} NormalRegion\n * @property {Vector2[]} boundary - Closed boundary polygon points\n * @property {Vector3} normal - The normal direction for this region\n * @property {number} area - Region area in pixels\n * @property {number} regionId - Unique ID for this region\n */\n\n/**\n * Extract polygons grouped by normal direction\n * @param {WebGLRenderer} renderer\n * @param {Scene} scene\n * @param {Camera} camera\n * @param {Object} options\n * @returns {NormalRegion[]}\n */\nexport function extractNormalRegions(renderer, scene, camera, options = {}) {\n    const {\n        resolution = 2.0,        // Render at 2x for smooth boundaries\n        normalBuckets = 12,      // Quantize normals into N directions\n        minArea = 100,           // Minimum region area in pixels (at output scale)\n        simplifyTolerance = 2.0,\n        insetPixels = 0          // Inset boundaries by this many pixels (GPU erosion)\n    } = options;\n\n    const size = renderer.getSize(new Vector2());\n    const width = Math.floor(size.x * resolution);\n    const height = Math.floor(size.y * resolution);\n\n    // Scale inset by resolution\n    const insetAmount = Math.round(insetPixels * resolution);\n\n\n\n    // Step 1: Render normals and depth to textures\n    const normalPixels = renderNormals(renderer, scene, camera, width, height);\n    const depthPixels = renderDepth(renderer, scene, camera, width, height);\n\n    // Step 2: Quantize normals to region IDs\n    let { regionMap, normalLookup } = quantizeNormals(normalPixels, width, height, normalBuckets);\n\n\n    // Step 2.5: Apply erosion for insetting (GPU-style morphological erosion)\n    if (insetAmount > 0) {\n        regionMap = erodeRegionMap(regionMap, width, height, insetAmount);\n    }\n\n    // Step 3: Connected component labeling\n    const { labels, regionCount } = connectedComponents(regionMap, width, height);\n\n\n    // Step 4: Trace boundaries for each region\n    const regions = [];\n    for (let regionId = 1; regionId <= regionCount; regionId++) {\n        const boundary = traceBoundary(labels, width, height, regionId);\n        if (boundary.length < 3) continue;\n\n        // Simplify boundary\n        const simplified = rdpSimplify(boundary, simplifyTolerance);\n        const area = Math.abs(polygonArea(simplified));\n\n        if (area < minArea) continue;\n\n\n        // Find the normal for this region (sample from center)\n        const normal = findRegionNormal(labels, regionMap, normalLookup, width, height, regionId);\n\n        // Sample depth at region center\n        const depth = sampleRegionDepth(labels, depthPixels, width, height, regionId);\n\n        regions.push({\n            boundary: simplified.map(p => new Vector2(\n                (p.x / resolution) - size.x / 2,\n                (p.y / resolution) - size.y / 2  // Y already flipped during readback\n            )),\n            normal,\n            depth,  // 0-1 normalized depth\n            area: area / (resolution * resolution),\n            regionId\n        });\n    }\n\n\n    return regions;\n}\n\n/**\n * Render normals to pixel buffer\n */\nfunction renderNormals(renderer, scene, camera, width, height) {\n    const target = new WebGLRenderTarget(width, height, {\n        minFilter: NearestFilter,\n        magFilter: NearestFilter\n    });\n\n    // Use MeshNormalMaterial for normal extraction\n    // Note: This outputs VIEW SPACE normals, not world space\n    const normalMaterial = new MeshNormalMaterial({ flatShading: true });\n\n    const originalMaterials = new Map();\n    const hiddenObjects = [];\n\n    scene.traverse(obj => {\n        // Only render Mesh objects, hide helpers/lines\n        if (obj.isMesh) {\n            originalMaterials.set(obj, obj.material);\n            obj.material = normalMaterial;\n        } else if (obj.isLineSegments || obj.isLine || obj.isPoints) {\n            // Hide grid helpers, line helpers, etc.\n            if (obj.visible) {\n                hiddenObjects.push(obj);\n                obj.visible = false;\n            }\n        }\n    });\n\n    renderer.setRenderTarget(target);\n    renderer.render(scene, camera);\n\n    scene.traverse(obj => {\n        if (obj.isMesh && originalMaterials.has(obj)) {\n            obj.material = originalMaterials.get(obj);\n        }\n    });\n\n    // Restore hidden objects (grid helpers, lines, etc.)\n    for (const obj of hiddenObjects) {\n        obj.visible = true;\n    }\n\n    renderer.setRenderTarget(null);\n\n    const pixels = new Uint8Array(width * height * 4);\n    renderer.readRenderTargetPixels(target, 0, 0, width, height, pixels);\n\n    target.dispose();\n    normalMaterial.dispose();\n\n    return pixels;\n}\n\n/**\n * Render depth to pixel buffer\n */\nfunction renderDepth(renderer, scene, camera, width, height) {\n    const target = new WebGLRenderTarget(width, height, {\n        minFilter: NearestFilter,\n        magFilter: NearestFilter\n    });\n\n    const depthMaterial = new MeshDepthMaterial({ depthPacking: RGBADepthPacking });\n\n    const originalMaterials = new Map();\n    const hiddenObjects = [];\n\n    scene.traverse(obj => {\n        if (obj.isMesh) {\n            originalMaterials.set(obj, obj.material);\n            obj.material = depthMaterial;\n        } else if (obj.isLineSegments || obj.isLine || obj.isPoints) {\n            if (obj.visible) {\n                hiddenObjects.push(obj);\n                obj.visible = false;\n            }\n        }\n    });\n\n    renderer.setRenderTarget(target);\n    renderer.render(scene, camera);\n\n    scene.traverse(obj => {\n        if (obj.isMesh && originalMaterials.has(obj)) {\n            obj.material = originalMaterials.get(obj);\n        }\n    });\n\n    for (const obj of hiddenObjects) {\n        obj.visible = true;\n    }\n\n    renderer.setRenderTarget(null);\n\n    const pixels = new Uint8Array(width * height * 4);\n    renderer.readRenderTargetPixels(target, 0, 0, width, height, pixels);\n\n    target.dispose();\n    depthMaterial.dispose();\n\n    return pixels;\n}\n\n/**\n * Sample average depth for a region\n */\nfunction sampleRegionDepth(labels, depthPixels, width, height, targetLabel) {\n    let sum = 0, count = 0;\n\n    for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n            if (labels[y * width + x] === targetLabel) {\n                const idx = (y * width + x) * 4;\n                // Unpack RGBA depth\n                const r = depthPixels[idx] / 255;\n                const g = depthPixels[idx + 1] / 255;\n                const b = depthPixels[idx + 2] / 255;\n                const a = depthPixels[idx + 3] / 255;\n                const depth = r + g / 256 + b / 65536 + a / 16777216;\n                sum += depth;\n                count++;\n            }\n        }\n    }\n\n    return count > 0 ? sum / count : 0.5;\n}\n\n/**\n * Morphological erosion on region map\n * Only erodes pixels at the OUTER boundary (next to background 0)\n * Does NOT erode at boundaries between different regions (holes)\n */\nfunction erodeRegionMap(regionMap, width, height, iterations) {\n    let current = regionMap;\n\n    for (let iter = 0; iter < iterations; iter++) {\n        const next = new Uint16Array(current);  // Start with copy\n\n        for (let y = 1; y < height - 1; y++) {\n            for (let x = 1; x < width - 1; x++) {\n                const i = y * width + x;\n                const region = current[i];\n\n                if (region === 0) continue;\n\n                // Check 4-connected neighbors\n                // Only erode if ANY neighbor is background (0)\n                // Don't erode if neighbors are just different regions\n                const left = current[i - 1];\n                const right = current[i + 1];\n                const up = current[i - width];\n                const down = current[i + width];\n\n                if (left === 0 || right === 0 || up === 0 || down === 0) {\n                    next[i] = 0;  // Erode this pixel (it touches background)\n                }\n                // else: keep the pixel even if it touches other regions\n            }\n        }\n\n        current = next;\n    }\n\n    return current;\n}\n\n/**\n * Quantize normals into buckets and create region map\n * Returns regionMap (pixel -> regionId) and normalLookup (regionId -> Vector3)\n */\nfunction quantizeNormals(pixels, width, height, buckets) {\n    const regionMap = new Uint16Array(width * height);\n    const normalLookup = {}; // regionId -> Vector3 normal\n    let nextId = 1;\n    const normalToId = {}; // quantized normal string -> regionId\n\n    for (let i = 0; i < width * height; i++) {\n        const idx = i * 4;\n        const r = pixels[idx];\n        const g = pixels[idx + 1];\n        const b = pixels[idx + 2];\n\n        // Background check (black = no geometry)\n        if (r < 5 && g < 5 && b < 5) {\n            regionMap[i] = 0; // Background\n            continue;\n        }\n\n        // Decode normal from RGB (MeshNormalMaterial encodes: (n+1)/2 * 255)\n        const nx = (r / 255) * 2 - 1;\n        const ny = (g / 255) * 2 - 1;\n        const nz = (b / 255) * 2 - 1;\n\n        // Round RGB to nearest 4 for tolerance at grazing angles\n        // This groups very similar normals together to avoid sub-pixel noise\n        const tolerance = 4;\n        const qr = Math.round(r / tolerance) * tolerance;\n        const qg = Math.round(g / tolerance) * tolerance;\n        const qb = Math.round(b / tolerance) * tolerance;\n        const key = `${qr}|${qg}|${qb}`;\n\n        if (!normalToId[key]) {\n            normalToId[key] = nextId;\n            normalLookup[nextId] = new Vector3(nx, ny, nz).normalize();\n            nextId++;\n        }\n\n        regionMap[i] = normalToId[key];\n    }\n\n    return { regionMap, normalLookup };\n}\n\n/**\n * Connected component labeling using union-find\n */\nfunction connectedComponents(regionMap, width, height) {\n    const labels = new Uint32Array(width * height);\n    const parent = [];\n    let nextLabel = 1;\n\n    function find(x) {\n        if (parent[x] !== x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    function union(x, y) {\n        const px = find(x);\n        const py = find(y);\n        if (px !== py) {\n            parent[py] = px;\n        }\n    }\n\n    // First pass: assign labels\n    for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n            const i = y * width + x;\n            const region = regionMap[i];\n\n            if (region === 0) continue; // Background\n\n            const neighbors = [];\n\n            // Check left neighbor\n            if (x > 0 && regionMap[i - 1] === region && labels[i - 1] > 0) {\n                neighbors.push(labels[i - 1]);\n            }\n            // Check top neighbor\n            if (y > 0 && regionMap[i - width] === region && labels[i - width] > 0) {\n                neighbors.push(labels[i - width]);\n            }\n\n            if (neighbors.length === 0) {\n                // New label\n                labels[i] = nextLabel;\n                parent[nextLabel] = nextLabel;\n                nextLabel++;\n            } else {\n                // Use minimum neighbor label\n                const minLabel = Math.min(...neighbors);\n                labels[i] = minLabel;\n                // Union all neighbors\n                for (const n of neighbors) {\n                    union(minLabel, n);\n                }\n            }\n        }\n    }\n\n    // Second pass: flatten labels\n    const labelRemap = {};\n    let finalLabel = 0;\n\n    for (let i = 0; i < width * height; i++) {\n        if (labels[i] === 0) continue;\n        const root = find(labels[i]);\n        if (labelRemap[root] === undefined) {\n            finalLabel++;\n            labelRemap[root] = finalLabel;\n        }\n        labels[i] = labelRemap[root];\n    }\n\n    return { labels, regionCount: finalLabel };\n}\n\n/**\n * Trace boundary of a labeled region using Moore neighborhood\n */\nfunction traceBoundary(labels, width, height, targetLabel) {\n    const boundary = [];\n\n    // Find starting point (leftmost pixel on top row of region)\n    let startX = -1, startY = -1;\n    outer: for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n            if (labels[y * width + x] === targetLabel) {\n                // Check if it's on boundary (has non-region neighbor)\n                const hasEdge =\n                    x === 0 || labels[y * width + x - 1] !== targetLabel ||\n                    y === 0 || labels[(y - 1) * width + x] !== targetLabel;\n                if (hasEdge) {\n                    startX = x;\n                    startY = y;\n                    break outer;\n                }\n            }\n        }\n    }\n\n    if (startX === -1) return boundary;\n\n    // Moore neighborhood: 8 directions clockwise from right\n    const dx = [1, 1, 0, -1, -1, -1, 0, 1];\n    const dy = [0, 1, 1, 1, 0, -1, -1, -1];\n\n    let x = startX, y = startY;\n    let dir = 7; // Start looking up-right\n    const maxIter = width * height * 2;\n    let iter = 0;\n\n    do {\n        boundary.push({ x, y });\n\n        // Find next boundary pixel\n        let found = false;\n        for (let i = 0; i < 8; i++) {\n            const checkDir = (dir + 6 + i) % 8; // Start from dir-2 (backtrack)\n            const nx = x + dx[checkDir];\n            const ny = y + dy[checkDir];\n\n            if (nx >= 0 && nx < width && ny >= 0 && ny < height) {\n                if (labels[ny * width + nx] === targetLabel) {\n                    x = nx;\n                    y = ny;\n                    dir = checkDir;\n                    found = true;\n                    break;\n                }\n            }\n        }\n\n        if (!found) break;\n        iter++;\n    } while ((x !== startX || y !== startY) && iter < maxIter);\n\n    return boundary;\n}\n\n/**\n * Find representative normal for a region\n */\nfunction findRegionNormal(labels, regionMap, normalLookup, width, height, targetLabel) {\n    // Find center of region and sample normal\n    let sumX = 0, sumY = 0, count = 0;\n    for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n            if (labels[y * width + x] === targetLabel) {\n                sumX += x;\n                sumY += y;\n                count++;\n            }\n        }\n    }\n\n    if (count === 0) return new Vector3(0, 0, 1);\n\n    const cx = Math.round(sumX / count);\n    const cy = Math.round(sumY / count);\n    const i = cy * width + cx;\n    const normalId = regionMap[i];\n\n    return normalLookup[normalId] || new Vector3(0, 0, 1);\n}\n\n/**\n * Ramer-Douglas-Peucker simplification\n */\nfunction rdpSimplify(points, epsilon) {\n    if (points.length < 3) return points;\n\n    let maxDist = 0, maxIdx = 0;\n    const first = points[0];\n    const last = points[points.length - 1];\n\n    for (let i = 1; i < points.length - 1; i++) {\n        const dist = perpendicularDistance(points[i], first, last);\n        if (dist > maxDist) {\n            maxDist = dist;\n            maxIdx = i;\n        }\n    }\n\n    if (maxDist > epsilon) {\n        const left = rdpSimplify(points.slice(0, maxIdx + 1), epsilon);\n        const right = rdpSimplify(points.slice(maxIdx), epsilon);\n        return left.slice(0, -1).concat(right);\n    } else {\n        return [first, last];\n    }\n}\n\nfunction perpendicularDistance(point, lineStart, lineEnd) {\n    const dx = lineEnd.x - lineStart.x;\n    const dy = lineEnd.y - lineStart.y;\n    const lenSq = dx * dx + dy * dy;\n    if (lenSq < 1e-10) {\n        return Math.sqrt((point.x - lineStart.x) ** 2 + (point.y - lineStart.y) ** 2);\n    }\n    const t = ((point.x - lineStart.x) * dx + (point.y - lineStart.y) * dy) / lenSq;\n    const projX = lineStart.x + t * dx;\n    const projY = lineStart.y + t * dy;\n    return Math.sqrt((point.x - projX) ** 2 + (point.y - projY) ** 2);\n}\n\nfunction polygonArea(points) {\n    let area = 0;\n    for (let i = 0; i < points.length; i++) {\n        const j = (i + 1) % points.length;\n        area += points[i].x * points[j].y;\n        area -= points[j].x * points[i].y;\n    }\n    return area / 2;\n}\n\n/**\n * Debug visualization: show normal regions colored by their normal direction\n */\nexport function debugNormalRegions(renderer, scene, camera) {\n    const size = renderer.getSize(new Vector2());\n    const width = Math.floor(size.x);\n    const height = Math.floor(size.y);\n\n    const normalPixels = renderNormals(renderer, scene, camera, width, height);\n    const { regionMap, normalLookup } = quantizeNormals(normalPixels, width, height, 12);\n    const { labels, regionCount } = connectedComponents(regionMap, width, height);\n\n\n\n    // Create visualization\n    const canvas = document.createElement('canvas');\n    canvas.width = width;\n    canvas.height = height;\n    const ctx = canvas.getContext('2d');\n    const imageData = ctx.createImageData(width, height);\n\n    // Generate colors for each region\n    const regionColors = {};\n    for (let i = 1; i <= regionCount; i++) {\n        const hue = (i * 137.508) % 360; // Golden angle for good distribution\n        regionColors[i] = hslToRgb(hue / 360, 0.7, 0.5);\n    }\n\n    for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n            const srcIdx = (height - 1 - y) * width + x;\n            const dstIdx = (y * width + x) * 4;\n            const label = labels[srcIdx];\n\n            if (label === 0) {\n                imageData.data[dstIdx] = 30;\n                imageData.data[dstIdx + 1] = 30;\n                imageData.data[dstIdx + 2] = 30;\n            } else {\n                const [r, g, b] = regionColors[label] || [128, 128, 128];\n                imageData.data[dstIdx] = r;\n                imageData.data[dstIdx + 1] = g;\n                imageData.data[dstIdx + 2] = b;\n            }\n            imageData.data[dstIdx + 3] = 255;\n        }\n    }\n    ctx.putImageData(imageData, 0, 0);\n\n    // Show modal\n    const modal = document.createElement('div');\n    modal.style.cssText = 'position:fixed;top:0;left:0;width:100vw;height:100vh;background:rgba(0,0,0,0.8);display:flex;align-items:center;justify-content:center;z-index:10000;cursor:pointer;';\n    modal.onclick = () => modal.remove();\n    canvas.style.cssText = 'max-width:90vw;max-height:90vh;border:2px solid lime;';\n    const info = document.createElement('div');\n    info.style.cssText = 'position:absolute;top:20px;left:20px;color:lime;font-family:monospace;';\n    info.textContent = `${regionCount} regions, ${Object.keys(normalLookup).length} normal buckets (click to close)`;\n    modal.appendChild(canvas);\n    modal.appendChild(info);\n    document.body.appendChild(modal);\n}\n\nfunction hslToRgb(h, s, l) {\n    let r, g, b;\n    if (s === 0) {\n        r = g = b = l;\n    } else {\n        const hue2rgb = (p, q, t) => {\n            if (t < 0) t += 1;\n            if (t > 1) t -= 1;\n            if (t < 1 / 6) return p + (q - p) * 6 * t;\n            if (t < 1 / 2) return q;\n            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n            return p;\n        };\n        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n        const p = 2 * l - q;\n        r = hue2rgb(p, q, h + 1 / 3);\n        g = hue2rgb(p, q, h);\n        b = hue2rgb(p, q, h - 1 / 3);\n    }\n    return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];\n}\n","/**\n * Perspective Hatching\n * \n * Generates architect-style perspective hatches that converge toward\n * vanishing points based on face orientation.\n */\n\nimport { Vector2, Vector3 } from 'three';\n\n/**\n * @typedef {Object} HatchLine\n * @property {Vector2} start\n * @property {Vector2} end\n */\n\n/**\n * Compute the 2D hatch direction for a face based on its normal\n * Projects the face's primary axis to screen space\n * @param {Vector3} normal - Face normal in world space\n * @param {Camera} camera - Three.js camera\n * @param {number} screenWidth\n * @param {number} screenHeight\n * @returns {{direction: Vector2, vanishingPoint: Vector2|null}}\n */\nexport function computeHatchDirection(normal, camera, screenWidth, screenHeight) {\n    const halfW = screenWidth / 2;\n    const halfH = screenHeight / 2;\n\n    // Find a primary axis direction in the face plane\n    // For most faces, use the horizontal (XZ) direction projected onto the face\n    const worldUp = new Vector3(0, 1, 0);\n    const worldForward = new Vector3(0, 0, 1);\n\n    // Get a vector in the face plane\n    let faceAxis;\n\n    // For horizontal faces (floor/ceiling), use world Z direction\n    if (Math.abs(normal.y) > 0.9) {\n        faceAxis = worldForward.clone();\n    } else {\n        // For vertical/angled faces, use horizontal direction in face plane\n        // This is the cross product of normal with world up, gives horizontal direction in face\n        faceAxis = new Vector3().crossVectors(worldUp, normal).normalize();\n\n        // If face is vertical and facing up/down, cross product might be zero\n        if (faceAxis.lengthSq() < 0.01) {\n            faceAxis = worldForward.clone();\n        }\n    }\n\n    // Project two points along this axis to screen to get 2D direction\n    const origin = new Vector3(0, 0, 0);\n    const farPoint = faceAxis.clone().multiplyScalar(100);\n\n    const originScreen = origin.clone().project(camera);\n    const farScreen = farPoint.clone().project(camera);\n\n    // Convert to screen pixels\n    const screenOrigin = new Vector2(\n        originScreen.x * halfW,\n        -originScreen.y * halfH\n    );\n    const screenFar = new Vector2(\n        farScreen.x * halfW,\n        -farScreen.y * halfH\n    );\n\n    // 2D direction on screen\n    const direction = screenFar.clone().sub(screenOrigin).normalize();\n\n    // Compute vanishing point by projecting point at infinity along this direction\n    // VP is where parallel 3D lines converge in 2D\n    const veryFarPoint = faceAxis.clone().multiplyScalar(100000);\n    const vpProjected = veryFarPoint.clone().project(camera);\n\n    // Check if VP is visible/finite\n    let vanishingPoint = null;\n    if (Math.abs(vpProjected.x) < 100 && Math.abs(vpProjected.y) < 100 && vpProjected.z < 1) {\n        vanishingPoint = new Vector2(\n            vpProjected.x * halfW,\n            -vpProjected.y * halfH\n        );\n    }\n\n    return { direction, vanishingPoint };\n}\n\n/**\n * Generate perspective hatch lines for a region\n * @param {Object} region - Region from extractNormalRegions\n * @param {Camera} camera\n * @param {Object} options\n * @returns {HatchLine[]}\n */\nexport function generatePerspectiveHatches(region, camera, options = {}) {\n    const {\n        baseSpacing = 8,      // Base spacing in screen pixels\n        minSpacing = 3,       // Minimum spacing\n        maxSpacing = 20,      // Maximum spacing\n        depthFactor = 0.5,    // How much depth affects density\n        screenWidth = 1200,\n        screenHeight = 800,\n        axisSettings = {}     // { x: { rotation: 0, spacing: 10 }, y: ... }\n    } = options;\n\n    const { boundary, normal, depth = 0.5 } = region;\n    if (boundary.length < 3) return [];\n\n    // Determine dominant axis\n    const ax = Math.abs(normal.x);\n    const ay = Math.abs(normal.y);\n    const az = Math.abs(normal.z);\n\n    let axis = 'y'; // default up\n    if (ax >= ay && ax >= az) axis = 'x';\n    else if (az >= ay && az >= ax) axis = 'z';\n\n    // Get settings for this axis\n    const settings = axisSettings[axis] || {};\n    const rotationDeg = settings.rotation || 0;\n    const spacingOverride = settings.spacing;\n\n    console.log(`[Hatch] normal=(${normal.x.toFixed(2)}, ${normal.y.toFixed(2)}, ${normal.z.toFixed(2)}) => axis=${axis}, rotation=${rotationDeg}, spacing=${spacingOverride}`);\n\n    // Get hatch direction from normal\n    const { direction, vanishingPoint } = computeHatchDirection(\n        normal, camera, screenWidth, screenHeight\n    );\n\n    // Apply rotation if needed\n    let finalDirection = direction;\n    if (rotationDeg !== 0) {\n        const rad = rotationDeg * (Math.PI / 180);\n        const cos = Math.cos(rad);\n        const sin = Math.sin(rad);\n        finalDirection = new Vector2(\n            direction.x * cos - direction.y * sin,\n            direction.x * sin + direction.y * cos\n        );\n    }\n\n    // Perpendicular direction for spacing\n    const perpDir = new Vector2(-finalDirection.y, finalDirection.x);\n\n    // Calculate spacing based on depth (closer = denser)\n    // Use override if available, otherwise baseSpacing\n    const effectiveBase = spacingOverride !== undefined ? spacingOverride : baseSpacing;\n    const spacing = Math.max(minSpacing, Math.min(maxSpacing,\n        effectiveBase + (depth * depthFactor * (maxSpacing - minSpacing))\n    ));\n\n    // Get bounding box of region\n    let minX = Infinity, maxX = -Infinity;\n    let minY = Infinity, maxY = -Infinity;\n    for (const pt of boundary) {\n        minX = Math.min(minX, pt.x);\n        maxX = Math.max(maxX, pt.x);\n        minY = Math.min(minY, pt.y);\n        maxY = Math.max(maxY, pt.y);\n    }\n\n    const centerX = (minX + maxX) / 2;\n    const centerY = (minY + maxY) / 2;\n    const center = new Vector2(centerX, centerY);\n\n    // Size of region along perpendicular direction\n    const diag = Math.sqrt((maxX - minX) ** 2 + (maxY - minY) ** 2);\n\n    const hatches = [];\n\n    // If rotated, we can't easily use the VP logic unless we rotate the VP too, \n    // but typically architectural hatching with rotation implies a pattern override, \n    // so we'll often fall back to parallel for rotated patterns unless it's 0/90.\n    // For now, if rotation is significant, force parallel to avoid weird VP artifacts.\n    // OR: Rotate the vector from VP to center? \n    // Let's stick to parallel for significantly rotated hatches to keep it clean for now,\n    // as \"perspective rotated hatching\" is geometrically ambiguous.\n    const usePerspective = vanishingPoint && Math.abs(rotationDeg) < 5 && vanishingPoint.distanceTo(center) < diag * 5;\n\n    if (usePerspective) {\n        // Perspective lines converging to visible VP\n        const vpDist = vanishingPoint.distanceTo(center);\n\n        // Generate lines radiating from VP\n        const numLines = Math.ceil(diag / spacing) * 2;\n        const angularSpan = Math.atan2(diag, vpDist);\n        const angleStep = angularSpan * 2 / numLines;\n\n        // Angle from VP to center\n        const centerAngle = Math.atan2(\n            centerY - vanishingPoint.y,\n            centerX - vanishingPoint.x\n        );\n\n        for (let i = -numLines; i <= numLines; i++) {\n            const angle = centerAngle + i * angleStep;\n            const dir = new Vector2(Math.cos(angle), Math.sin(angle));\n\n            // Line from VP extending far past region\n            const lineStart = vanishingPoint.clone();\n            const lineEnd = vanishingPoint.clone().add(dir.clone().multiplyScalar(vpDist * 10));\n\n            const clipped = clipLineToPolygon({ start: lineStart, end: lineEnd }, boundary);\n            hatches.push(...clipped);\n        }\n    } else {\n        // Parallel lines (VP at infinity or very far)\n        const numLines = Math.ceil(diag / spacing) + 2;\n\n        for (let i = -numLines; i <= numLines; i++) {\n            // Offset along perpendicular direction\n            const offset = perpDir.clone().multiplyScalar(i * spacing);\n            const lineCenter = center.clone().add(offset);\n\n            // Line extending in hatch direction\n            const lineStart = lineCenter.clone().add(finalDirection.clone().multiplyScalar(-diag));\n            const lineEnd = lineCenter.clone().add(finalDirection.clone().multiplyScalar(diag));\n\n            const clipped = clipLineToPolygon({ start: lineStart, end: lineEnd }, boundary);\n            hatches.push(...clipped);\n        }\n    }\n\n    return hatches;\n}\n\n/**\n * Clip a line to a polygon\n */\nexport function clipLineToPolygon(line, polygon) {\n    const intersections = [];\n    const n = polygon.length;\n\n    for (let i = 0; i < n; i++) {\n        const p1 = polygon[i];\n        const p2 = polygon[(i + 1) % n];\n\n        const intersection = lineIntersection(\n            line.start.x, line.start.y, line.end.x, line.end.y,\n            p1.x, p1.y, p2.x, p2.y\n        );\n\n        if (intersection) {\n            intersections.push({\n                point: new Vector2(intersection.x, intersection.y),\n                t: intersection.t\n            });\n        }\n    }\n\n    if (intersections.length < 2) return [];\n\n    // Sort by parameter along line\n    intersections.sort((a, b) => a.t - b.t);\n\n    // Create segments between consecutive pairs, checking midpoint is inside\n    const result = [];\n    for (let i = 0; i < intersections.length - 1; i++) {\n        const midX = (intersections[i].point.x + intersections[i + 1].point.x) / 2;\n        const midY = (intersections[i].point.y + intersections[i + 1].point.y) / 2;\n\n        if (pointInPolygon(midX, midY, polygon)) {\n            result.push({\n                start: intersections[i].point,\n                end: intersections[i + 1].point\n            });\n        }\n    }\n\n    return result;\n}\n\n/**\n * Clip a line to OUTSIDE a polygon (inverse of clipLineToPolygon)\n * Returns segments that are OUTSIDE the polygon\n */\nexport function clipLineOutsidePolygon(line, polygon) {\n    const intersections = [];\n    const n = polygon.length;\n\n    // Add start and end points\n    const startInside = pointInPolygon(line.start.x, line.start.y, polygon);\n    const endInside = pointInPolygon(line.end.x, line.end.y, polygon);\n\n    intersections.push({ point: line.start.clone(), t: 0, inside: startInside });\n\n    // Find all intersections with polygon edges\n    for (let i = 0; i < n; i++) {\n        const p1 = polygon[i];\n        const p2 = polygon[(i + 1) % n];\n\n        const intersection = lineIntersectionFull(\n            line.start.x, line.start.y, line.end.x, line.end.y,\n            p1.x, p1.y, p2.x, p2.y\n        );\n\n        if (intersection && intersection.t > 0 && intersection.t < 1) {\n            intersections.push({\n                point: new Vector2(intersection.x, intersection.y),\n                t: intersection.t,\n                inside: null // will be determined by neighbors\n            });\n        }\n    }\n\n    intersections.push({ point: line.end.clone(), t: 1, inside: endInside });\n\n    // Sort by parameter\n    intersections.sort((a, b) => a.t - b.t);\n\n    // Remove duplicates (points too close together)\n    const filtered = [intersections[0]];\n    for (let i = 1; i < intersections.length; i++) {\n        if (intersections[i].t - filtered[filtered.length - 1].t > 0.0001) {\n            filtered.push(intersections[i]);\n        }\n    }\n\n    if (filtered.length < 2) return [line]; // No intersections, check if line is outside\n\n    // Build segments that are OUTSIDE\n    const result = [];\n    for (let i = 0; i < filtered.length - 1; i++) {\n        const midT = (filtered[i].t + filtered[i + 1].t) / 2;\n        const midX = line.start.x + midT * (line.end.x - line.start.x);\n        const midY = line.start.y + midT * (line.end.y - line.start.y);\n\n        // If midpoint is OUTSIDE polygon, include this segment\n        if (!pointInPolygon(midX, midY, polygon)) {\n            result.push({\n                start: filtered[i].point.clone(),\n                end: filtered[i + 1].point.clone()\n            });\n        }\n    }\n\n    return result;\n}\n\n// Full line intersection (both segments)\nfunction lineIntersectionFull(x1, y1, x2, y2, x3, y3, x4, y4) {\n    const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n    if (Math.abs(denom) < 1e-10) return null;\n\n    const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;\n    const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;\n\n    if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {\n        return {\n            x: x1 + t * (x2 - x1),\n            y: y1 + t * (y2 - y1),\n            t\n        };\n    }\n    return null;\n}\n\nfunction lineIntersection(x1, y1, x2, y2, x3, y3, x4, y4) {\n    const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n    if (Math.abs(denom) < 1e-10) return null;\n\n    const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;\n    const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;\n\n    if (u >= 0 && u <= 1) {\n        return {\n            x: x1 + t * (x2 - x1),\n            y: y1 + t * (y2 - y1),\n            t\n        };\n    }\n    return null;\n}\n\nfunction pointInPolygon(x, y, polygon) {\n    let inside = false;\n    const n = polygon.length;\n\n    for (let i = 0, j = n - 1; i < n; j = i++) {\n        const xi = polygon[i].x, yi = polygon[i].y;\n        const xj = polygon[j].x, yj = polygon[j].y;\n\n        if (((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) {\n            inside = !inside;\n        }\n    }\n\n    return inside;\n}\n","const EPSILON = 0.001;\n\nexport class Point {\n  /**\n   * @param {number} x\n   * @param {number} y\n   */\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n  /**\n   * @param {Point} pt\n   */\n  static clone(pt) {\n    return new Point(pt.x, pt.y);\n  }\n}\n\nexport class BoundingBox {\n  /**\n   * @param {number} minX\n   * @param {number} minY\n   * @param {number} maxX\n   * @param {number} maxY\n   */\n  constructor(minX, minY, maxX, maxY) {\n    this.minX = minX;\n    this.minY = minY;\n    this.maxX = maxX;\n    this.maxY = maxY;\n  }\n  width() {\n    return Math.abs(this.maxX - this.minX);\n  }\n  height() {\n    return Math.abs(this.maxY - this.minY);\n  }\n}\n\nexport class BoundingCircle {\n  /**\n   *\n   * @param {number} r radius\n   */\n  constructor(r = 0) {\n    this.r = r;\n  }\n}\n\nexport class Segment {\n  /**\n   *\n   * @param {Point} a start point\n   * @param {Point} b end point\n   */\n  constructor(a, b) {\n    this.a = a;\n    this.b = b;\n    this.tags = {};\n  }\n\n  /**\n   *\n   * @param {Segment} segA\n   * @param {Segment} segB\n   */\n  static isEqual(segA, segB) {\n    return (\n      (GeomUtil.pointsEqual(segA.a, segB.a) && GeomUtil.pointsEqual(segA.b, segB.b)) ||\n      (GeomUtil.pointsEqual(segA.b, segB.a) && GeomUtil.pointsEqual(segA.a, segB.b))\n    );\n  }\n\n  /**\n   * @param {Segment} seg\n   */\n  static clone(seg) {\n    return new Segment(new Point(seg.a.x, seg.a.y), new Point(seg.b.x, seg.b.y));\n  }\n}\n\nexport class SegmentCollection {\n  constructor() {\n    this.pivot = { x: 0, y: 0 };\n    this.rotation = 0;\n    this.isOpen = true;\n    this.isGroup = false;\n    this.isStrong = false;\n    /**\n     *\n     * @param {Point[]} pts\n     */\n    this._makeAbsolute = (pts) => {\n      let rot = (this.rotation * Math.PI) / 180;\n      pts.forEach((pt, idx) => {\n        const ptA = { x: pt.x, y: pt.y };\n        GeomUtil.rotatePoint(ptA, rot);\n        ptA.x += this.pivot.x;\n        ptA.y += this.pivot.y;\n        pts[idx] = ptA;\n      });\n    };\n    /**\n     *\n     * @param {Segment[]} segs\n     */\n    this._makeSegsAbsolute = (segs) => {\n      let rot = (this.rotation * Math.PI) / 180;\n      segs.forEach((seg) => {\n        const ptA = { x: seg.a.x, y: seg.a.y };\n        const ptB = { x: seg.b.x, y: seg.b.y };\n        GeomUtil.rotatePoint(ptA, rot);\n        GeomUtil.rotatePoint(ptB, rot);\n        GeomUtil.addToPoint(ptA, this.pivot);\n        GeomUtil.addToPoint(ptB, this.pivot);\n        seg.a = ptA;\n        seg.b = ptB;\n      });\n    };\n  }\n\n  /**\n   * @param {boolean} local\n   * @returns {Point[]}\n   */\n  toPoints(local = false) {\n    throw \"not implemented\";\n  }\n\n  /**\n   *\n   * @param {boolean} local\n   * @returns {Segment[]};\n   */\n  toSegments(local = false) {\n    throw \"not implemented\";\n  }\n\n  /**\n   *\n   * @param {boolean} local\n   * @returns {BoundingBox}\n   */\n  getBoundingBox(local = false) {\n    const bb = new BoundingBox(1000000, 1000000, -1000000, -1000000);\n    const pts = this.toPoints(local);\n    pts.forEach((pt) => {\n      bb.minX = Math.min(bb.minX, pt.x);\n      bb.minY = Math.min(bb.minY, pt.y);\n      bb.maxX = Math.max(bb.maxX, pt.x);\n      bb.maxY = Math.max(bb.maxY, pt.y);\n    });\n\n    return bb;\n  }\n\n  /**\n   * @returns {BoundingCircle}\n   */\n  getBoundingCircle() {\n    const bc = new BoundingCircle();\n    const pts = this.toPoints(true);\n    pts.forEach((pt) => {\n      bc.r = Math.max(bc.r, Math.sqrt(pt.x * pt.x + pt.y * pt.y));\n    });\n    return bc;\n  }\n}\n\nexport class Segments extends SegmentCollection {\n  /**\n   *\n   * @param {Segment[]} segments\n   */\n  constructor(segments) {\n    super();\n    /** @type {Segment[]} */\n    this._segments = segments;\n  }\n\n  /**\n   * @param {Segment[]} segs\n   */\n  add(...segs) {\n    this._segments = this._segments.concat(segs);\n  }\n\n  /**\n   * @param {boolean} local\n   * @returns {Point[]}\n   */\n  toPoints(local = false) {\n    return this.toSegments(local).reduce((arr, seg) => (seg ? arr.concat([seg.a, seg.b]) : arr), []);\n  }\n  /**\n   *\n   * @param {boolean} local\n   * @returns {Segment[]};\n   */\n  toSegments(local = false) {\n    let segs = this._segments.reduce((arr, seg) => (seg ? arr.concat(Segment.clone(seg)) : arr), []);\n    if (!local) {\n      this._makeSegsAbsolute(segs);\n    }\n    return segs;\n  }\n\n  bake() {\n    // noOp\n  }\n\n  result() {\n    return Segments.clone(this);\n  }\n\n  /**\n   *\n   * @param {Segments} segs\n   */\n  static clone(segs) {\n    let sA = segs._segments;\n    let sB = [];\n    let i = sA.length;\n    while (i--) {\n      sB.unshift(Segment.clone(sA[i]));\n    }\n    let s = new Segments(sB);\n    s.pivot.x = segs.pivot.x;\n    s.pivot.y = segs.pivot.y;\n    s.rotation = segs.rotation;\n    return s;\n  }\n}\n\nexport class GeomUtil {\n  /**\n   *\n   * @param {number} a\n   * @param {number} b\n   * @param {number} d\n   * @returns {number}\n   */\n  static lerp(a, b, d) {\n    return (1 - d) * a + d * b;\n  }\n\n  /**\n   *\n   * @param {Point} ptA\n   * @param {Point} ptB\n   */\n  static angleBetween(ptA, ptB) {\n    return Math.atan2(ptB.y - ptA.y, ptB.x - ptA.x);\n  }\n\n  /**\n   *\n   * @param {Segment} segA\n   * @param {Segment} segB\n   */\n  static sameAngle(segA, segB) {\n    let aA = GeomUtil.angleBetween(segA.a, segA.b);\n    let aB = GeomUtil.angleBetween(segB.a, segB.b);\n\n    return Math.abs(aA - aB) < EPSILON;\n  }\n\n  /**\n   *\n   * @param {Segment} segA\n   * @param {Segment} segB\n   */\n  static sameAngleRev(segA, segB) {\n    let aA = GeomUtil.angleBetween(segA.a, segA.b);\n    let aB = GeomUtil.angleBetween(segB.b, segB.a);\n\n    return Math.abs(aA - aB) < EPSILON;\n  }\n\n  /**\n   *\n   * @param {Point} ptA\n   * @param {Point} ptB\n   * @param {number} d\n   * @returns {Point}\n   */\n  static lerpPoints(ptA, ptB, d) {\n    return {\n      x: GeomUtil.lerp(ptA.x, ptB.x, d),\n      y: GeomUtil.lerp(ptA.y, ptB.y, d),\n    };\n  }\n\n  /**\n   *\n   * @param {Point} pt the point to rotate in place\n   * @param {number} deg angle in degrees\n   */\n  static rotatePointDeg(pt, deg) {\n    GeomUtil.rotatePoint(pt, (deg * Math.PI) / 180);\n  }\n\n  /**\n   *\n   * @param {Point} pt\n   * @param {*} rad\n   */\n  static rotatePoint(pt, rad) {\n    const cos = Math.cos(rad);\n    const sin = Math.sin(rad);\n\n    const oldY = pt.y;\n    const oldX = pt.x;\n\n    pt.y = cos * oldY - sin * oldX;\n    pt.x = sin * oldY + cos * oldX;\n  }\n\n  /**\n   *\n   * @param {number} rad\n   * @param  {...Point} points\n   */\n  static rotatePoints(rad, ...points) {\n    points.forEach((pt) => {\n      GeomUtil.rotatePoint(pt, rad);\n    });\n  }\n\n  /**\n   *\n   * @param {number} deg\n   * @param  {...Point} points\n   */\n  static rotatePointsDeg(deg, ...points) {\n    let rad = (deg * Math.PI) / 180;\n    points.forEach((pt) => {\n      GeomUtil.rotatePoint(pt, rad);\n    });\n  }\n\n  // Based on http://stackoverflow.com/a/12037737\n\n  static outerTangents(ptA, rA, ptB, rB) {\n    var dx = ptB.x - ptA.x;\n    var dy = ptB.y - ptA.y;\n    var dist = Math.sqrt(dx * dx + dy * dy);\n\n    if (dist <= Math.abs(rB - rA)) return []; // no valid tangents\n\n    // Rotation from x-axis\n    var angle1 = Math.atan2(dy, dx);\n    var angle2 = Math.acos((rA - rB) / dist);\n\n    return [\n      new Segment(\n        {\n          x: ptA.x + rA * Math.cos(angle1 + angle2),\n          y: ptA.y + rA * Math.sin(angle1 + angle2),\n        },\n        {\n          x: ptB.x + rB * Math.cos(angle1 + angle2),\n          y: ptB.y + rB * Math.sin(angle1 + angle2),\n        }\n      ),\n      new Segment(\n        {\n          x: ptA.x + rA * Math.cos(angle1 - angle2),\n          y: ptA.y + rA * Math.sin(angle1 - angle2),\n        },\n        {\n          x: ptB.x + rB * Math.cos(angle1 - angle2),\n          y: ptB.y + rB * Math.sin(angle1 - angle2),\n        }\n      ),\n    ];\n  }\n\n  /**\n   *\n   * @param {Point} pt\n   */\n  static cartesian2Polar(pt) {\n    const d = Math.sqrt(pt.x * pt.x + pt.y * pt.y);\n    const r = Math.atan2(pt.y, pt.x);\n    pt.x = d;\n    pt.y = r;\n  }\n\n  /**\n   *\n   * @param {Point} ptA\n   * @param {Point} ptB\n   * @param {number} [scale]\n   */\n  static pointsEqual(ptA, ptB, scale = 1) {\n    return (\n      Math.round(ptA.x * 10000 / scale) == Math.round(ptB.x * 10000 / scale) && Math.round(ptA.y * 10000 / scale) == Math.round(ptB.y * 10000 / scale)\n    );\n  }\n\n  /**\n   *\n   * @param {Point} ptA\n   * @param {Point} ptB\n   * @returns {number}\n   */\n  static distanceBetween(ptA, ptB) {\n    const dx = ptB.x - ptA.x;\n    const dy = ptB.y - ptA.y;\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n  /**\n   *\n   * @param {Point} ptA\n   * @param {Point} ptB\n   * @returns {number}\n   */\n  static distanceBetweenSquared(ptA, ptB) {\n    const dx = ptB.x - ptA.x;\n    const dy = ptB.y - ptA.y;\n    return dx * dx + dy * dy;\n  }\n\n  /**\n   *\n   * @param {Point} ptA\n   * @param {Point} ptB\n   * @param {number} numSegs\n   * @returns {Point[]}\n   */\n  static interpolatePoints(ptA, ptB, numSegs) {\n    let pts = [{ x: ptA.x, y: ptA.y }];\n    let perc = 1 / numSegs;\n    let deltaX = (ptB.x - ptA.x) * perc;\n    let deltaY = (ptB.y - ptA.y) * perc;\n    for (var i = 1; i < numSegs; i++) {\n      pts.push(new Point(ptA.x + deltaX * i, ptA.y + deltaY * i));\n    }\n    pts.push({ x: ptB.x, y: ptB.y });\n    return pts;\n  }\n\n  /**\n   *\n   * @param  {...Point} pts\n   */\n  static averagePoints(...pts) {\n    let a = new Point(0, 0);\n    pts.forEach((pt) => {\n      a.x += pt.x;\n      a.y += pt.y;\n    });\n    a.x /= pts.length;\n    a.y /= pts.length;\n    return a;\n  }\n\n  /**\n   *\n   * @param {Point} targetPt the point that will be added to\n   * @param {Point} sourcePt the point to add to the target\n   */\n  static addToPoint(targetPt, sourcePt) {\n    targetPt.x += sourcePt.x;\n    targetPt.y += sourcePt.y;\n  }\n\n  /**\n   *\n   * @param {Point} targetPt the point that will be subtracted from\n   * @param {Point} sourcePt the point tosubtract from the target\n   */\n  static subFromPoint(targetPt, sourcePt) {\n    targetPt.x -= sourcePt.x;\n    targetPt.y -= sourcePt.y;\n  }\n\n  /**\n   *\n   * @param {Point} ptA\n   * @param {Point} ptB\n   * @param {number} delta\n   * @returns {Point[]}\n   */\n  static subdivideByDistance(ptA, ptB, delta) {\n    if (delta === 0) {\n      return [ptA, ptB];\n    }\n    let pts = [{ x: ptA.x, y: ptA.y }];\n    let dist = GeomUtil.distanceBetween(ptA, ptB);\n    let perc = delta / dist;\n    let numFit = Math.floor(1 / perc);\n    let remain = dist % delta;\n    delta += remain / numFit;\n    perc = delta / dist;\n    let travel = perc;\n    let i = 1;\n    let deltaX = (ptB.x - ptA.x) * perc;\n    let deltaY = (ptB.y - ptA.y) * perc;\n    while (travel < 1) {\n      pts.push(new Point(ptA.x + deltaX * i, ptA.y + deltaY * i));\n      travel += perc;\n      i++;\n    }\n    pts.push({ x: ptB.x, y: ptB.y });\n    return pts;\n  }\n\n  /**\n   *\n   * @param {Segment} segA\n   * @param {Segment} segB\n   * @param {number} [scale]\n   */\n  static segmentsConnected(segA, segB, scale = 1) {\n    return GeomUtil.pointsEqual(segA.b, segB.a, scale) || GeomUtil.pointsEqual(segA.a, segB.b, scale);\n  }\n\n  /**\n   *\n   * @param {Segment[]} segs\n   * @returns {Point[]}\n   */\n  static segmentsToPoints(segs) {\n    let pts = segs.reduce((arr, seg) => {\n      return arr.concat(seg.a, seg.b);\n    }, []);\n    let i = pts.length;\n    while (i--) {\n      let pt = pts[i];\n      if (i > 0 && GeomUtil.pointsEqual(pt, pts[i - 1])) {\n        pts.splice(i, 1);\n      }\n    }\n    return pts;\n  }\n\n  /**\n   *\n   * @param {Point[]} pts\n   * @returns {number}\n   */\n  static polygonArea(pts) {\n    let area = 0;\n    let j = pts.length - 1;\n    for (var i = 0; i < pts.length; i++) {\n      area += pts[i].x * pts[j].y;\n      area -= pts[j].x * pts[i].y;\n      j = i;\n    }\n    return area / 2;\n  }\n\n  /**\n   *\n   * @param {Point[]} pts\n   * @returns {BoundingBox}\n   */\n  static pointsBoundingBox(pts) {\n    const b = new BoundingBox(1000000, 1000000, -1000000, -1000000);\n\n    pts.forEach((pt) => {\n      b.minX = Math.min(b.minX, pt.x);\n      b.minY = Math.min(b.minY, pt.y);\n      b.maxX = Math.max(b.maxX, pt.x);\n      b.maxY = Math.max(b.maxY, pt.y);\n    });\n\n    return b;\n  }\n\n  /**\n   *\n   * @param {BoundingBox[]} bbs\n   * @returns {BoundingBox}\n   */\n  static boundingBoxesBoundingBox(bbs) {\n    const b = new BoundingBox(1000000, 1000000, -1000000, -1000000);\n\n    bbs.forEach((bb) => {\n      b.minX = Math.min(b.minX, bb.minX);\n      b.minY = Math.min(b.minY, bb.minY);\n      b.maxX = Math.max(b.maxX, bb.maxX);\n      b.maxY = Math.max(b.maxY, bb.maxY);\n    });\n\n    return b;\n  }\n\n  /**\n   *\n   * @param {Segment[]} segs\n   * @returns {BoundingBox}\n   */\n  static segmentsBoundingBox(segs) {\n    const pts = [];\n    segs.forEach((seg) => {\n      pts.push(seg.a);\n      pts.push(seg.b);\n    });\n    return GeomUtil.pointsBoundingBox(pts);\n  }\n\n  /**\n   *\n   * @param {BoundingBox} ab\n   * @param {BoundingBox} bb\n   */\n  static boundingBoxesIntersect(ab, bb) {\n    return ab.maxX >= bb.minX && ab.maxY >= bb.minY && ab.minX <= bb.maxX && ab.minY <= bb.maxY;\n  }\n\n  /**\n   *\n   * @param {Point[]} pts\n   * @returns {boolean}\n   */\n  static polygonIsClockwise(pts) {\n    return GeomUtil.polygonArea(pts) > 0;\n  }\n\n  /**\n   *\n   * @param {Point} p1\n   * @param {Point} p2\n   * @param {Point} p3\n   */\n  static ccw(p1, p2, p3) {\n    return (p3.y - p1.y) * (p2.x - p1.x) > (p2.y - p1.y) * (p3.x - p1.x);\n  }\n\n  /**\n   *\n   * @param {Segment} segA\n   * @param {Segment} segB\n   * @returns {boolean}\n   */\n  static segmentsIntersect(segA, segB) {\n    const fn = GeomUtil.ccw;\n    return (\n      fn(segA.a, segB.a, segB.b) != fn(segA.b, segB.a, segB.b) &&\n      fn(segA.a, segA.b, segB.a) != fn(segA.a, segA.b, segB.b)\n    );\n  }\n\n  /**\n   *\n   * @param {Segment} segA\n   * @param {Segment} segB\n   * @returns {Point}\n   */\n  static segmentSegmentIntersect(segA, segB, ignoreTouching = false) {\n    const x1 = segA.a.x;\n    const y1 = segA.a.y;\n    const x2 = segA.b.x;\n    const y2 = segA.b.y;\n    const x3 = segB.a.x;\n    const y3 = segB.a.y;\n    const x4 = segB.b.x;\n    const y4 = segB.b.y;\n\n    const s1_x = x2 - x1;\n    const s1_y = y2 - y1;\n    const s2_x = x4 - x3;\n    const s2_y = y4 - y3;\n\n    const s = (-s1_y * (x1 - x3) + s1_x * (y1 - y3)) / (-s2_x * s1_y + s1_x * s2_y);\n    const t = (s2_x * (y1 - y3) - s2_y * (x1 - x3)) / (-s2_x * s1_y + s1_x * s2_y);\n\n    if (s >= 0 && s <= 1 && t >= 0 && t <= 1) {\n      const atX = x1 + t * s1_x;\n      const atY = y1 + t * s1_y;\n      let intPt = { x: atX, y: atY };\n      if (ignoreTouching) {\n        if (GeomUtil.pointsEqual(intPt, segB.a) || GeomUtil.pointsEqual(intPt, segB.b)) {\n          return;\n        }\n        if (GeomUtil.pointsEqual(intPt, segA.a) || GeomUtil.pointsEqual(intPt, segA.b)) {\n          return;\n        }\n      }\n      return intPt;\n    }\n\n    return null;\n  }\n\n  /**\n   *\n   * @param {Segment} segA\n   * @param {Segment[]} segs\n   * @returns {Point[]}\n   */\n  static segmentSegmentsIntersections(segA, segs, ignoreTouching = false) {\n    let pts = [];\n    segs.forEach((seg) => {\n      if (seg == segA) {\n        return;\n      }\n      let intPt = GeomUtil.segmentSegmentIntersect(segA, seg, ignoreTouching);\n      if (intPt) {\n        pts.push(intPt);\n      }\n    });\n    return pts;\n  }\n\n  /**\n   *\n   * @param {Point} ptA\n   * @param {Point} ptB\n   */\n  static dot(ptA, ptB) {\n    return ptA.x * ptB.x + ptA.y * ptB.y;\n  }\n\n  /**\n   *\n   * @param {Point} ptA\n   * @param {Point} ptB\n   */\n  static cross(ptA, ptB) {\n    return ptA.x * ptB.y - ptA.y * ptB.x;\n  }\n\n  /**\n   * \n   * @param {Point} pt \n   * @param {Point} ptA \n   * @param {Point} ptB \n   */\n  static lineSide (pt, ptA, ptB) {\n    return Math.round(((ptB.x - ptA.x) * (pt.y - ptA.y) - (ptB.y - ptA.y) * (pt.x - ptA.x)) * 100) / 100;\n  }\n\n  /**\n   *\n   * @param {Point} ptA\n   * @param {Point} ptB\n   */\n  static sub(ptA, ptB) {\n    return new Point(ptA.x - ptB.x, ptA.y - ptB.y);\n  }\n\n  /**\n   *\n   * @param {Point} ptA\n   * @param {Point} ptB\n   */\n  static add(ptA, ptB) {\n    return new Point(ptA.x + ptB.x, ptA.y + ptB.y);\n  }\n\n  /**\n   *\n   * @param {Point} pt\n   * @param {Segment} seg\n   * @returns {Point}\n   */\n  static closestPtPointSegment(pt, seg) {\n    var ab = GeomUtil.sub(seg.b, seg.a);\n    var ca = GeomUtil.sub(pt, seg.a);\n    var t = GeomUtil.dot(ca, ab);\n\n    if (t < 0) {\n      pt = seg.a;\n    } else {\n      var denom = GeomUtil.dot(ab, ab);\n      if (t >= denom) {\n        pt = seg.b;\n      } else {\n        t /= denom;\n        // reuse ca\n        ca.x = seg.a.x + t * ab.x;\n        ca.y = seg.a.y + t * ab.y;\n        pt = ca;\n      }\n    }\n\n    return Point.clone(pt);\n  }\n\n  /**\n   *\n   * @param {Point} pt\n   * @param {Segment} seg\n   */\n  static distancePointSegment(pt, seg) {\n    return GeomUtil.distanceBetween(pt, GeomUtil.closestPtPointSegment(pt, seg));\n  }\n\n  /**\n   *\n   * @param {*} pt\n   * @param {*} boundingBox\n   * @returns {boolean}\n   */\n  static pointWithinBoundingBox(pt, boundingBox) {\n    return pt.x >= boundingBox.minX && pt.y >= boundingBox.minY && pt.x <= boundingBox.maxX && pt.y <= boundingBox.maxY;\n  }\n\n  /**\n   *\n   * @param {Point} pt\n   * @param {Segment[]} polySegs\n   * @returns {boolean}\n   */\n  static pointWithinPolygon(pt, polySegs, ignoreTouching) {\n    const b = GeomUtil.segmentsBoundingBox(polySegs);\n    // early out\n    if (!this.pointWithinBoundingBox(pt, b)) {\n      return false;\n    }\n\n    let startPt = new Point(100000, 100000);\n    let seg = new Segment(startPt, pt);\n\n    let pts = GeomUtil.segmentSegmentsIntersections(seg, polySegs);\n\n    if (!(pts.length % 2 == 0)) {\n      if (ignoreTouching && GeomUtil.pointsEqual(pt, pts[0])) {\n        return false;\n      }\n    }\n    return !(pts.length % 2 == 0);\n  }\n\n  /**\n   *\n   * @param {Segment} seg\n   * @param {Segment[]} polySegs\n   * @returns {boolean}\n   */\n  static segmentWithinPolygon(seg, polySegs) {\n    let aTouching = this.pointWithinPolygon(seg.a, polySegs, false);\n    let bTouching = this.pointWithinPolygon(seg.b, polySegs, false);\n    let aWithin = this.pointWithinPolygon(seg.a, polySegs, true);\n    let bWithin = this.pointWithinPolygon(seg.b, polySegs, true);\n    return (aWithin && bWithin) || (aWithin && bTouching) || (bWithin && aTouching);\n  }\n\n  static sign(p1, p2, p3) {\n    return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);\n  }\n\n  /**\n   *\n   * @param {Point} pt\n   * @param {Point} v1\n   * @param {Point} v2\n   * @param {Point} v3\n   * @returns {boolean}\n   */\n  static pointWithinTriangle(pt, v1, v2, v3, ignoreTouching) {\n    const d1 = GeomUtil.sign(pt, v1, v2);\n    const d2 = GeomUtil.sign(pt, v2, v3);\n    const d3 = GeomUtil.sign(pt, v3, v1);\n\n    const has_neg = d1 < 0 || d2 < 0 || d3 < 0;\n    const has_pos = d1 > 0 || d2 > 0 || d3 > 0;\n\n    if (!(has_neg && has_pos) && ignoreTouching) {\n      let seg = { a: v1, b: v2, tags: null };\n      if (GeomUtil.distancePointSegment(pt, seg) < 1) return false;\n      seg.a = v2;\n      seg.b = v3;\n      if (GeomUtil.distancePointSegment(pt, seg) < 1) return false;\n      seg.a = v3;\n      seg.b = v1;\n      if (GeomUtil.distancePointSegment(pt, seg) < 1) return false;\n    }\n\n    return !(has_neg && has_pos);\n  }\n\n  /**\n   *\n   * @param {Segment} seg\n   * @param {Point} v1\n   * @param {Point} v2\n   * @param {Point} v3\n   * @returns {boolean}\n   */\n  static segmentWithinTriangle(seg, v1, v2, v3) {\n    let aTouching = this.pointWithinTriangle(seg.a, v1, v2, v3, false);\n    let bTouching = this.pointWithinTriangle(seg.b, v1, v2, v3, false);\n    let aWithin = this.pointWithinTriangle(seg.a, v1, v2, v3, true);\n    let bWithin = this.pointWithinTriangle(seg.b, v1, v2, v3, true);\n    let pt = GeomUtil.averagePoints(seg.a, seg.b);\n    return (aWithin && bWithin) || (aWithin && bTouching) || (bWithin && aTouching) || (aTouching && bTouching);\n  }\n\n  /**\n   *\n   * @param {Point[]} pts\n   * @returns {Segment[]}\n   */\n  static pointsToClosedPolySegments(...pts) {\n    let out = [];\n    for (let i = 0; i < pts.length; i++) {\n      out.push(new Segment(pts[i], i < pts.length - 1 ? pts[i + 1] : pts[0]));\n    }\n    return out;\n  }\n\n  /**\n   *\n   * @param {Segment[]} polySegsA\n   * @param {Segment[]} polySegsB\n   * @returns {boolean}\n   */\n  static polygonWithinPolygon(polySegsA, polySegsB) {\n    const ab = GeomUtil.segmentsBoundingBox(polySegsA);\n    const bb = GeomUtil.segmentsBoundingBox(polySegsB);\n\n    // early out\n    if (!GeomUtil.boundingBoxesIntersect(ab, bb)) {\n      return false;\n    }\n\n    const startPt = new Point(bb.minX - 100, bb.minY - 100);\n\n    for (let i = 0; i < polySegsA.length; i++) {\n      let seg = polySegsA[i];\n      let pts = GeomUtil.segmentSegmentsIntersections(seg, polySegsB);\n\n      if (pts.length % 2 == 0) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   *\n   * @param {Point} ptA\n   * @param {Point} ptB\n   * @param {Point} ptC\n   * @param {number} iterations\n   */\n  static splinePoints(ptA, ptB, ptC, iterations = 0) {\n    let divide = (pts) => {\n      let out = [pts[0]];\n      for (let i = 0; i < pts.length - 1; i++) {\n        let pt = new Point(0, 0);\n        if (i + 1 < pts.length * 0.4) {\n          pt.x = (pts[i].x * 40 + pts[i + 1].x * 60) * 0.01;\n          pt.y = (pts[i].y * 40 + pts[i + 1].y * 60) * 0.01;\n        } else if (i + 1 > pts.length * 0.6) {\n          pt.x = (pts[i].x * 60 + pts[i + 1].x * 40) * 0.01;\n          pt.y = (pts[i].y * 60 + pts[i + 1].y * 40) * 0.01;\n        } else {\n          pt.x = (pts[i].x + pts[i + 1].x) * 0.5;\n          pt.y = (pts[i].y + pts[i + 1].y) * 0.5;\n        }\n        out.push(pt);\n      }\n      out.push(pts[pts.length - 1]);\n      return out;\n    };\n\n    let spts = [ptA, ptB, ptC];\n\n    for (let i = 0; i < iterations; i++) {\n      spts = divide(spts);\n    }\n\n    return spts;\n  }\n}","import { Segment, Point, GeomUtil } from \"./geom/geom.js\";\nimport { PolygonShape } from \"./geom/shapes.js\";\n\nexport class Analyzer {\n\n  /**\n   * @property {Segment[]} segs\n   * @property {boolean} splitTeeIntersections\n   * @returns {{ originalPts: Object.<string, Point>, pts: string[], cxs: Object.<string,string[]> }}\n   */\n  static getSegsAndConnections(segs, splitTeeIntersections = false, splitCrossIntersections = false) {\n\n    /** @type {Object.<string,string[]>} */\n    let cxs = {};\n    /** @type {string[]} */\n    let pts = [];\n    /** @type {Object.<string, Point>} */\n    let originalPts = {};\n\n    let token = pt => {\n      let t = `${Math.round(pt.x * 1)}|${Math.round(pt.y * 1)}`;\n      originalPts[t] = pt;\n      return t;\n    }\n\n    if (splitTeeIntersections) {\n\n      // step 0, split segments that cross a point (T intersections);\n\n      let allPts = segs.reduce((arr, seg) => arr.concat(seg.a, seg.b), []);\n      let j = allPts.length;\n\n      while (j--) {\n        let ptA = allPts[j];\n        let i = j;\n        while (i--) {\n          let ptB = allPts[i];\n          if (GeomUtil.pointsEqual(ptA, ptB)) {\n            allPts.splice(j, 1);\n            break;\n          }\n        }\n      }\n\n      let i = segs.length;\n\n      while (i--) {\n\n        let seg = segs[i];\n\n        let crossPts = [];\n\n        allPts.forEach(pt => {\n          if (GeomUtil.distancePointSegment(pt, seg) < 0.1) {\n            if (!GeomUtil.pointsEqual(pt, seg.a) && !GeomUtil.pointsEqual(pt, seg.b)) {\n              crossPts.push(pt);\n            }\n          }\n        });\n\n        if (crossPts.length) {\n\n          crossPts.sort((ptA, ptB) => {\n            const da = GeomUtil.distanceBetweenSquared(ptA, seg.a);\n            const db = GeomUtil.distanceBetweenSquared(ptB, seg.a);\n            if (da < db) {\n              return -1;\n            } else if (da > db) {\n              return 1;\n            }\n            return 0;\n          });\n\n          const newSegs = [];\n\n          let ptA = seg.a;\n          for (let k = 0; k < crossPts.length; k++) {\n            let ptB = crossPts[k];\n            newSegs.push(new Segment(ptA, ptB));\n            ptA = ptB;\n          }\n          newSegs.push(new Segment(ptA, seg.b));\n\n          segs.splice(i, 1, ...newSegs);\n\n        }\n\n      }\n\n    }\n\n    if (splitCrossIntersections) {\n\n      let j = segs.length;\n      while (j--) {\n        let i = j;\n        let found = false\n        while (i--) {\n          let segA = segs[j];\n          let segB = segs[i];\n          let intPt = GeomUtil.segmentSegmentIntersect(segA, segB, true);\n          if (intPt) {\n            found = true;\n            segs.splice(j, 1, new Segment(Point.clone(segA.a), Point.clone(intPt)), new Segment(Point.clone(intPt), Point.clone(segA.b)));\n            segs.splice(i, 1, new Segment(Point.clone(segB.a), Point.clone(intPt)), new Segment(Point.clone(intPt), Point.clone(segB.b)));\n          }\n        }\n        if (found) {\n          j = segs.length;\n        }\n      }\n\n    }\n\n    // step 1, collect endpoints\n    // step 2, filter out dupes\n    // step 3, collect connected endpoints for each endpoint\n\n    segs.forEach(seg => {\n      let ta = token(seg.a);\n      let tb = token(seg.b);\n      if (!cxs[ta]) cxs[ta] = [];\n      if (!cxs[tb]) cxs[tb] = [];\n      if (cxs[ta].indexOf(tb) === -1) {\n        cxs[ta].push(tb);\n      }\n      if (cxs[tb].indexOf(ta) === -1) {\n        cxs[tb].push(ta);\n      }\n      if (pts.indexOf(ta) === -1) {\n        pts.push(ta);\n      }\n      if (pts.indexOf(tb) === -1) {\n        pts.push(tb);\n      }\n    });\n\n    return {\n      originalPts,\n      pts,\n      cxs\n    };\n\n  }\n\n  /**\n   * @property {Segment[]} segs\n   * @property {boolean} splitTeeIntersections\n   * @returns {Segment[]}\n   */\n  static pathOrder(segs, splitTeeIntersections = false, splitCrossIntersections = false) {\n\n    let res = [];\n    let { originalPts, pts, cxs } = Analyzer.getSegsAndConnections(segs, splitTeeIntersections, splitCrossIntersections);\n\n    let nekot = str => {\n      return originalPts[str];\n    };\n\n    let byNumConnections = (ta, tb) => {\n      if (cxs[ta].length > cxs[tb].length) {\n        return 1;\n      } else if (cxs[ta].length < cxs[tb].length) {\n        return -1;\n      }\n      return 0;\n    }\n\n    // step 1, sort by number of connections, desc\n    // step 2, choose first endpoint\n    // step 3, pick the connected one with the lowest index that isn't in the stack, remove from connections list, push onto stack\n    // step 4, resort by number of connections, desc\n    // step 5, repeat step 6 until no more connections\n\n    pts.sort(byNumConnections);\n\n    while (pts.length) {\n\n      pts.sort(byNumConnections);\n      let ptA = pts.shift();\n\n      while (ptA) {\n\n        if (cxs[ptA].length) {\n\n          cxs[ptA].sort(byNumConnections);\n          let ptB = cxs[ptA].shift();\n\n          let oppIdx = cxs[ptB].indexOf(ptA);\n          if (oppIdx !== -1) cxs[ptB].splice(oppIdx, 1);\n\n          res.push(new Segment(nekot(ptA), nekot(ptB)));\n\n          if (cxs[ptA].length) {\n            pts.unshift(ptA);\n          }\n\n          ptA = ptB;\n\n        } else {\n\n          ptA = null;\n\n        }\n\n      }\n\n    }\n\n    return res;\n\n  }\n\n  /**\n   * @property {Segment[]} segs\n   * @property {number} offset\n   * @returns {Point[]}\n   */\n  static getEndingSegmentPoints(segs, offset = 0) {\n\n    segs = segs.concat();\n    segs = Analyzer.pathOrder(segs, true, true);\n\n    let { originalPts, pts, cxs } = Analyzer.getSegsAndConnections(segs, true);\n\n    let nekot = str => {\n      return originalPts[str];\n    };\n\n    // return all points with one connection\n\n    const endTokens = pts.filter(ta => cxs[ta].length === 1);\n\n    const out = [];\n    endTokens.forEach(tb => {\n      const ptB = Point.clone(nekot(tb));\n      if (offset === 0) {\n        out.push(ptB);\n        return;\n      }\n      const ptA = nekot(cxs[tb]);\n      const ang = GeomUtil.angleBetween(ptA, ptB);\n      const pt = new Point(0, offset);\n      GeomUtil.rotatePoint(pt, Math.PI * 0.5 - ang);\n      GeomUtil.addToPoint(ptB, pt);\n      out.push(ptB);\n    });\n\n    return out;\n\n  }\n\n  /**\n   * @property {Segment[]} segs\n   * @property {number} searchMultiplier multiple of typical segmentation distance to search for flood-fill points\n   * @returns {Point[][]}\n   */\n  static getFills(segs, searchMultiplier = 5) {\n\n    segs = segs.concat();\n\n    let { originalPts, pts, cxs } = Analyzer.getSegsAndConnections(segs, true, true);\n\n    let token = pt => {\n      let t = `${Math.round(pt.x * 1)}|${Math.round(pt.y * 1)}`;\n      originalPts[t] = pt;\n      return t;\n    }\n\n    let cenTokens = [];\n    let pointGroups = [];\n\n    // 1. iterate through all points\n    // 2. for each point pick a each connection\n    // 3. for each pair, proceed to find a winding polygon\n\n    let minX = 100000;\n    let minY = 100000;\n    let maxX = -100000;\n    let maxY = -100000;\n    let minDx = 100000;\n    let minDy = 100000;\n\n    let ptArray = [];\n\n    // get extents\n\n    for (let token in originalPts) {\n      let pt = originalPts[token];\n      ptArray.push(pt);\n      minX = Math.min(minX, pt.x);\n      minY = Math.min(minY, pt.y);\n      maxX = Math.max(maxX, pt.x);\n      maxY = Math.max(maxY, pt.y);\n    }\n\n    // get minimum spacing\n\n    ptArray.sort((a, b) => {\n      if (a.x < b.x) {\n        return -1;\n      } else if (a.x > b.x) {\n        return 1;\n      }\n      return 0;\n    });\n\n    ptArray.forEach((ptA, idx) => {\n      if (idx > 0) {\n        let ptB = ptArray[idx - 1];\n        let dx = Math.round(Math.abs(ptA.x - ptB.x));\n        if (dx > 1) {\n          minDx = Math.min(minDx, dx);\n        }\n      }\n    });\n\n    ptArray.sort((a, b) => {\n      if (a.y < b.y) {\n        return -1;\n      } else if (a.y > b.y) {\n        return 1;\n      }\n      return 0;\n    });\n\n    ptArray.forEach((ptA, idx) => {\n      if (idx > 0) {\n        let ptB = ptArray[idx - 1];\n        let dy = Math.round(Math.abs(ptA.y - ptB.y));\n        if (dy > 1) {\n          minDy = Math.min(minDy, dy);\n        }\n      }\n    });\n\n    let hDx = minDx * 0.5;\n    let hDy = minDy * 0.5;\n\n    let rayPts = [];\n\n    for (let j = minY; j < maxY; j += minDy) {\n      for (let i = minX; i < maxX; i += minDx) {\n        rayPts.push(new Point(i + hDx, j + hDy));\n      }\n    }\n\n    rayPts.forEach(rayPt => {\n      let nearPts = [];\n      ptArray.forEach(pt => {\n        let dist = GeomUtil.distanceBetween(pt, rayPt);\n        if (dist < Math.max(minDx, minDy) * searchMultiplier) {\n          let ang = GeomUtil.angleBetween(pt, rayPt);\n          nearPts.push({\n            pt,\n            dist,\n            ang\n          });\n        }\n      });\n      if (nearPts.length < 4) {\n        return;\n      }\n      let i = nearPts.length;\n      while (i--) {\n        let nPt = nearPts[i].pt;\n        let seg = new Segment(rayPt, nPt);\n        let hits = GeomUtil.segmentSegmentsIntersections(seg, segs, true);\n        if (hits.length > 0) {\n          nearPts.splice(i, 1);\n        }\n      }\n      nearPts.sort((a, b) => {\n        if (a.ang < b.ang) {\n          return -1;\n        } else if (a.ang > b.ang) {\n          return 1;\n        }\n        return 0;\n      });\n      i = nearPts.length;\n      while (i--) {\n        let nPtA = nearPts[i].pt;\n        let tokenA = token(nPtA);\n        let j = nearPts.length;\n        let ok = false;\n        while (j--) {\n          if (i === j) {\n            continue;\n          }\n          let nPtB = nearPts[j].pt;\n          let tokenB = token(nPtB);\n          if (cxs[tokenA].indexOf(tokenB) === -1) {\n            ok = true;\n            break;\n          }\n        }\n        if (!ok) {\n          nearPts.splice(i, 1);\n        }\n      }\n      let ok = true;\n      nearPts.forEach((npA, idx) => {\n        let npB = nearPts[(idx + 1) % nearPts.length];\n        let tokenA = token(npA.pt);\n        let tokenB = token(npB.pt);\n        if (cxs[tokenA].indexOf(tokenB) === -1) {\n          ok = false;\n        }\n      });\n      if (ok) {\n        let polyPts = nearPts.map(nPt => nPt.pt);\n        let cen = GeomUtil.averagePoints(...polyPts);\n        let cenToken = token(cen);\n        if (cenTokens.indexOf(cenToken) === -1) {\n          cenTokens.push(cenToken);\n          pointGroups.push(polyPts);\n        }\n      }\n    });\n\n    return pointGroups;\n\n  }\n\n}\n\n","import { Segment, Segments, SegmentCollection, Point, GeomUtil } from \"./geom/geom.js\";\nimport { Analyzer } from \"./analyzer.js\";\n\nexport class Optimize {\n  /**\n   *\n   * @param {SegmentCollection[]} segCols\n   * @param {boolean} [noSplit]\n   * @param {boolean} [trimSmall]\n   * @param {number} [smallDist]\n   * @param {boolean} [optimizePathOrder]\n   * @param {boolean} [splitTeeIntersections]\n   * @returns {Segments}\n   */\n  static segmentCollections(segCols, noSplit = false, trimSmall = true, smallDist = 1, optimizePathOrder = false, splitTeeIntersections = false, splitCrossIntersections = false) {\n    let allsegs = segCols.reduce((arr, sc) => arr.concat(sc.toSegments()), []);\n    return Optimize.segments(allsegs, noSplit, trimSmall, smallDist, optimizePathOrder, splitTeeIntersections, splitCrossIntersections);\n  }\n  /**\n   *\n   * @param {SegmentCollection[]} segCols\n   * @param {boolean} [splitTeeIntersections]\n   * @returns {Segments}\n   */\n  static segmentCollectionsPathOrder(segCols, splitTeeIntersections = false, splitCrossIntersections = false) {\n    let allsegs = segCols.reduce((arr, sc) => arr.concat(sc.toSegments()), []);\n    return new Segments(Analyzer.pathOrder(allsegs, splitTeeIntersections, splitCrossIntersections));\n  }\n  /**\n   *\n   * @param {Segment[]} segs\n   * @param {boolean} [noSplitColinear]\n   * @param {boolean} [trimSmall]\n   * @param {number} [smallDist]\n   * @param {boolean} [optimizePathOrder]\n   * @param {boolean} [splitTeeIntersections]\n   * @returns {Segments}\n   */\n  static segments(segs, noSplitColinear = false, trimSmall = true, smallDist = 1, optimizePathOrder = false, splitTeeIntersections = false, splitCrossIntersections = false) {\n\n    segs = Optimize._segments(segs, noSplitColinear, trimSmall, smallDist);\n\n    if (optimizePathOrder) {\n      segs = Analyzer.pathOrder(segs, splitTeeIntersections, splitCrossIntersections);\n    }\n\n    return new Segments(segs);\n  }\n\n  /**\n   * JS fallback for segment optimization  \n   * @private\n   */\n  static _segments(segs, noSplitColinear, trimSmall, smallDist) {\n    const sb = segs;\n    segs = [];\n\n    // Dedupe\n    while (sb.length) {\n      let s = sb.shift();\n      let n = segs.length\n      let found = false;\n      while (n--) {\n        const sn = segs[n];\n        if (Segment.isEqual(s, sn)) {\n          found = true;\n          break;\n        }\n      }\n      if (!found) {\n        segs.push(s);\n      }\n    }\n\n    // Merge colinear\n    if (!noSplitColinear) {\n\n      for (let n = 0; n < 3; n++) {\n        let i = segs.length;\n        let overlaps = 0;\n\n        while (i--) {\n          let segA = segs[i];\n          let aa, ab, ba, bb, heading;\n          for (let j = i - 1; j >= 0; j--) {\n            let segB = segs[j];\n            let same = false;\n            let isRev = false;\n            if (GeomUtil.sameAngle(segA, segB)) {\n              same = true;\n              aa = Point.clone(segA.a);\n              ab = Point.clone(segA.b);\n              ba = Point.clone(segB.a);\n              bb = Point.clone(segB.b);\n            } else if (GeomUtil.sameAngleRev(segA, segB)) {\n              same = isRev = true;\n              aa = Point.clone(segA.b);\n              ab = Point.clone(segA.a);\n              ba = Point.clone(segB.a);\n              bb = Point.clone(segB.b);\n            }\n            if (same) {\n              heading = GeomUtil.angleBetween(aa, ab);\n              GeomUtil.rotatePoints(heading, aa, ab, ba, bb);\n              if (Math.abs(aa.y - ba.y) < 0.1 && ab.x >= ba.x - 0.0001 && aa.x <= bb.x + 0.0001) {\n                overlaps++;\n                if (aa.x < ba.x) {\n                  if (!isRev) {\n                    segB.a = segA.a;\n                  } else {\n                    segB.a = segA.b;\n                  }\n                }\n                if (ab.x > bb.x) {\n                  if (!isRev) {\n                    segB.b = segA.b;\n                  } else {\n                    segB.b = segA.a;\n                  }\n                }\n                segs.splice(i, 1);\n                break;\n              }\n            }\n          }\n        }\n      }\n\n    }\n\n    // Trim small\n    let i = segs.length;\n    while (i--) {\n      let seg = segs[i];\n      if (!seg) {\n        segs.splice(i, 1);\n        continue;\n      }\n      if (trimSmall && GeomUtil.distanceBetween(seg.a, seg.b) < smallDist) {\n        segs.splice(i, 1);\n        continue;\n      }\n    }\n\n    console.log(`[JS] Optimize: ${sb.length + segs.length} -> ${segs.length} segments`);\n    return segs;\n  }\n\n}\n","// @ts-check\n/**\n * Edge-Based Hidden Line Renderer\n * \n * A faster alternative to clipper-based boolean operations.\n * Uses per-edge occlusion testing.\n */\n\nimport { Optimize } from './optimize.js';\n\nimport {\n    Vector3,\n    Vector2,\n    Raycaster,\n    Camera,\n    Scene,\n    Mesh,\n    WebGLRenderTarget,\n    NearestFilter,\n    RGBAFormat,\n    UnsignedByteType,\n    MeshDepthMaterial,\n    RGBADepthPacking,\n    ShaderMaterial,\n    BufferAttribute,\n    BufferGeometry,\n    DoubleSide\n} from \"three\";\n\n/**\n * @typedef {Object} Edge3D\n * @property {Vector3} a - Start point (world space)\n * @property {Vector3} b - End point (world space)\n * @property {Vector3} normal1 - First face normal\n * @property {Vector3} [normal2] - Second face normal (if shared edge)\n * @property {number} faceIdx1 - First face index\n * @property {number} [faceIdx2] - Second face index\n * @property {Mesh} mesh - Parent mesh\n * @property {boolean} [isHatch] - Is this a hatch line?\n */\n\n/**\n * @typedef {Object} Edge2D\n * @property {Vector2} a - Start point (screen space)\n * @property {Vector2} b - End point (screen space)\n * @property {Vector3} a3d - Start point (world space)\n * @property {Vector3} b3d - End point (world space)\n * @property {Vector3} midpoint3d - Midpoint in world space\n * @property {boolean} isProfile - Is this a silhouette edge?\n * @property {boolean} visible - Is this edge visible?\n * @property {number} faceIdx - Parent face index\n * @property {number} [faceIdx2] - Second face index (if shared edge)\n * @property {Mesh} mesh - Parent mesh\n * @property {boolean} [isHatch] - Is this a hatch line?\n * @property {boolean} [isSilhouette] - Is this a silhouette edge (borders void)?\n * @property {Vector3} [normal1] - First face normal (propagated)\n * @property {Vector3} [normal2] - Second face normal (propagated)\n * @property {number} [adjacentFaceCount] - Number of adjacent faces (debug/filtering)\n * @property {number} [faceSimilarity] - Similarity of adjacent face normals (debug/filtering)\n * @property {boolean} [isTJunctionStraggler] - Is this edge a result of a T-junction split?\n */\n\n/**\n * @typedef {Object} Point2D\n * @property {number} x\n * @property {number} y\n */\n\n/**\n * @typedef {Object} ProjectedFace\n * @property {Vector2} a2d - Screen space vertex A\n * @property {Vector2} b2d - Screen space vertex B\n * @property {Vector2} c2d - Screen space vertex C\n * @property {number} depthA - Depth at vertex A\n * @property {number} depthB - Depth at vertex B\n * @property {number} depthC - Depth at vertex C\n * @property {Mesh} mesh - Source mesh\n * @property {number} faceIdx - Original face index\n * @property {Vector3} normal - Face normal (world space)\n * @property {number} constant - Plane constant d\n */\n\n/**\n * Extract edges from a mesh with face normal information\n * Only extracts edges from front-facing faces (skips back-facing)\n * @param {Mesh} mesh \n * @param {Vector3} cameraPosition - Camera position for face culling\n * @returns {Edge3D[]}\n */\nexport function extractEdges(mesh, cameraPosition) {\n    const geometry = mesh.geometry;\n    const position = geometry.attributes.position;\n    const index = geometry.index;\n\n    if (!position) return [];\n\n    /** @type {Map<string, Edge3D>} */\n    const edgeMap = new Map();\n\n    // Snap tolerance for position-based edge matching\n    const SNAP = 1000; // Precision: 3 decimal places\n\n    // Position-based edge key (not index-based, handles duplicate vertices)\n    /**\n     * \n     * @param {Vector3} va \n     * @param {Vector3} vb \n     * @returns \n     */\n    const getEdgeKey = (va, vb) => {\n        const ax = Math.round(va.x * SNAP);\n        const ay = Math.round(va.y * SNAP);\n        const az = Math.round(va.z * SNAP);\n        const bx = Math.round(vb.x * SNAP);\n        const by = Math.round(vb.y * SNAP);\n        const bz = Math.round(vb.z * SNAP);\n\n        const keyA = `${ax},${ay},${az}`;\n        const keyB = `${bx},${by},${bz}`;\n\n        // Consistent ordering for undirected edges\n        return keyA < keyB ? `${keyA}|${keyB}` : `${keyB}|${keyA}`;\n    };\n\n    /**\n     * \n     * @param {number} idx \n     * @returns \n     */\n    const getVertex = (idx) => {\n        const v = new Vector3(\n            position.getX(idx),\n            position.getY(idx),\n            position.getZ(idx)\n        );\n        return v.applyMatrix4(mesh.matrixWorld);\n    };\n\n    /**\n     * \n     * @param {Vector3} v0 \n     * @param {Vector3} v1 \n     * @param {Vector3} v2 \n     * @returns \n     */\n    const getFaceNormal = (v0, v1, v2) => {\n        const edge1 = new Vector3().subVectors(v1, v0);\n        const edge2 = new Vector3().subVectors(v2, v0);\n        return new Vector3().crossVectors(edge1, edge2).normalize();\n    };\n\n    const numFaces = index ? index.count / 3 : position.count / 3;\n\n    for (let f = 0; f < numFaces; f++) {\n        let i0, i1, i2;\n\n        if (index) {\n            i0 = index.getX(f * 3);\n            i1 = index.getX(f * 3 + 1);\n            i2 = index.getX(f * 3 + 2);\n        } else {\n            i0 = f * 3;\n            i1 = f * 3 + 1;\n            i2 = f * 3 + 2;\n        }\n\n        const v0 = getVertex(i0);\n        const v1 = getVertex(i1);\n        const v2 = getVertex(i2);\n        const normal = getFaceNormal(v0, v1, v2);\n\n        // Skip back-facing faces - only extract edges from front-facing faces\n        const faceMid = new Vector3().addVectors(v0, v1).add(v2).divideScalar(3);\n        const viewDir = new Vector3().subVectors(cameraPosition, faceMid);\n        if (normal.dot(viewDir) <= 0) {\n            continue; // Skip back-facing face\n        }\n\n        // Process three edges of the triangle\n        const edges = [\n            [v0, v1],\n            [v1, v2],\n            [v2, v0]\n        ];\n\n        for (const [va, vb] of edges) {\n            const key = getEdgeKey(va, vb);\n\n            if (edgeMap.has(key)) {\n                // Edge already exists - add second face normal\n                const existing = edgeMap.get(key);\n                if (existing && !existing.normal2) {\n                    existing.normal2 = normal.clone();\n                    existing.faceIdx2 = f;\n                }\n            } else {\n                edgeMap.set(key, {\n                    a: va.clone(),\n                    b: vb.clone(),\n                    normal1: normal.clone(),\n                    faceIdx1: f,\n                    mesh\n                });\n            }\n        }\n    }\n\n    return Array.from(edgeMap.values());\n}\n\n/**\n * Filter edges: remove those where both faces are back-facing\n * @param {Edge3D[]} edges \n * @param {Vector3} cameraPosition \n * @returns {Edge3D[]}\n */\nexport function filterBackfacing(edges, cameraPosition) {\n    return edges.filter(edge => {\n        const edgeMidpoint = new Vector3().addVectors(edge.a, edge.b).multiplyScalar(0.5);\n        const viewDir = new Vector3().subVectors(cameraPosition, edgeMidpoint).normalize();\n\n        const facing1 = edge.normal1.dot(viewDir) > 0;\n\n        // Boundary edges (only one face) are always kept - they're silhouettes\n        if (!edge.normal2) {\n            return true;\n        }\n\n        const facing2 = edge.normal2.dot(viewDir) > 0;\n\n        // Keep edge if at least one face is front-facing\n        return facing1 || facing2;\n    });\n}\n\n/**\n * Detect profile (silhouette) edges and mark smooth edges for removal\n * @param {Edge3D[]} edges \n * @param {Vector3} cameraPosition \n * @param {number} smoothThreshold - Dot product threshold for similar normals (default 0.99)\n * @returns {{profiles: Edge3D[], smoothFiltered: Edge3D[]}}\n */\nexport function classifyEdges(edges, cameraPosition, smoothThreshold = 0.99) {\n    const profiles = [];\n    const smoothFiltered = [];\n\n    // Debug counters\n    let boundaryCount = 0;\n    let profileCount = 0;\n    let smoothCount = 0;\n    let discardedCount = 0;\n\n    for (const edge of edges) {\n        const edgeMidpoint = new Vector3().addVectors(edge.a, edge.b).multiplyScalar(0.5);\n        const viewDir = new Vector3().subVectors(cameraPosition, edgeMidpoint).normalize();\n\n        const facing1 = edge.normal1.dot(viewDir) > 0;\n        const facing2 = edge.normal2 ? edge.normal2.dot(viewDir) > 0 : true; // Boundary edges count as profile\n\n        // Profile edge: one face front, one face back (or boundary)\n        if (facing1 !== facing2 || !edge.normal2) {\n            profiles.push(edge);\n            continue;\n        }\n\n        // Check if normals are similar (smooth shading edge)\n        if (edge.normal2) {\n            const similarity = edge.normal1.dot(edge.normal2);\n            // Keep edge only if normals are different enough (crease/hard edge)\n            // Filter out smooth edges where normals are nearly parallel\n            if (similarity < smoothThreshold) {\n                smoothFiltered.push(edge);\n            }\n            // Edges with similar normals (similarity >= threshold) are discarded as smooth surface edges\n        }\n    }\n\n    console.log(`classifyEdges: ${profiles.length} profiles, ${smoothFiltered.length} smooth/crease edges`);\n\n    return { profiles, smoothFiltered };\n}\n\n/**\n * Project 3D edges to screen space\n * @param {Edge3D[]} edges \n * @param {Camera} camera \n * @param {number} width \n * @param {number} height \n * @param {number} scale - Internal scale factor for precision (default 1)\n * @returns {Edge2D[]}\n */\nexport function projectEdges(edges, camera, width, height, scale = 1) {\n    const halfWidth = width / 2;\n    const halfHeight = height / 2;\n\n    /**\n     * \n     * @param {Vector3} p3d \n     * @returns \n     */\n    const projectPoint = (p3d) => {\n        const projected = p3d.clone().project(camera);\n        return new Vector2(\n            projected.x * halfWidth * scale,\n            -projected.y * halfHeight * scale\n        );\n    };\n\n    return edges.map(edge => ({\n        a: projectPoint(edge.a),\n        b: projectPoint(edge.b),\n        a3d: edge.a.clone(),\n        b3d: edge.b.clone(),\n        midpoint3d: new Vector3().addVectors(edge.a, edge.b).multiplyScalar(0.5),\n        isProfile: false, // Will be set by classifyEdges\n        visible: true,\n        faceIdx: edge.faceIdx1,\n        faceIdx2: edge.faceIdx2,\n        mesh: edge.mesh,\n        isHatch: edge.isHatch,\n        normal1: edge.normal1,  // Propagate normals for straggler detection\n        normal2: edge.normal2\n    }));\n}\n\n/**\n * Spatial hash for efficient edge queries\n */\nexport class SpatialHash {\n    /**\n     * @param {number} cellSize \n     */\n    constructor(cellSize) {\n        this.cellSize = cellSize;\n        /** @type {Map<string, Edge2D[]>} */\n        this.cells = new Map();\n    }\n\n    /**\n     * Get cell key for a point\n     * @param {number} x \n     * @param {number} y \n     * @returns {string}\n     */\n    getCellKey(x, y) {\n        const cx = Math.floor(x / this.cellSize);\n        const cy = Math.floor(y / this.cellSize);\n        return `${cx},${cy}`;\n    }\n\n    /**\n     * Get all cells an edge crosses\n     * @param {Edge2D} edge \n     * @returns {string[]}\n     */\n    getCellsCrossed(edge) {\n        const cells = new Set();\n\n        // Use line rasterization to find all cells\n        const dx = Math.abs(edge.b.x - edge.a.x);\n        const dy = Math.abs(edge.b.y - edge.a.y);\n        const steps = Math.max(dx, dy) / this.cellSize + 1;\n\n        for (let i = 0; i <= steps; i++) {\n            const t = i / steps;\n            const x = edge.a.x + t * (edge.b.x - edge.a.x);\n            const y = edge.a.y + t * (edge.b.y - edge.a.y);\n            cells.add(this.getCellKey(x, y));\n        }\n\n        return Array.from(cells);\n    }\n\n    /**\n     * Insert an edge into the spatial hash\n     * @param {Edge2D} edge \n     */\n    insert(edge) {\n        const cells = this.getCellsCrossed(edge);\n        for (const key of cells) {\n            if (!this.cells.has(key)) {\n                this.cells.set(key, []);\n            }\n            this.cells.get(key)?.push(edge);\n        }\n    }\n\n    /**\n     * Get all edges in a cell\n     * @param {string} key \n     * @returns {Edge2D[]}\n     */\n    query(key) {\n        return this.cells.get(key) || [];\n    }\n\n    /**\n     * Get all cell keys\n     * @returns {string[]}\n     */\n    getAllCells() {\n        return Array.from(this.cells.keys());\n    }\n\n    clear() {\n        this.cells.clear();\n    }\n}\n\n/**\n * Find intersection point of two 2D line segments\n * @param {Edge2D} e1 \n * @param {Edge2D} e2 \n * @returns {{t1: number, t2: number, point: Vector2} | null}\n */\nexport function findIntersection(e1, e2) {\n    const x1 = e1.a.x, y1 = e1.a.y;\n    const x2 = e1.b.x, y2 = e1.b.y;\n    const x3 = e2.a.x, y3 = e2.a.y;\n    const x4 = e2.b.x, y4 = e2.b.y;\n\n    const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n    if (Math.abs(denom) < 1e-10) return null; // Parallel\n\n    const t1 = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;\n    const t2 = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;\n\n    const eps = 0.001;\n    // Check if intersection is within both segments (excluding endpoints)\n    if (t1 > eps && t1 < 1 - eps && t2 > eps && t2 < 1 - eps) {\n        return {\n            t1,\n            t2,\n            point: new Vector2(\n                x1 + t1 * (x2 - x1),\n                y1 + t1 * (y2 - y1)\n            )\n        };\n    }\n\n    return null;\n}\n\n/**\n * Split edges at intersection points within a cell\n * @param {Edge2D[]} edges \n * @returns {Edge2D[]}\n */\nexport function splitAtIntersections(edges) {\n    /** @type {Map<Edge2D, {t: number, point: Vector2}[]>} */\n    const splits = new Map();\n\n    const eps = 0.01;\n\n    // Helper: check if point p lies on edge interior (not endpoints)\n    // Returns t parameter (0,1) if on edge, null otherwise\n    /**\n     * \n     * @param {Vector2} p \n     * @param {Edge2D} edge \n     * @returns \n     */\n    const pointOnEdgeInterior = (p, edge) => {\n        const dx = edge.b.x - edge.a.x;\n        const dy = edge.b.y - edge.a.y;\n        const lenSq = dx * dx + dy * dy;\n        if (lenSq < 1e-10) return null; // Degenerate edge\n\n        // Project p onto edge line\n        const t = ((p.x - edge.a.x) * dx + (p.y - edge.a.y) * dy) / lenSq;\n\n        // Check if t is in interior (not at endpoints)\n        if (t <= eps || t >= 1 - eps) return null;\n\n        // Check distance from point to projected point on line\n        const projX = edge.a.x + t * dx;\n        const projY = edge.a.y + t * dy;\n        const distSq = (p.x - projX) * (p.x - projX) + (p.y - projY) * (p.y - projY);\n\n        // Tolerance for \"on the edge\"\n        if (distSq < 1.0) { // 1 pixel tolerance\n            return t;\n        }\n        return null;\n    };\n\n    // Track edges that might be stragglers (their endpoint caused a T-junction)\n    const potentialStragglers = new Set();\n\n    // Find all intersections (crossing + T-junctions)\n    for (let i = 0; i < edges.length; i++) {\n        for (let j = i + 1; j < edges.length; j++) {\n            // Check for crossing intersection\n            const intersection = findIntersection(edges[i], edges[j]);\n            if (intersection) {\n                // Record split points for both edges\n                if (!splits.has(edges[i])) splits.set(edges[i], []);\n                if (!splits.has(edges[j])) splits.set(edges[j], []);\n\n                splits.get(edges[i])?.push({ t: intersection.t1, point: intersection.point });\n                splits.get(edges[j])?.push({ t: intersection.t2, point: intersection.point });\n            } else {\n                // Check for T-junctions: endpoint of one edge on interior of other\n                // Mark BOTH edges as potential stragglers\n\n                // Edge i's endpoints on edge j\n                const tAonJ = pointOnEdgeInterior(edges[i].a, edges[j]);\n                if (tAonJ !== null) {\n                    if (!splits.has(edges[j])) splits.set(edges[j], []);\n                    splits.get(edges[j])?.push({ t: tAonJ, point: edges[i].a.clone() });\n                    potentialStragglers.add(edges[i]);\n                    potentialStragglers.add(edges[j]);  // Mark BOTH\n                }\n\n                const tBonJ = pointOnEdgeInterior(edges[i].b, edges[j]);\n                if (tBonJ !== null) {\n                    if (!splits.has(edges[j])) splits.set(edges[j], []);\n                    splits.get(edges[j])?.push({ t: tBonJ, point: edges[i].b.clone() });\n                    potentialStragglers.add(edges[i]);\n                    potentialStragglers.add(edges[j]);  // Mark BOTH\n                }\n\n                // Edge j's endpoints on edge i\n                const tAonI = pointOnEdgeInterior(edges[j].a, edges[i]);\n                if (tAonI !== null) {\n                    if (!splits.has(edges[i])) splits.set(edges[i], []);\n                    splits.get(edges[i])?.push({ t: tAonI, point: edges[j].a.clone() });\n                    potentialStragglers.add(edges[i]);  // Mark BOTH\n                    potentialStragglers.add(edges[j]);\n                }\n\n                const tBonI = pointOnEdgeInterior(edges[j].b, edges[i]);\n                if (tBonI !== null) {\n                    if (!splits.has(edges[i])) splits.set(edges[i], []);\n                    splits.get(edges[i])?.push({ t: tBonI, point: edges[j].b.clone() });\n                    potentialStragglers.add(edges[i]);  // Mark BOTH\n                    potentialStragglers.add(edges[j]);\n                }\n            }\n        }\n    }\n\n    console.log(`T-junction detection: ${potentialStragglers.size} potential straggler edges`);\n\n    // Split edges at recorded points\n    const result = [];\n\n    for (const edge of edges) {\n        const edgeSplits = splits.get(edge);\n        const isStraggler = potentialStragglers.has(edge);\n\n        if (!edgeSplits || edgeSplits.length === 0) {\n            // Mark the edge as potential straggler if it was identified\n            edge.isTJunctionStraggler = isStraggler;\n            result.push(edge);\n            continue;\n        }\n\n        // Sort splits by t value\n        edgeSplits.sort((a, b) => a.t - b.t);\n\n        // Create sub-edges\n        let prevT = 0;\n        let prevPoint = edge.a;\n        let prevPoint3d = edge.a3d;\n\n        for (const split of edgeSplits) {\n            const point3d = new Vector3().lerpVectors(edge.a3d, edge.b3d, split.t);\n\n            result.push({\n                a: prevPoint.clone(),\n                b: split.point.clone(),\n                a3d: prevPoint3d.clone(),\n                b3d: point3d.clone(),\n                midpoint3d: new Vector3().addVectors(prevPoint3d, point3d).multiplyScalar(0.5),\n                isProfile: edge.isProfile,\n                visible: edge.visible,\n                faceIdx: edge.faceIdx,\n                mesh: edge.mesh,\n                isHatch: edge.isHatch,\n                normal1: edge.normal1,  // Propagate normal for smooth filter\n                isTJunctionStraggler: isStraggler\n            });\n\n            prevT = split.t;\n            prevPoint = split.point;\n            prevPoint3d = point3d;\n        }\n\n        // Final segment\n        result.push({\n            a: prevPoint.clone(),\n            b: edge.b.clone(),\n            a3d: prevPoint3d.clone(),\n            b3d: edge.b3d.clone(),\n            midpoint3d: new Vector3().addVectors(prevPoint3d, edge.b3d).multiplyScalar(0.5),\n            isProfile: edge.isProfile,\n            visible: edge.visible,\n            faceIdx: edge.faceIdx,\n            mesh: edge.mesh,\n            isHatch: edge.isHatch,\n            normal1: edge.normal1,  // Propagate normal for smooth filter\n            isTJunctionStraggler: isStraggler\n        });\n    }\n\n    return result;\n}\n\n/**\n * Test edge visibility using GPU depth buffer (fast O(1) per edge)\n * Uses a render target with depth material to read depth as RGBA\n * @param {Edge2D[]} edges \n * @param {Scene} scene \n * @param {Camera} camera \n * @param {number} epsilon - Depth tolerance (normalized 0-1)\n * @param {number} width - Viewport width\n * @param {number} height - Viewport height\n * @param {any} renderer - THREE.WebGLRenderer instance\n * @returns {Edge2D[]}\n */\nexport function testOcclusionDepthBuffer(edges, scene, camera, epsilon, width, height, renderer) {\n    const visibleEdges = [];\n\n    if (!renderer) {\n        console.warn('No renderer provided, skipping occlusion test');\n        return edges;\n    }\n\n    // Create render target for depth\n    const renderTarget = new WebGLRenderTarget(width, height, {\n        minFilter: NearestFilter,\n        magFilter: NearestFilter,\n        format: RGBAFormat,\n        type: UnsignedByteType\n    });\n\n    // Create depth material that encodes depth as color\n    const depthMaterial = new MeshDepthMaterial({\n        depthPacking: RGBADepthPacking\n    });\n\n    // Store original material overrides\n    const originalOverrideMaterial = scene.overrideMaterial;\n\n    // Render scene with depth material\n    scene.overrideMaterial = depthMaterial;\n    renderer.setRenderTarget(renderTarget);\n    renderer.render(scene, camera);\n\n    // Read the render target as RGBA\n    const depthData = new Uint8Array(width * height * 4);\n    renderer.readRenderTargetPixels(renderTarget, 0, 0, width, height, depthData);\n\n    // Restore scene\n    scene.overrideMaterial = originalOverrideMaterial;\n    renderer.setRenderTarget(null);\n\n    // Check if we got valid data\n    let hasData = false;\n    for (let i = 0; i < Math.min(4000, depthData.length); i += 4) {\n        if (depthData[i] !== 0 || depthData[i + 1] !== 0 || depthData[i + 2] !== 0) {\n            hasData = true;\n            break;\n        }\n    }\n\n    // Debug: sample center of depth buffer\n    const centerIdx = Math.floor(height / 2) * width * 4 + Math.floor(width / 2) * 4;\n    console.log(`Depth buffer center pixel (RGBA): ${depthData[centerIdx]}, ${depthData[centerIdx + 1]}, ${depthData[centerIdx + 2]}, ${depthData[centerIdx + 3]}`);\n\n    if (!hasData) {\n        console.warn('Could not read depth buffer, falling back to all-visible');\n        renderTarget.dispose();\n        depthMaterial.dispose();\n        return edges;\n    }\n\n    // Decode depth from RGBA using three.js formula\n    // See: https://github.com/mrdoob/three.js/blob/master/src/renderers/shaders/ShaderChunk/packing.glsl.js\n    // UnpackDownscale = 255/256\n    // UnpackFactors4 = (UnpackDownscale/1, UnpackDownscale/256, UnpackDownscale/65536, 1/16777216)\n    const UnpackDownscale = 255.0 / 256.0;\n    const PackFactors = [1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0];\n    const UnpackFactors4 = [\n        UnpackDownscale / PackFactors[0],  // 0.99609375\n        UnpackDownscale / PackFactors[1],  // 0.00389099...\n        UnpackDownscale / PackFactors[2],  // 0.0000152...\n        1.0 / PackFactors[3]               // 0.0000000059...\n    ];\n\n    /**\n     * \n     * @param {number} r \n     * @param {number} g \n     * @param {number} b \n     * @param {number} a \n     * @returns \n     */\n    const unpackDepth = (r, g, b, a) => {\n        // Normalize from 0-255 to 0-1\n        const rn = r / 255.0;\n        const gn = g / 255.0;\n        const bn = b / 255.0;\n        const an = a / 255.0;\n        // dot product with UnpackFactors4\n        return rn * UnpackFactors4[0] + gn * UnpackFactors4[1] + bn * UnpackFactors4[2] + an * UnpackFactors4[3];\n    };\n\n    // @ts-ignore\n    const near = camera.near;\n    // @ts-ignore  \n    const far = camera.far;\n\n    // Debug: log first few depth comparisons\n    let debugCount = 0;\n\n    for (const edge of edges) {\n        // Get screen-space coordinates of edge midpoint\n        const midX = (edge.a.x + edge.b.x) / 2;\n        const midY = (edge.a.y + edge.b.y) / 2;\n\n        const sx = Math.round(midX + width / 2);\n        const sy = Math.round(height / 2 + midY); // projectEdges already negates Y\n\n        // Check bounds\n        if (sx < 0 || sx >= width || sy < 0 || sy >= height) {\n            edge.visible = true;\n            visibleEdges.push(edge);\n            continue;\n        }\n\n        // Sample depth buffer (note: readRenderTargetPixels returns bottom-up)\n        const depthIdx = ((height - 1 - sy) * width + sx) * 4;\n        const sampledDepth = unpackDepth(\n            depthData[depthIdx],\n            depthData[depthIdx + 1],\n            depthData[depthIdx + 2],\n            depthData[depthIdx + 3]\n        );\n\n        // Compute expected depth using view-space Z (linear depth)\n        // MeshDepthMaterial stores: (viewZ - near) / (far - near) where viewZ is distance along camera's look direction\n        // For perspective cameras, we need to transform the midpoint to view space\n        const midpoint3d = edge.midpoint3d;\n\n        // Transform to view space (camera-relative coordinates)\n        const viewMatrix = camera.matrixWorldInverse;\n        const viewPos = midpoint3d.clone().applyMatrix4(viewMatrix);\n\n        // viewPos.z is negative in front of camera, so we negate it\n        const viewZ = -viewPos.z;\n\n        // Convert to 0-1 range matching MeshDepthMaterial\n        const expectedDepth = (viewZ - near) / (far - near);\n\n        // Debug logging\n        if (debugCount < 10) {\n            console.log(`Edge ${debugCount}: sample=${sampledDepth.toFixed(4)}, expected=${expectedDepth.toFixed(4)}, diff=${(sampledDepth - expectedDepth).toFixed(6)}`);\n            debugCount++;\n        }\n\n        // Compare: edge is visible if sampled depth >= expected depth (within tolerance)\n        // sampledDepth is depth of closest surface at this pixel\n        // expectedDepth is depth of the edge\n        // Edge is visible if it's at or in front of (closer than) the sampled surface\n        const isVisible = Math.abs(sampledDepth - expectedDepth) < epsilon || sampledDepth >= expectedDepth - epsilon;\n\n        if (isVisible) {\n            edge.visible = true;\n            visibleEdges.push(edge);\n        }\n    }\n\n    // Cleanup\n    renderTarget.dispose();\n    depthMaterial.dispose();\n\n    return visibleEdges;\n}\n\n/**\n * Test edge visibility using face ID buffer (correct occlusion)\n * Renders each face with a unique color = face index\n * Samples at edge midpoint to check if parent face is visible\n * @param {Edge2D[]} edges \n * @param {Mesh[]} meshes - All meshes in scene\n * @param {Camera} camera \n * @param {number} width - Viewport width\n * @param {number} height - Viewport height\n * @param {any} renderer - THREE.WebGLRenderer instance\n * @param {boolean} isProfile - If true, these are profile edges (always visible)\n * @returns {Edge2D[]}\n */\nexport function testOcclusionFaceID(edges, meshes, camera, width, height, renderer, isProfile = false) {\n    // Profile edges are ALWAYS visible (silhouette edges)\n    if (isProfile) {\n        edges.forEach(e => e.visible = true);\n        return edges;\n    }\n\n    const visibleEdges = [];\n\n    if (!renderer) {\n        console.warn('No renderer provided, skipping occlusion test');\n        return edges;\n    }\n\n    // Create render target for face IDs\n    const renderTarget = new WebGLRenderTarget(width, height, {\n        minFilter: NearestFilter,\n        magFilter: NearestFilter,\n        format: RGBAFormat,\n        type: UnsignedByteType\n    });\n\n    // Create face ID shader material\n    const faceIdMaterial = new ShaderMaterial({\n        vertexShader: `\n            attribute vec3 faceColor;\n            varying vec3 vFaceColor;\n            void main() {\n                vFaceColor = faceColor;\n                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n            }\n        `,\n        fragmentShader: `\n            varying vec3 vFaceColor;\n            void main() {\n                gl_FragColor = vec4(vFaceColor, 1.0);\n            }\n        `,\n        side: DoubleSide\n    });\n\n    // Build meshes with face ID colors\n    const faceIdMeshes = [];\n    let globalFaceOffset = 0;\n\n    for (const mesh of meshes) {\n        const geom = mesh.geometry;\n        const position = geom.attributes.position;\n        const index = geom.index;\n\n        const numFaces = index ? index.count / 3 : position.count / 3;\n\n        // Create new geometry with face colors - APPLY WORLD TRANSFORM\n        const newPositions = [];\n        const faceColors = [];\n\n        for (let f = 0; f < numFaces; f++) {\n            let i0, i1, i2;\n            if (index) {\n                i0 = index.getX(f * 3);\n                i1 = index.getX(f * 3 + 1);\n                i2 = index.getX(f * 3 + 2);\n            } else {\n                i0 = f * 3;\n                i1 = f * 3 + 1;\n                i2 = f * 3 + 2;\n            }\n\n            // Get vertices and APPLY WORLD TRANSFORM\n            const v0 = new Vector3(position.getX(i0), position.getY(i0), position.getZ(i0));\n            const v1 = new Vector3(position.getX(i1), position.getY(i1), position.getZ(i1));\n            const v2 = new Vector3(position.getX(i2), position.getY(i2), position.getZ(i2));\n\n            v0.applyMatrix4(mesh.matrixWorld);\n            v1.applyMatrix4(mesh.matrixWorld);\n            v2.applyMatrix4(mesh.matrixWorld);\n\n            // Add world-space positions\n            newPositions.push(v0.x, v0.y, v0.z, v1.x, v1.y, v1.z, v2.x, v2.y, v2.z);\n\n            // Encode face ID as RGB (globalFaceOffset + f + 1, reserve 0 for background)\n            const globalFaceId = globalFaceOffset + f + 1;\n            const r = (globalFaceId & 0xFF) / 255;\n            const g = ((globalFaceId >> 8) & 0xFF) / 255;\n            const b = ((globalFaceId >> 16) & 0xFF) / 255;\n\n            // Same color for all 3 vertices of this face\n            faceColors.push(r, g, b, r, g, b, r, g, b);\n        }\n\n        // Create geometry with world-space positions\n        const newGeom = new BufferGeometry();\n        newGeom.setAttribute('position', new BufferAttribute(new Float32Array(newPositions), 3));\n        newGeom.setAttribute('faceColor', new BufferAttribute(new Float32Array(faceColors), 3));\n\n        // Create mesh - no need for matrix since positions are already in world space\n        const faceIdMesh = new Mesh(newGeom, faceIdMaterial);\n        faceIdMeshes.push(faceIdMesh);\n\n        globalFaceOffset += numFaces;\n    }\n\n    // Create temporary scene with ALL face ID meshes\n    const tempScene = new Scene();\n    for (const faceIdMesh of faceIdMeshes) {\n        tempScene.add(faceIdMesh);\n    }\n\n    // Render ALL meshes TOGETHER in one pass\n    renderer.setRenderTarget(renderTarget);\n    renderer.setClearColor(0x000000, 1);\n    renderer.clear();\n    renderer.render(tempScene, camera);\n\n    // Read the render target\n    const faceIdData = new Uint8Array(width * height * 4);\n    renderer.readRenderTargetPixels(renderTarget, 0, 0, width, height, faceIdData);\n\n    // Restore renderer\n    renderer.setRenderTarget(null);\n\n    // Process edges\n    for (const edge of edges) {\n        const midX = (edge.a.x + edge.b.x) / 2;\n        const midY = (edge.a.y + edge.b.y) / 2;\n\n        const sx = Math.round(midX + width / 2);\n        const sy = Math.round(height / 2 + midY);\n\n        if (sx < 0 || sx >= width || sy < 0 || sy >= height) {\n            edge.visible = true;\n            visibleEdges.push(edge);\n            continue;\n        }\n\n        const idx = ((height - 1 - sy) * width + sx) * 4;\n        const r = faceIdData[idx];\n        const g = faceIdData[idx + 1];\n        const b = faceIdData[idx + 2];\n\n        const sampledFaceId = r + (g << 8) + (b << 16);\n\n        // If 0 (background), edge is visible\n        if (sampledFaceId === 0) {\n            edge.visible = true;\n            visibleEdges.push(edge);\n            continue;\n        }\n\n        // Edge parent face ID is faceIdx + 1 (we offset by 1 to reserve 0 for background)\n        const parentFaceId = edge.faceIdx + 1;\n\n        // Edge is visible if sampled face matches parent face\n        if (sampledFaceId === parentFaceId) {\n            edge.visible = true;\n            visibleEdges.push(edge);\n        } else {\n            edge.visible = false;\n        }\n    }\n\n    // Cleanup\n    renderTarget.dispose();\n    faceIdMaterial.dispose();\n    for (const m of faceIdMeshes) {\n        m.geometry.dispose();\n    }\n\n    return visibleEdges;\n}\n\n/**\n * Pure mathematical point-in-triangle test (2D)\n * @param {Vector2} p - Point to test\n * @param {Vector2} a - Triangle vertex A\n * @param {Vector2} b - Triangle vertex B\n * @param {Vector2} c - Triangle vertex C\n * @returns {boolean}\n */\nfunction pointInTriangle2D(p, a, b, c) {\n    /**\n     * \n     * @param {Vector2} p1 \n     * @param {Vector2} p2 \n     * @param {Vector2} p3 \n     * @returns \n     */\n    const sign = (p1, p2, p3) =>\n        (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);\n\n    const d1 = sign(p, a, b);\n    const d2 = sign(p, b, c);\n    const d3 = sign(p, c, a);\n\n    const hasNeg = (d1 < 0) || (d2 < 0) || (d3 < 0);\n    const hasPos = (d1 > 0) || (d2 > 0) || (d3 > 0);\n\n    return !(hasNeg && hasPos);\n}\n\n/**\n * Check if edge lies along a face edge (collinear and within)\n * @param {Vector2} edgeA - Edge start point\n * @param {Vector2} edgeB - Edge end point\n * @param {Vector2} faceEdgeA - Face edge start point\n * @param {Vector2} faceEdgeB - Face edge end point\n * @param {number} tolerance - Distance tolerance in pixels\n * @returns {boolean}\n */\nfunction edgeLiesAlongFaceEdge(edgeA, edgeB, faceEdgeA, faceEdgeB, tolerance = 2.0) {\n    // Get face edge direction and length\n    const dx = faceEdgeB.x - faceEdgeA.x;\n    const dy = faceEdgeB.y - faceEdgeA.y;\n    const lenSq = dx * dx + dy * dy;\n    if (lenSq < 1e-10) return false;  // Degenerate face edge\n\n    // Project edge endpoints onto face edge line\n    /** @param {{x:number, y:number}} p - Point with x,y */\n    const projectAndCheck = (p) => {\n        // Project p onto line defined by faceEdgeA->faceEdgeB\n        const t = ((p.x - faceEdgeA.x) * dx + (p.y - faceEdgeA.y) * dy) / lenSq;\n\n        // Projected point\n        const projX = faceEdgeA.x + t * dx;\n        const projY = faceEdgeA.y + t * dy;\n\n        // Distance from p to projected point\n        const distSq = (p.x - projX) * (p.x - projX) + (p.y - projY) * (p.y - projY);\n\n        // Check if close to line and within segment (with small margin)\n        return distSq < tolerance * tolerance && t >= -0.01 && t <= 1.01;\n    };\n\n    // Both edge endpoints must lie along the face edge\n    return projectAndCheck(edgeA) && projectAndCheck(edgeB);\n}\n\n/**\n * Find all faces adjacent to an edge geometrically\n * @param {Edge2D} edge - Edge with a, b (2D points)\n * @param {ProjectedFace[]} projectedFaces - Array of projected faces\n * @returns {{ face: ProjectedFace, matchedEdge: string, matchType: string}[]} - Array of matching faces with match type\n */\nexport function findAdjacentFaces(edge, projectedFaces) {\n    const results = [];\n\n    for (const face of projectedFaces) {\n        // Get the three edges of the face\n        const faceEdges = [\n            { a: face.a2d, b: face.b2d, name: 'AB' },\n            { a: face.b2d, b: face.c2d, name: 'BC' },\n            { a: face.c2d, b: face.a2d, name: 'CA' }\n        ];\n\n        for (const fe of faceEdges) {\n            if (edgeLiesAlongFaceEdge(edge.a, edge.b, fe.a, fe.b)) {\n                results.push({\n                    face,\n                    matchedEdge: fe.name,\n                    matchType: 'collinear'\n                });\n                break;  // Found a match for this face, move to next\n            }\n        }\n    }\n\n    return results;\n}\n\n/**\n * Compute depth at point inside triangle using barycentric interpolation\n * @param {Vector2} p - Point to compute depth at\n * @param {Vector2} a - Triangle vertex A (2D)\n * @param {Vector2} b - Triangle vertex B (2D)\n * @param {Vector2} c - Triangle vertex C (2D)\n * @param {number} depthA - Depth at vertex A\n * @param {number} depthB - Depth at vertex B\n * @param {number} depthC - Depth at vertex C\n * @returns {number} - Interpolated depth at p\n */\nfunction barycentricDepth(p, a, b, c, depthA, depthB, depthC) {\n    // Compute barycentric coordinates\n    const v0 = { x: c.x - a.x, y: c.y - a.y };\n    const v1 = { x: b.x - a.x, y: b.y - a.y };\n    const v2 = { x: p.x - a.x, y: p.y - a.y };\n\n    const dot00 = v0.x * v0.x + v0.y * v0.y;\n    const dot01 = v0.x * v1.x + v0.y * v1.y;\n    const dot02 = v0.x * v2.x + v0.y * v2.y;\n    const dot11 = v1.x * v1.x + v1.y * v1.y;\n    const dot12 = v1.x * v2.x + v1.y * v2.y;\n\n    const denom = dot00 * dot11 - dot01 * dot01;\n    if (Math.abs(denom) < 1e-10) return Infinity;\n\n    const u = (dot11 * dot02 - dot01 * dot12) / denom;\n    const v = (dot00 * dot12 - dot01 * dot02) / denom;\n    const w = 1 - u - v;\n\n    return w * depthA + v * depthB + u * depthC;\n}\n\n/**\n * Post-split smooth filter: removes T-junction straggler edges that lie on a coplanar face\n * This catches \"straggler\" edges from T-junctions that extend into smooth surfaces\n * @param {Edge2D[]} edges - Split edges to filter\n * @param {ProjectedFace[]} projectedFaces - Projected faces with normals\n * @param {number} coplanarThreshold - Normal dot product threshold (default 0.99)\n * @param {number} distanceThreshold - Plane distance threshold (default 0.5)\n * @returns {Edge2D[]}\n */\nexport function filterSmoothSplitEdges(edges, projectedFaces, coplanarThreshold = 0.99, distanceThreshold = 0.5) {\n    const filteredEdges = [];\n    let removedCount = 0;\n\n    for (const edge of edges) {\n        // Find all adjacent faces geometrically\n        const adjacentFaces = findAdjacentFaces(edge, projectedFaces);\n\n        // Store adjacent face count for debugging\n        edge.adjacentFaceCount = adjacentFaces.length;\n\n        let shouldRemove = false;\n\n        // Only remove if we have exactly 2 faces with matching normals AND matching plane constants\n        if (adjacentFaces.length === 2) {\n            const f1 = adjacentFaces[0].face;\n            const f2 = adjacentFaces[1].face;\n            const fn1 = f1.normal;\n            const fn2 = f2.normal;\n\n            if (fn1 && fn2) {\n                const dot = fn1.dot(fn2);\n                const similarity = Math.abs(dot);\n                edge.faceSimilarity = similarity;\n\n                // Check distance between planes (must be very close to be truly coplanar)\n                // If normals are parallel (dot > 0), d1 ~ d2 => diff ~ 0\n                // If normals are anti-parallel (dot < 0), d1 ~ -d2 => sum ~ 0\n                let distDiff;\n                if (dot > 0) {\n                    distDiff = Math.abs(f1.constant - f2.constant);\n                } else {\n                    distDiff = Math.abs(f1.constant + f2.constant);\n                }\n\n                if (similarity >= coplanarThreshold && distDiff < distanceThreshold) {\n                    // Edge lies between exactly 2 coplanar faces - remove it\n                    shouldRemove = true;\n                    removedCount++;\n                }\n            }\n        } else if (adjacentFaces.length > 2) {\n            // 3+ faces: check if ALL normals match AND ALL planes match\n            const faces = adjacentFaces.map(af => af.face).filter(f => f.normal);\n            if (faces.length >= 2) {\n                let allCoplanar = true;\n                let minSimilarity = 1;\n\n                for (let i = 1; i < faces.length; i++) {\n                    const dot = faces[0].normal.dot(faces[i].normal);\n                    const sim = Math.abs(dot);\n\n                    let distDiff;\n                    if (dot > 0) {\n                        distDiff = Math.abs(faces[0].constant - faces[i].constant);\n                    } else {\n                        distDiff = Math.abs(faces[0].constant + faces[i].constant);\n                    }\n\n                    minSimilarity = Math.min(minSimilarity, sim);\n\n                    if (sim < coplanarThreshold || distDiff >= distanceThreshold) {\n                        allCoplanar = false;\n                        break;\n                    }\n                }\n                edge.faceSimilarity = minSimilarity;\n\n                if (allCoplanar) {\n                    shouldRemove = true;\n                    removedCount++;\n                }\n            }\n        }\n\n        if (!shouldRemove) {\n            filteredEdges.push(edge);\n        }\n    }\n\n    console.log(`Geometric straggler filter: removed ${removedCount} coplanar edges`);\n    return filteredEdges;\n}\n/**\n * Test edge visibility using pure math (point-in-triangle + depth)\n * No GPU, no raycasting - fully mathematical\n * @param {Edge2D[]} edges \n * @param {ProjectedFace[]} projectedFaces - Array of {a2d, b2d, c2d, depthA, depthB, depthC, mesh, faceIdx}\n * @param {Camera} camera\n * @returns {Edge2D[]}\n */\nexport function testOcclusionMath(edges, projectedFaces, camera) {\n    const cameraPos = camera.position;\n\n    // JS fallback\n    return testOcclusionMathJS(edges, projectedFaces, cameraPos);\n}\n\n/**\n * JS fallback for occlusion testing\n * @param {Edge2D[]} edges \n * @param {ProjectedFace[]} projectedFaces \n * @param {Vector3} cameraPos \n * @returns {Edge2D[]}\n */\nfunction testOcclusionMathJS(edges, projectedFaces, cameraPos) {\n    const visibleEdges = [];\n    let debugHitCount = 0;\n    let debugOccludedCount = 0;\n\n    for (const edge of edges) {\n        // Get midpoint in 2D and 3D\n        const mid2d = new Vector2(\n            (edge.a.x + edge.b.x) / 2,\n            (edge.a.y + edge.b.y) / 2\n        );\n\n        // Compute edge midpoint depth (distance from camera)\n        const mid3d = edge.midpoint3d;\n        const edgeDepth = cameraPos.distanceTo(mid3d);\n\n        let occluded = false;\n\n        // Check against ALL faces\n        for (const face of projectedFaces) {\n            // Skip if this is the edge's parent face\n            if (face.mesh === edge.mesh &&\n                (face.faceIdx === edge.faceIdx || face.faceIdx === edge.faceIdx2)) {\n                continue;\n            }\n\n            // Point-in-triangle test in 2D\n            if (!pointInTriangle2D(mid2d, face.a2d, face.b2d, face.c2d)) {\n                continue;\n            }\n\n            // Compute depth of the face at this 2D point\n            const faceDepthAtPoint = barycentricDepth(\n                mid2d, face.a2d, face.b2d, face.c2d,\n                face.depthA, face.depthB, face.depthC\n            );\n\n            // If face is closer  edge is occluded\n            if (faceDepthAtPoint < edgeDepth - 0.001) {\n                occluded = true;\n                debugOccludedCount++;\n                break;\n            }\n            debugHitCount++;\n        }\n\n        if (!occluded) {\n            edge.visible = true;\n            visibleEdges.push(edge);\n        } else {\n            edge.visible = false;\n        }\n    }\n\n    console.log(`[JS] Occlusion debug: ${debugHitCount} point-in-triangle hits, ${debugOccludedCount} occluded`);\n    return visibleEdges;\n}\n\n/**\n * Test edge visibility using raycasting (slow fallback)\n * @param {Edge2D[]} edges \n * @param {Scene} scene \n * @param {Camera} camera \n * @param {number} epsilon - Distance tolerance (as fraction of distance)\n * @returns {Edge2D[]}\n */\nexport function testOcclusion(edges, scene, camera, epsilon = 0.05) {\n    const raycaster = new Raycaster();\n    const visibleEdges = [];\n\n    // Collect all meshes in the scene for intersection testing\n    /** @type {any[]} */\n    const meshes = [];\n    scene.traverse((obj) => {\n        // @ts-ignore - isMesh exists on Mesh objects\n        if (obj.isMesh) {\n            meshes.push(obj);\n        }\n    });\n\n    for (const edge of edges) {\n        // Get direction from camera to midpoint\n        const toMidpoint = new Vector3().subVectors(edge.midpoint3d, camera.position);\n        const direction = toMidpoint.clone().normalize();\n        const expectedDist = toMidpoint.length();\n\n        // Use relative epsilon based on distance\n        const relEps = expectedDist * epsilon;\n\n        // Raycast from camera towards the edge midpoint\n        raycaster.set(camera.position.clone(), direction);\n\n        const intersects = raycaster.intersectObjects(meshes, true);\n\n        if (intersects.length === 0) {\n            // No hit - edge is visible\n            edge.visible = true;\n            visibleEdges.push(edge);\n        } else {\n            // Check if any hit is significantly in front of the edge\n            let occluded = false;\n\n            for (const hit of intersects) {\n                // Skip hits at or beyond the edge's depth\n                if (hit.distance >= expectedDist - relEps) {\n                    continue;\n                }\n\n                // For same-mesh hits, check if it's the edge's own face\n                if (hit.object === edge.mesh) {\n                    // Skip if this is the same face the edge belongs to\n                    if (hit.faceIndex === edge.faceIdx) {\n                        continue;\n                    }\n                }\n\n                // Something is in front of the edge - it's occluded\n                occluded = true;\n                break;\n            }\n\n            if (!occluded) {\n                edge.visible = true;\n                visibleEdges.push(edge);\n            } else {\n                edge.visible = false;\n            }\n        }\n    }\n\n    return visibleEdges;\n}\n\n/**\n * Remove duplicate segments and merge colinear ones\n * @param {Edge2D[]} edges \n * @param {number} tolerance \n * @returns {Edge2D[]}\n */\nexport function optimizeEdges(edges, tolerance = 0.5) {\n    // Deduplicate using hash\n    /** @type {Map<string, Edge2D>} */\n    const unique = new Map();\n\n    /** @param {Point2D} p */\n    const hashPoint = (p) => `${Math.round(p.x / tolerance)},${Math.round(p.y / tolerance)}`;\n    /** @param {Edge2D} e */\n    const hashEdge = (e) => {\n        const h1 = hashPoint(e.a);\n        const h2 = hashPoint(e.b);\n        return h1 < h2 ? `${h1}-${h2}` : `${h2}-${h1}`;\n    };\n\n    for (const edge of edges) {\n        const key = hashEdge(edge);\n        if (!unique.has(key)) {\n            unique.set(key, edge);\n        }\n    }\n\n    // TODO: Merge colinear segments\n\n    return Array.from(unique.values());\n}\n\n/**\n * Cleanup orphaned edges by extending to find intersections\n * An orphaned endpoint is a vertex with only 1 connected edge\n * Strategy: extend orphan edges and find line-line intersections\n * @param {Edge2D[]} edges - Edges to clean up\n * @param {number} tolerance - Distance tolerance for vertex matching\n * @param {number} maxExtension - Maximum distance to extend an edge\n * @returns {Edge2D[]}\n */\nexport function cleanupOrphanedEdges(edges, tolerance = 1.0, maxExtension = 50) {\n    // Build vertex -> edge connectivity map\n\n    const vertexKey = (/** @type {Point2D} */ p) => `${Math.round(p.x / tolerance)},${Math.round(p.y / tolerance)}`;\n\n    // Map of vertex hash -> { edges: [{edge, endpoint: 'a'|'b'}], point: Point2D }\n    const vertices = new Map();\n\n    for (const edge of edges) {\n        for (const endpoint of /** @type {const} */ (['a', 'b'])) {\n            /** @type {Point2D} */\n            const p = endpoint === 'a' ? edge.a : edge.b;\n            const key = vertexKey(p);\n            if (!vertices.has(key)) {\n                vertices.set(key, { edges: [], point: { x: p.x, y: p.y } });\n            }\n            vertices.get(key).edges.push({ edge, endpoint });\n        }\n    }\n\n    // Find orphaned endpoints (vertices with only 1 edge)\n    const orphans = [];\n    for (const [key, vertex] of vertices) {\n        if (vertex.edges.length === 1) {\n            const { edge, endpoint } = vertex.edges[0];\n            const orphanPoint = vertex.point;\n            const otherPoint = endpoint === 'a' ? edge.b : edge.a;\n\n            // Compute direction (from fixed end toward orphan end)\n            const dx = orphanPoint.x - otherPoint.x;\n            const dy = orphanPoint.y - otherPoint.y;\n            const len = Math.sqrt(dx * dx + dy * dy);\n            if (len < 0.001) continue;\n\n            orphans.push({\n                key,\n                edge,\n                endpoint,\n                point: orphanPoint,\n                otherPoint,\n                dirX: dx / len,\n                dirY: dy / len,\n                len\n            });\n        }\n    }\n\n    console.log(`Edge cleanup: found ${orphans.length} orphaned endpoints`);\n    if (orphans.length === 0) return edges;\n\n    // Line-line intersection helper\n    // Returns t values for intersection point on both lines, or null if parallel\n    /**\n     * \n     * @param {Point2D} p1 \n     * @param {Point2D} d1 \n     * @param {Point2D} p2 \n     * @param {Point2D} d2 \n     * @returns {{t1: number, t2: number}|null}\n     */\n    const lineIntersection = (p1, d1, p2, d2) => {\n        const cross = d1.x * d2.y - d1.y * d2.x;\n        if (Math.abs(cross) < 0.0001) return null; // Parallel\n\n        const dx = p2.x - p1.x;\n        const dy = p2.y - p1.y;\n\n        const t1 = (dx * d2.y - dy * d2.x) / cross;\n        const t2 = (dx * d1.y - dy * d1.x) / cross;\n\n        return { t1, t2 };\n    };\n\n    let extensionsCount = 0;\n    const processed = new Set();\n\n    for (let i = 0; i < orphans.length; i++) {\n        const orphan = orphans[i];\n        if (processed.has(orphan.key)) continue;\n\n        let bestMatch = null;\n        /** @type {Point2D | null} */\n        let bestIntersection = null;\n        let bestDist = Infinity;\n\n        for (let j = 0; j < orphans.length; j++) {\n            if (i === j) continue;\n            const candidate = orphans[j];\n            if (processed.has(candidate.key)) continue;\n\n            // Check if candidate's orphan point is reasonably close\n            const dist = Math.sqrt(\n                (candidate.point.x - orphan.point.x) ** 2 +\n                (candidate.point.y - orphan.point.y) ** 2\n            );\n            if (dist > maxExtension * 2) continue;\n\n            // Extend both lines and find intersection\n            // orphan: starts at orphan.point, direction orphan.dirX/dirY\n            // candidate: starts at candidate.point, direction candidate.dirX/dirY\n            const result = lineIntersection(\n                { x: orphan.point.x, y: orphan.point.y },\n                { x: orphan.dirX, y: orphan.dirY },\n                { x: candidate.point.x, y: candidate.point.y },\n                { x: candidate.dirX, y: candidate.dirY }\n            );\n\n            if (!result) continue; // Parallel lines\n\n            // t1 > 0 means intersection is in forward direction from orphan\n            // t2 > 0 means intersection is in forward direction from candidate\n            // Both must be positive (extending, not backtracking)\n            if (result.t1 < -0.1 || result.t2 < -0.1) continue;\n            if (result.t1 > maxExtension || result.t2 > maxExtension) continue;\n\n            // Compute intersection point\n            const ix = orphan.point.x + result.t1 * orphan.dirX;\n            const iy = orphan.point.y + result.t1 * orphan.dirY;\n\n            // Prefer closer intersections\n            const intersectDist = result.t1 + result.t2;\n            if (intersectDist < bestDist) {\n                bestDist = intersectDist;\n                bestMatch = candidate;\n                bestIntersection = { x: ix, y: iy };\n            }\n        }\n\n        if (bestMatch && bestIntersection) {\n            // Check if extension would cross any other edges\n            // Check segment from orphan.point to intersection\n            const crosses1 = segmentCrossesEdges(\n                orphan.point,\n                bestIntersection,\n                edges,\n                orphan.edge,\n                bestMatch.edge\n            );\n            // Check segment from bestMatch.point to intersection\n            const crosses2 = segmentCrossesEdges(\n                bestMatch.point,\n                bestIntersection,\n                edges,\n                orphan.edge,\n                bestMatch.edge\n            );\n\n            if (crosses1 || crosses2) {\n                // Skip this extension - it would cross existing edges\n                continue;\n            }\n\n            // Extend both edges to meet at intersection point\n            if (orphan.endpoint === 'a') {\n                orphan.edge.a.x = bestIntersection.x;\n                orphan.edge.a.y = bestIntersection.y;\n            } else {\n                orphan.edge.b.x = bestIntersection.x;\n                orphan.edge.b.y = bestIntersection.y;\n            }\n\n            if (bestMatch.endpoint === 'a') {\n                bestMatch.edge.a.x = bestIntersection.x;\n                bestMatch.edge.a.y = bestIntersection.y;\n            } else {\n                bestMatch.edge.b.x = bestIntersection.x;\n                bestMatch.edge.b.y = bestIntersection.y;\n            }\n\n            processed.add(orphan.key);\n            processed.add(bestMatch.key);\n            extensionsCount++;\n        }\n    }\n\n    console.log(`Edge cleanup: extended ${extensionsCount} pairs of edges to intersections`);\n\n    // Calculate average edge length for threshold\n    let totalLength = 0;\n    for (const edge of edges) {\n        const dx = edge.b.x - edge.a.x;\n        const dy = edge.b.y - edge.a.y;\n        totalLength += Math.sqrt(dx * dx + dy * dy);\n    }\n    const avgEdgeLength = totalLength / edges.length;\n    const snapThreshold = avgEdgeLength / 8;\n\n    console.log(`Edge cleanup: average edge length = ${avgEdgeLength.toFixed(2)}, snap threshold = ${snapThreshold.toFixed(2)}`);\n\n    // Rebuild orphan list after extensions\n    const finalVertices = new Map();\n    for (const edge of edges) {\n        for (const endpoint of /** @type {const} */ (['a', 'b'])) {\n            /** @type {Point2D} */\n            const p = endpoint === 'a' ? edge.a : edge.b;\n            const key = vertexKey(p);\n            if (!finalVertices.has(key)) {\n                finalVertices.set(key, { edges: [], point: p });\n            }\n            finalVertices.get(key).edges.push({ edge, endpoint });\n        }\n    }\n\n    // Find remaining orphans\n    const finalOrphans = [];\n    for (const [key, vertex] of finalVertices) {\n        if (vertex.edges.length === 1) {\n            finalOrphans.push({ key, ...vertex.edges[0], point: vertex.point });\n        }\n    }\n\n    console.log(`Edge cleanup: ${finalOrphans.length} orphaned endpoints before snap pass`);\n\n    // Snap nearby orphans together\n    let snapCount = 0;\n    const snapped = new Set();\n\n    for (let i = 0; i < finalOrphans.length; i++) {\n        const orphan = finalOrphans[i];\n        if (snapped.has(orphan.key)) continue;\n\n        let nearestOrphan = null;\n        let nearestDist = Infinity;\n\n        for (let j = 0; j < finalOrphans.length; j++) {\n            if (i === j) continue;\n            const candidate = finalOrphans[j];\n            if (snapped.has(candidate.key)) continue;\n\n            const dist = Math.sqrt(\n                (candidate.point.x - orphan.point.x) ** 2 +\n                (candidate.point.y - orphan.point.y) ** 2\n            );\n\n            if (dist < nearestDist) {\n                nearestDist = dist;\n                nearestOrphan = candidate;\n            }\n        }\n\n        if (nearestOrphan && nearestDist < snapThreshold) {\n            // Snap both to the midpoint\n            const midX = (orphan.point.x + nearestOrphan.point.x) / 2;\n            const midY = (orphan.point.y + nearestOrphan.point.y) / 2;\n\n            if (orphan.endpoint === 'a') {\n                orphan.edge.a.x = midX;\n                orphan.edge.a.y = midY;\n            } else {\n                orphan.edge.b.x = midX;\n                orphan.edge.b.y = midY;\n            }\n\n            if (nearestOrphan.endpoint === 'a') {\n                nearestOrphan.edge.a.x = midX;\n                nearestOrphan.edge.a.y = midY;\n            } else {\n                nearestOrphan.edge.b.x = midX;\n                nearestOrphan.edge.b.y = midY;\n            }\n\n            snapped.add(orphan.key);\n            snapped.add(nearestOrphan.key);\n            snapCount++;\n        }\n    }\n\n    console.log(`Edge cleanup: snapped ${snapCount} pairs of nearby orphans`);\n\n    // Final count\n    const remainingOrphans = finalOrphans.length - (snapCount * 2);\n    console.log(`Edge cleanup: ${remainingOrphans} orphaned endpoints remaining`);\n\n    return edges;\n}\n\n/**\n * Remove isolated edges where BOTH endpoints are orphaned (no connections to other edges)\n * These are floating edge fragments that don't connect to anything\n * @param {Edge2D[]} edges - Edges to filter\n * @param {number} tolerance - Distance tolerance for vertex matching\n * @returns {Edge2D[]} Filtered edges\n */\nexport function removeIsolatedEdges(edges, tolerance = 1.0) {\n\n    const vertexKey = (/** @type {Vector2} */ p) => `${Math.round(p.x / tolerance)},${Math.round(p.y / tolerance)}`;\n\n    // Count connections per vertex\n    const vertexConnections = new Map();\n\n    for (const edge of edges) {\n        const keyA = vertexKey(edge.a);\n        const keyB = vertexKey(edge.b);\n\n        vertexConnections.set(keyA, (vertexConnections.get(keyA) || 0) + 1);\n        vertexConnections.set(keyB, (vertexConnections.get(keyB) || 0) + 1);\n    }\n\n    // Filter out edges where both endpoints have only 1 connection (orphaned at both ends)\n    const filtered = edges.filter(edge => {\n        const keyA = vertexKey(edge.a);\n        const keyB = vertexKey(edge.b);\n        const connectionsA = vertexConnections.get(keyA) || 0;\n        const connectionsB = vertexConnections.get(keyB) || 0;\n\n        // Keep edge if at least one endpoint has 2+ connections\n        return connectionsA >= 2 || connectionsB >= 2;\n    });\n\n    const removed = edges.length - filtered.length;\n    if (removed > 0) {\n        console.log(`Edge cleanup: removed ${removed} isolated edges (orphaned at both ends)`);\n    }\n\n    return filtered;\n}\n\n/**\n * Check if a segment from p1 to p2 crosses any existing edge\n * @param {Point2D} p1 - Start point\n * @param {Point2D} p2 - End point\n * @param {Edge2D[]} edges - Existing edges to check against\n * @param {Edge2D} excludeEdge1 - Edge to exclude from check\n * @param {Edge2D} excludeEdge2 - Edge to exclude from check\n * @returns {boolean} True if segment crosses an edge\n */\nfunction segmentCrossesEdges(p1, p2, edges, excludeEdge1, excludeEdge2) {\n    const eps = 0.001;\n\n    for (const edge of edges) {\n        if (edge === excludeEdge1 || edge === excludeEdge2) continue;\n\n        // Check if segment p1->p2 intersects edge.a->edge.b\n        const d1x = p2.x - p1.x;\n        const d1y = p2.y - p1.y;\n        const d2x = edge.b.x - edge.a.x;\n        const d2y = edge.b.y - edge.a.y;\n\n        const cross = d1x * d2y - d1y * d2x;\n        if (Math.abs(cross) < eps) continue; // Parallel\n\n        const dx = edge.a.x - p1.x;\n        const dy = edge.a.y - p1.y;\n\n        const t1 = (dx * d2y - dy * d2x) / cross;\n        const t2 = (dx * d1y - dy * d1x) / cross;\n\n        // Check if intersection is within both segments (with small margin)\n        if (t1 > eps && t1 < 1 - eps && t2 > eps && t2 < 1 - eps) {\n            return true; // Crosses an edge\n        }\n    }\n\n    return false;\n}\n\n/**\n * Main hidden line removal function\n * @param {Mesh} mesh \n * @param {Camera} camera \n * @param {Scene} scene \n * @param {Object} options\n * @param {number} [options.smoothThreshold] - Threshold for smooth edge removal (default 0.99)\n * @param {number} [options.gridSize] - Spatial hash grid size (default 32)\n * @param {number} [options.occlusionEpsilon] - Occlusion test tolerance (relative to camera distance)\n * @param {boolean} [options.skipOcclusion] - Skip occlusion testing (debug mode)\n * @param {number} [options.width] - Viewport width\n * @param {number} [options.height] - Viewport height\n * @param {any} [options.renderer] - THREE.WebGLRenderer for depth buffer occlusion (fast)\n * @returns {{edges: Edge2D[], profiles: Edge2D[]}}\n */\nexport function computeHiddenLines(mesh, camera, scene, options = {}) {\n    const {\n        smoothThreshold = 0.99,\n        gridSize = 32,\n        occlusionEpsilon = 0.01, // 1% depth tolerance for depth buffer\n        skipOcclusion = false,\n        width = 800,\n        height = 600,\n        renderer = null\n    } = options;\n\n    console.time('extractEdges');\n    const edges3d = extractEdges(mesh, camera.position);\n    console.timeEnd('extractEdges');\n    console.log(`Extracted ${edges3d.length} edges`);\n\n    console.time('filterBackfacing');\n    const frontEdges = filterBackfacing(edges3d, camera.position);\n    console.timeEnd('filterBackfacing');\n    console.log(`After backface filter: ${frontEdges.length} edges`);\n\n    console.time('classifyEdges');\n    const { profiles, smoothFiltered } = classifyEdges(frontEdges, camera.position, smoothThreshold);\n    console.timeEnd('classifyEdges');\n    console.log(`Profiles: ${profiles.length}, Smooth edges: ${smoothFiltered.length}`);\n\n    // Combine profile and smooth edges for processing\n    const allEdges = [...profiles, ...smoothFiltered];\n\n    console.time('projectEdges');\n    let edges2d = projectEdges(allEdges, camera, width, height);\n    console.timeEnd('projectEdges');\n\n    // Mark profile edges\n    for (let i = 0; i < profiles.length; i++) {\n        edges2d[i].isProfile = true;\n    }\n\n    console.time('spatialHash');\n    const cellSize = Math.max(width, height) / gridSize;\n    const hash = new SpatialHash(cellSize);\n    for (const edge of edges2d) {\n        hash.insert(edge);\n    }\n    console.timeEnd('spatialHash');\n\n    console.time('splitIntersections');\n    // Process each cell\n    const processedEdges = new Set();\n    let splitEdges = [];\n\n    for (const cellKey of hash.getAllCells()) {\n        const cellEdges = hash.query(cellKey).filter(e => !processedEdges.has(e));\n        const split = splitAtIntersections(cellEdges);\n        splitEdges.push(...split);\n        for (const e of cellEdges) processedEdges.add(e);\n    }\n    console.timeEnd('splitIntersections');\n    console.log(`After splitting: ${splitEdges.length} edges`);\n\n    let visibleEdges;\n    if (skipOcclusion) {\n        console.log('Skipping occlusion test (debug mode)');\n        visibleEdges = splitEdges;\n    } else if (renderer) {\n        console.time('testOcclusion (face ID buffer)');\n        // Separate profile and non-profile edges\n        const profileEdges = splitEdges.filter(e => e.isProfile);\n        const otherEdges = splitEdges.filter(e => !e.isProfile);\n\n        // Profile edges are ALWAYS visible (silhouette edges)\n        profileEdges.forEach(e => e.visible = true);\n\n        // Test occlusion only for non-profile edges using face ID buffer\n        const visibleOtherEdges = testOcclusionFaceID(otherEdges, [mesh], camera, width, height, renderer, false);\n\n        visibleEdges = [...profileEdges, ...visibleOtherEdges];\n        console.timeEnd('testOcclusion (face ID buffer)');\n    } else {\n        console.time('testOcclusion (raycaster - slow)');\n        visibleEdges = testOcclusion(splitEdges, scene, camera, occlusionEpsilon);\n        console.timeEnd('testOcclusion (raycaster - slow)');\n    }\n    console.log(`Visible edges: ${visibleEdges.length}`);\n\n    console.time('optimize');\n    const optimizedEdges = optimizeEdges(visibleEdges);\n    console.timeEnd('optimize');\n\n    console.time('cleanup orphans');\n    const finalEdges = cleanupOrphanedEdges(optimizedEdges);\n    console.timeEnd('cleanup orphans');\n    console.log(`Final edges: ${finalEdges.length}`);\n\n    return {\n        edges: finalEdges,\n        profiles: finalEdges.filter(e => e.isProfile)\n    };\n}\n\n/**\n * Hidden line removal for multiple meshes with cross-object occlusion\n * All meshes are rendered to a single face ID buffer for correct occlusion\n * @param {Mesh[]} meshes \n * @param {Camera} camera \n * @param {Scene} scene \n * @param {Object} options\n * @param {number} [options.smoothThreshold]\n * @param {number} [options.gridSize]\n * @param {boolean} [options.skipOcclusion]\n * @param {number} [options.width]\n * @param {number} [options.height]\n * @param {any} [options.renderer]\n * @param {Edge3D[]} [options.hatchEdges] - Optional array of Edge3D objects for hatching\n * @param {number} [options.minHatchDotProduct] - Minimum dot product with view vector to keep hatch edges (0-1)\n * @param {number} [options.internalScale] - Internal scale factor (default: 4)\n * @param {number} [options.distanceThreshold] - Distance threshold for coplanar detection (default: 0.5)\n * @returns {{edges: Edge2D[], profiles: Edge2D[], allEdges: Edge2D[], projectedFaces: ProjectedFace[]}}\n */\nexport function computeHiddenLinesMultiple(meshes, camera, scene, options = {}) {\n    const {\n        smoothThreshold = 0.99,\n        gridSize = 32,\n        skipOcclusion = false,\n        width = 800,\n        height = 600,\n        renderer = null,\n        internalScale = 4,  // Scale up internally for better precision\n        distanceThreshold = 0.5 // Default plane distance threshold\n    } = options;\n\n    // Process each mesh to extract edges (keep local face indices with mesh reference)\n    let allEdges3d = [];\n\n    for (const mesh of meshes) {\n        mesh.updateMatrixWorld(true);\n        const edges3d = extractEdges(mesh, camera.position);\n        // Edges already have mesh reference and local faceIdx1/faceIdx2 from extractEdges\n        allEdges3d.push(...edges3d);\n    }\n\n    console.log(`Extracted ${allEdges3d.length} edges from ${meshes.length} meshes`);\n\n    // Classify edges: identify profiles and filter smooth edges\n    const { profiles, smoothFiltered } = classifyEdges(allEdges3d, camera.position, smoothThreshold);\n    console.log(`Profiles: ${profiles.length}, Crease edges: ${smoothFiltered.length}`);\n\n    const allEdges = [...profiles, ...smoothFiltered];\n    console.log(`After smooth filter: ${allEdges.length} edges`);\n\n    // Project to 2D (with internal scale for precision)\n    let edges2d = projectEdges(allEdges, camera, width, height, internalScale);\n\n    // Process additional hatch edges if provided\n    if (options.hatchEdges && options.hatchEdges.length > 0) {\n        console.log(`Processing ${options.hatchEdges.length} hatch edges...`);\n        // Filter backfacing hatch edges\n        let visibleHatch = filterBackfacing(options.hatchEdges, camera.position);\n\n        // Filter over-dense hatching based on view angle\n        if (options.minHatchDotProduct !== undefined) {\n            const threshold = options.minHatchDotProduct;\n            visibleHatch = visibleHatch.filter(edge => {\n                const edgeMidpoint = new Vector3().addVectors(edge.a, edge.b).multiplyScalar(0.5);\n                const viewDir = new Vector3().subVectors(camera.position, edgeMidpoint).normalize();\n                const dot = edge.normal1.dot(viewDir);\n                return Math.abs(dot) >= threshold;\n            });\n            console.log(`Density filter: kept ${visibleHatch.length} hatch edges (threshold ${threshold})`);\n        }\n\n        // Project\n        const hatch2d = projectEdges(visibleHatch, camera, width, height, internalScale);\n\n        // Mark explicitly (in case projectEdges didn't catch it from source)\n        hatch2d.forEach(e => e.isHatch = true);\n\n        // Add to main list\n        edges2d.push(...hatch2d);\n        console.log(`Added ${hatch2d.length} visible hatch edges`);\n    }\n\n    // Mark profile edges\n    // Split all edges at intersections (direct O(n) comparison - no spatial hash)\n    console.time('splitIntersections');\n    const splitEdges = splitAtIntersections(edges2d);\n    console.timeEnd('splitIntersections');\n    console.log(`After splitting: ${splitEdges.length} edges`);\n\n    // Build projected faces array for math occlusion\n    console.time('buildProjectedFaces');\n    /** @type {ProjectedFace[]} */\n    const projectedFaces = [];\n    const cameraPos = camera.position;\n    const halfWidth = width / 2;\n    const halfHeight = height / 2;\n\n    for (const mesh of meshes) {\n        const geom = mesh.geometry;\n        const position = geom.attributes.position;\n        const index = geom.index;\n        const numFaces = index ? index.count / 3 : position.count / 3;\n\n        for (let f = 0; f < numFaces; f++) {\n            let i0, i1, i2;\n            if (index) {\n                i0 = index.getX(f * 3);\n                i1 = index.getX(f * 3 + 1);\n                i2 = index.getX(f * 3 + 2);\n            } else {\n                i0 = f * 3;\n                i1 = f * 3 + 1;\n                i2 = f * 3 + 2;\n            }\n\n            // Get world-space vertices\n            const v0 = new Vector3(position.getX(i0), position.getY(i0), position.getZ(i0)).applyMatrix4(mesh.matrixWorld);\n            const v1 = new Vector3(position.getX(i1), position.getY(i1), position.getZ(i1)).applyMatrix4(mesh.matrixWorld);\n            const v2 = new Vector3(position.getX(i2), position.getY(i2), position.getZ(i2)).applyMatrix4(mesh.matrixWorld);\n\n            // Compute face normal and check if front-facing\n            const edge1 = new Vector3().subVectors(v1, v0);\n            const edge2 = new Vector3().subVectors(v2, v0);\n            const normal = new Vector3().crossVectors(edge1, edge2).normalize();\n            const faceMid = new Vector3().addVectors(v0, v1).add(v2).divideScalar(3);\n            const viewDir = new Vector3().subVectors(cameraPos, faceMid);\n\n            // Plane constant d for the plane equation ax + by + cz + d = 0\n            // d = -(n . p)\n            const constant = -normal.dot(v0);\n\n            // Only include front-facing faces (back-facing can't occlude)\n            if (normal.dot(viewDir) <= 0) continue;\n\n            // Project to 2D\n            const p0 = v0.clone().project(camera);\n            const p1 = v1.clone().project(camera);\n            const p2 = v2.clone().project(camera);\n\n            // Convert to screen coordinates (with same scale as edges)\n            const a2d = new Vector2(p0.x * halfWidth * internalScale, -p0.y * halfHeight * internalScale);\n            const b2d = new Vector2(p1.x * halfWidth * internalScale, -p1.y * halfHeight * internalScale);\n            const c2d = new Vector2(p2.x * halfWidth * internalScale, -p2.y * halfHeight * internalScale);\n\n            // Compute depths (distance from camera)\n            const depthA = cameraPos.distanceTo(v0);\n            const depthB = cameraPos.distanceTo(v1);\n            const depthC = cameraPos.distanceTo(v2);\n\n            projectedFaces.push({\n                a2d, b2d, c2d,\n                depthA, depthB, depthC,\n                mesh, faceIdx: f,\n                normal,  // Store normal for post-split smooth filter\n                constant // Store plane constant for coplanar detection\n            });\n        }\n    }\n    console.timeEnd('buildProjectedFaces');\n    console.log(`Built ${projectedFaces.length} projected faces for occlusion`);\n\n    // Classify silhouette edges (edges that border the void) - BEFORE cleanup/optimization\n    console.time('classifySilhouettes');\n    classifySilhouettes(splitEdges, projectedFaces);\n    console.timeEnd('classifySilhouettes');\n\n    // Geometric straggler filter: remove edges lying between coplanar faces\n    console.time('filterSmoothSplitEdges');\n    const smoothFilteredEdges = filterSmoothSplitEdges(splitEdges, projectedFaces, smoothThreshold, distanceThreshold);\n    console.timeEnd('filterSmoothSplitEdges');\n\n    // Occlusion using pure math\n    let visibleEdges;\n    if (skipOcclusion) {\n        visibleEdges = smoothFilteredEdges;\n    } else {\n        console.time('testOcclusion (math)');\n        // Test ALL edges through occlusion (no special treatment for profiles)\n        visibleEdges = testOcclusionMath(smoothFilteredEdges, projectedFaces, camera);\n        console.timeEnd('testOcclusion (math)');\n    }\n    console.log(`Visible edges: ${visibleEdges.length}`);\n\n    console.time('optimize');\n    const optimizedEdges = optimizeEdges(visibleEdges);\n    console.timeEnd('optimize');\n\n    console.time('cleanup orphans');\n    const cleanedEdges = cleanupOrphanedEdges(optimizedEdges);\n    console.timeEnd('cleanup orphans');\n\n    // Remove completely isolated edges (orphaned at both ends)\n    const filteredEdges = removeIsolatedEdges(cleanedEdges);\n    console.log(`Final edges before optimization: ${filteredEdges.length}`);\n\n    // Run through Optimize.js\n    let optimizedFinal = filteredEdges;\n    if (filteredEdges.length > 0) {\n        let totalLen = 0;\n        for (const e of filteredEdges) {\n            const dx = e.b.x - e.a.x;\n            const dy = e.b.y - e.a.y;\n            totalLen += Math.sqrt(dx * dx + dy * dy);\n        }\n        const avgLen = totalLen / filteredEdges.length;\n        const smallDist = avgLen / 10;\n        console.log(`Optimization: avgLen=${avgLen.toFixed(2)}, trim limit=${smallDist.toFixed(2)}`);\n\n        console.time('Optimize.segments');\n        // @ts-ignore - _segments is private but we need the raw objects to preserve metadata\n        optimizedFinal = Optimize.segments(filteredEdges, false, true, smallDist, false, false, false)._segments;\n        console.timeEnd('Optimize.segments');\n        console.log(`After optimization: ${optimizedFinal.length} edges`);\n    }\n\n\n\n    // Scale edges back down to original coordinate space\n    for (const edge of optimizedFinal) {\n        edge.a.x /= internalScale;\n        edge.a.y /= internalScale;\n        edge.b.x /= internalScale;\n        edge.b.y /= internalScale;\n    }\n    const finalEdges = optimizedFinal;\n\n    return {\n        edges: finalEdges,\n        profiles: finalEdges.filter(e => e.isProfile),\n        allEdges: splitEdges, // For debug visualization\n        projectedFaces: projectedFaces  // For face visualization\n    };\n}\n\n/**\n * Classify edges as silhouettes if they border the void (one side has no mesh)\n * Uses 2D ray casting from edge midpoint perpendicular to the edge\n * @param {Edge2D[]} edges - Edges to classify\n * @param {ProjectedFace[]} projectedFaces - Projected triangles for hit testing\n */\nfunction classifySilhouettes(edges, projectedFaces) {\n    const RAY_LENGTH = 1000; // Long ray to ensure we hit any face on that side\n\n    for (const edge of edges) {\n        // Hatches are never silhouettes\n        if (edge.isHatch) {\n            edge.isSilhouette = false;\n            continue;\n        }\n\n        // Calculate midpoint\n        const midX = (edge.a.x + edge.b.x) / 2;\n        const midY = (edge.a.y + edge.b.y) / 2;\n\n        // Calculate edge direction and perpendicular\n        const dx = edge.b.x - edge.a.x;\n        const dy = edge.b.y - edge.a.y;\n        const len = Math.sqrt(dx * dx + dy * dy);\n\n        if (len < 0.001) {\n            edge.isSilhouette = false;\n            continue;\n        }\n\n        // Perpendicular direction (normalized)\n        const perpX = -dy / len;\n        const perpY = dx / len;\n\n        // Raycast on each side - check if ray intersects any face edge\n        const leftHit = rayHitsAnyFace(midX, midY, perpX, perpY, RAY_LENGTH, projectedFaces);\n        const rightHit = rayHitsAnyFace(midX, midY, -perpX, -perpY, RAY_LENGTH, projectedFaces);\n\n        // Silhouette if one side has no intersection\n        edge.isSilhouette = !leftHit || !rightHit;\n    }\n\n    const silCount = edges.filter(e => e.isSilhouette).length;\n    console.log(`Classified ${silCount} silhouette edges out of ${edges.length}`);\n}\n\n/**\n * Check if a 2D ray from origin in direction (dx, dy) intersects any projected triangle\n * @param {number} ox - Ray origin X\n * @param {number} oy - Ray origin Y\n * @param {number} dx - Ray direction X\n * @param {number} dy - Ray direction Y\n * @param {number} maxDist - Maximum ray distance\n * @param {ProjectedFace[]} faces - Array of projected faces\n * @returns {boolean}\n */\nfunction rayHitsAnyFace(ox, oy, dx, dy, maxDist, faces) {\n    for (const face of faces) {\n        if (rayIntersectsTriangle(ox, oy, dx, dy, maxDist, face.a2d, face.b2d, face.c2d)) {\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * Check if 2D ray intersects a triangle (any of its 3 edges)\n * @param {number} ox - Ray origin X\n * @param {number} oy - Ray origin Y\n * @param {number} rdx - Ray direction X\n * @param {number} rdy - Ray direction Y\n * @param {number} maxDist\n * @param {Vector2} a - Triangle vertex A\n * @param {Vector2} b - Triangle vertex B\n * @param {Vector2} c - Triangle vertex C\n * @returns {boolean}\n */\nfunction rayIntersectsTriangle(ox, oy, rdx, rdy, maxDist, a, b, c) {\n    if (raySegmentIntersect(ox, oy, rdx, rdy, maxDist, a.x, a.y, b.x, b.y)) return true;\n    if (raySegmentIntersect(ox, oy, rdx, rdy, maxDist, b.x, b.y, c.x, c.y)) return true;\n    if (raySegmentIntersect(ox, oy, rdx, rdy, maxDist, c.x, c.y, a.x, a.y)) return true;\n    return false;\n}\n\n/**\n * Check if 2D ray (origin ox,oy, direction rdx,rdy) intersects line segment (x1,y1)-(x2,y2)\n * @param {number} ox\n * @param {number} oy\n * @param {number} rdx\n * @param {number} rdy\n * @param {number} maxDist\n * @param {number} x1\n * @param {number} y1\n * @param {number} x2\n * @param {number} y2\n * @returns {boolean}\n */\nfunction raySegmentIntersect(ox, oy, rdx, rdy, maxDist, x1, y1, x2, y2) {\n    const sdx = x2 - x1;\n    const sdy = y2 - y1;\n\n    const denom = rdx * sdy - rdy * sdx;\n    if (Math.abs(denom) < 1e-10) return false; // Parallel\n\n    const t = ((x1 - ox) * sdy - (y1 - oy) * sdx) / denom;\n    const u = ((x1 - ox) * rdy - (y1 - oy) * rdx) / denom;\n\n    // t > 0.1 (past origin, small epsilon), t <= maxDist, u in [0,1] (on segment)\n    return t > 0.1 && t <= maxDist && u >= 0 && u <= 1;\n}\n\n/**\n * Check if a 2D point is inside any projected triangle\n * @param {number} px \n * @param {number} py \n * @param {ProjectedFace[]} faces \n * @returns {boolean}\n */\nfunction pointInAnyFace(px, py, faces) {\n    for (const face of faces) {\n        if (pointInTriangle(px, py, face.a2d, face.b2d, face.c2d)) {\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * Check if point (px, py) is inside triangle (a, b, c) using barycentric coordinates\n * @param {number} px \n * @param {number} py \n * @param {Vector2} a \n * @param {Vector2} b \n * @param {Vector2} c \n * @returns {boolean}\n */\nfunction pointInTriangle(px, py, a, b, c) {\n    const v0x = c.x - a.x;\n    const v0y = c.y - a.y;\n    const v1x = b.x - a.x;\n    const v1y = b.y - a.y;\n    const v2x = px - a.x;\n    const v2y = py - a.y;\n\n    const dot00 = v0x * v0x + v0y * v0y;\n    const dot01 = v0x * v1x + v0y * v1y;\n    const dot02 = v0x * v2x + v0y * v2y;\n    const dot11 = v1x * v1x + v1y * v1y;\n    const dot12 = v1x * v2x + v1y * v2y;\n\n    const invDenom = 1 / (dot00 * dot11 - dot01 * dot01);\n    const u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n    const v = (dot00 * dot12 - dot01 * dot02) * invDenom;\n\n    return (u >= 0) && (v >= 0) && (u + v <= 1);\n}\n","/**\n * PlotterRenderer - GPU-based SVG renderer for Three.js\n * Based on SVGRenderer by @mrdoob / http://mrdoob.com/\n */\n\nimport { Camera, Color, Object3D, Vector3 } from \"three\";\nimport { extractNormalRegions } from \"./gpu-silhouette.js\";\nimport { generatePerspectiveHatches, clipLineOutsidePolygon } from \"./perspective-hatch.js\";\nimport { computeHiddenLinesMultiple } from \"./hidden-line.js\";\n\nvar lop = (n) => {\n  return Math.round(n * 100) / 100;\n};\n\nvar SVGObject = function (node) {\n  Object3D.call(this);\n  this.node = node;\n};\n\nSVGObject.prototype = Object.create(Object3D.prototype);\nSVGObject.prototype.constructor = SVGObject;\n\nvar PlotterRenderer = function () {\n  var _this = this,\n    _svg = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\"),\n    _silhouettes = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\"),\n    _edges = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\"),\n    _shading = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\"),\n    _svgWidth,\n    _svgHeight,\n    _svgWidthHalf,\n    _svgHeightHalf,\n    _clearColor = new Color();\n\n  // Add proper SVG namespace attributes for macOS and native rendering\n  _svg.setAttribute(\"xmlns\", \"http://www.w3.org/2000/svg\");\n  _svg.setAttribute(\"xmlns:inkscape\", \"http://www.inkscape.org/namespaces/inkscape\");\n  _svg.setAttribute(\"xmlns:xlink\", \"http://www.w3.org/1999/xlink\");\n  _svg.setAttribute(\"version\", \"1.1\");\n\n  // Setup SVG layers (order determines z-index: later = on top)\n  _silhouettes.setAttribute(\"inkscape:label\", \"Silhouettes\");\n  _silhouettes.setAttribute(\"inkscape:groupmode\", \"layer\");\n  _silhouettes.id = \"silhouettes_layer\";\n  _svg.appendChild(_silhouettes);\n\n  _shading.setAttribute(\"inkscape:label\", \"Shading\");\n  _shading.setAttribute(\"inkscape:groupmode\", \"layer\");\n  _shading.id = \"shading_layer\";\n  _svg.appendChild(_shading);\n\n  _edges.setAttribute(\"inkscape:label\", \"Edges\");\n  _edges.setAttribute(\"inkscape:groupmode\", \"layer\");\n  _edges.id = \"edges_layer\";\n  _svg.appendChild(_edges);\n\n  this.domElement = _svg;\n\n  // Layer toggles\n  this.showSilhouettes = true;\n  this.showEdges = true;\n  this.showHatches = true;\n\n  // Silhouette options (GPU normal regions)\n  this.silhouetteOptions = {\n    normalBuckets: 12,\n    simplifyTolerance: 2.0,\n    minArea: 100\n  };\n\n  // Hatch options (perspective hatching)\n  this.hatchOptions = {\n    baseSpacing: 8,\n    minSpacing: 3,\n    maxSpacing: 40,\n    depthFactor: 0.5,\n    insetPixels: 3,\n    stroke: 'black',\n    strokeWidth: '1px',\n    axisSettings: {\n      x: { rotation: 0, spacing: 8 },\n      y: { rotation: 0, spacing: 8 },\n      z: { rotation: 0, spacing: 8 }\n    }\n  };\n\n  // Edge options (hidden line edges)\n  this.edgeOptions = {\n    stroke: 'white',\n    strokeWidth: '1px'\n  };\n\n  // Hidden-line options\n  this.hiddenLineOptions = {\n    smoothThreshold: 0.99\n  };\n\n  // WebGL renderer reference (needed for GPU operations)\n  this._glRenderer = null;\n\n  this.autoClear = true;\n\n  this.setClearColor = function (color) {\n    _clearColor.set(color);\n  };\n\n  this.setPixelRatio = function () { };\n\n  this.setSize = function (width, height) {\n    _svgWidth = width;\n    _svgHeight = height;\n    _svgWidthHalf = _svgWidth / 2;\n    _svgHeightHalf = _svgHeight / 2;\n\n    _svg.setAttribute(\"viewBox\", -_svgWidthHalf + \" \" + -_svgHeightHalf + \" \" + _svgWidth + \" \" + _svgHeight);\n    _svg.setAttribute(\"width\", _svgWidth);\n    _svg.setAttribute(\"height\", _svgHeight);\n  };\n\n  this.getSize = function () {\n    return {\n      width: _svgWidth,\n      height: _svgHeight,\n    };\n  };\n\n  this.setGLRenderer = function (glRenderer) {\n    _this._glRenderer = glRenderer;\n  };\n\n  function removeChildNodes() {\n    while (_silhouettes.childNodes.length > 0) {\n      _silhouettes.removeChild(_silhouettes.childNodes[0]);\n    }\n    while (_edges.childNodes.length > 0) {\n      _edges.removeChild(_edges.childNodes[0]);\n    }\n    while (_shading.childNodes.length > 0) {\n      _shading.removeChild(_shading.childNodes[0]);\n    }\n  }\n\n  this.clear = function () {\n    removeChildNodes();\n    _svg.style.backgroundColor = _clearColor.getStyle();\n  };\n\n  /**\n   * Render GPU-based layers (silhouettes and hatches)\n   * @param {Object} scene - Three.js scene\n   * @param {Object} camera - Three.js camera\n   */\n  this.renderGPULayers = function (scene, camera) {\n    if (!_this._glRenderer) {\n      console.warn(\"PlotterRenderer: WebGL renderer not set. Call setGLRenderer() first.\");\n      return;\n    }\n\n    const glRenderer = _this._glRenderer;\n\n    // GPU Silhouettes (region fills based on normal direction)\n    if (_this.showSilhouettes || _this.showHatches) {\n      const regions = extractNormalRegions(glRenderer, scene, camera, {\n        normalBuckets: _this.silhouetteOptions.normalBuckets,\n        simplifyTolerance: _this.silhouetteOptions.simplifyTolerance,\n        minArea: _this.silhouetteOptions.minArea,\n        insetPixels: _this.showHatches ? _this.hatchOptions.insetPixels : 0\n      });\n\n      // Draw silhouette fills\n      if (_this.showSilhouettes) {\n        regions.forEach(region => {\n          if (region.boundary.length < 3) return;\n\n          const path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n          let d = \"\";\n          region.boundary.forEach((pt, i) => {\n            const x = pt.x;\n            const y = -pt.y; // GPU regions use different Y convention\n            d += (i === 0 ? \"M\" : \"L\") + lop(x) + \",\" + lop(y);\n          });\n          d += \"Z\";\n\n          // Color based on normal direction\n          const n = region.normal;\n          const r = Math.floor((n.x * 0.5 + 0.5) * 255);\n          const g = Math.floor((n.y * 0.5 + 0.5) * 255);\n          const b = Math.floor((n.z * 0.5 + 0.5) * 255);\n\n          path.setAttribute(\"d\", d);\n          path.setAttribute(\"fill\", `rgba(${r},${g},${b},0.3)`);\n          path.setAttribute(\"stroke\", \"none\");\n          _silhouettes.appendChild(path);\n        });\n      }\n\n      // GPU Perspective Hatches (render before edges so edges appear on top)\n      if (_this.showHatches) {\n        // Sort by depth (front first) for occlusion\n        regions.sort((a, b) => a.depth - b.depth);\n        const allRegionBounds = regions.map(r => r.boundary);\n\n        regions.forEach((region, idx) => {\n          let hatches = generatePerspectiveHatches(region, camera, {\n            baseSpacing: _this.hatchOptions.baseSpacing,\n            minSpacing: _this.hatchOptions.minSpacing,\n            maxSpacing: _this.hatchOptions.maxSpacing,\n            depthFactor: _this.hatchOptions.depthFactor,\n            insetPixels: _this.hatchOptions.insetPixels,\n            screenWidth: _svgWidth,\n            screenHeight: _svgHeight,\n            axisSettings: _this.hatchOptions.axisSettings\n          });\n\n          // Clip against front regions\n          for (let frontIdx = 0; frontIdx < idx; frontIdx++) {\n            hatches = hatches.flatMap(hatch =>\n              clipLineOutsidePolygon(hatch, allRegionBounds[frontIdx])\n            );\n          }\n\n          // Draw hatches\n          hatches.forEach(hatch => {\n            const path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n            const d = `M${lop(hatch.start.x)},${lop(-hatch.start.y)}L${lop(hatch.end.x)},${lop(-hatch.end.y)}`;\n            path.setAttribute(\"d\", d);\n            path.setAttribute(\"fill\", \"none\");\n            path.setAttribute(\"stroke\", _this.hatchOptions.stroke);\n            path.setAttribute(\"stroke-width\", _this.hatchOptions.strokeWidth);\n            _shading.appendChild(path);\n          });\n        });\n      }\n\n      // Hidden Line Edges (render last so they appear on top)\n      if (_this.showEdges) {\n        // Collect all meshes from scene\n        const meshes = [];\n        scene.traverse((obj) => {\n          if (obj.isMesh && obj.geometry) {\n            meshes.push(obj);\n          }\n        });\n\n        if (meshes.length > 0) {\n          const result = computeHiddenLinesMultiple(meshes, camera, scene, {\n            smoothThreshold: _this.hiddenLineOptions.smoothThreshold,\n            width: _svgWidth,\n            height: _svgHeight\n          });\n          const edges = result.edges || [];\n\n          edges.forEach(edge => {\n            const line = document.createElementNS(\"http://www.w3.org/2000/svg\", \"line\");\n            line.setAttribute(\"x1\", lop(edge.a.x));\n            line.setAttribute(\"y1\", lop(edge.a.y));\n            line.setAttribute(\"x2\", lop(edge.b.x));\n            line.setAttribute(\"y2\", lop(edge.b.y));\n            line.setAttribute(\"stroke\", _this.edgeOptions.stroke);\n            line.setAttribute(\"stroke-width\", _this.edgeOptions.strokeWidth);\n            _edges.appendChild(line);\n          });\n        }\n      }\n    }\n  };\n\n  /**\n   * Legacy render method - renders wireframe preview during camera movement\n   * For final output, use clear() + renderGPULayers()\n   * @param {Object} scene - Three.js scene\n   * @param {Object} camera - Three.js camera\n   */\n  this.render = function (scene, camera) {\n    if (camera instanceof Camera === false) {\n      console.error(\"PlotterRenderer.render: camera is not an instance of Camera.\");\n      return;\n    }\n\n    // For now, render is a no-op. Use renderGPULayers() for output.\n    // This maintains API compatibility with Three.js SVGRenderer\n  };\n\n};\n\nexport { SVGObject, PlotterRenderer };\n"],"names":["extractNormalRegions","renderer","scene","camera","options","resolution","normalBuckets","minArea","simplifyTolerance","insetPixels","size","Vector2","width","height","insetAmount","normalPixels","renderNormals","depthPixels","renderDepth","regionMap","normalLookup","quantizeNormals","erodeRegionMap","labels","regionCount","connectedComponents","regions","regionId","boundary","traceBoundary","simplified","rdpSimplify","area","polygonArea","normal","findRegionNormal","depth","sampleRegionDepth","p","target","WebGLRenderTarget","NearestFilter","normalMaterial","MeshNormalMaterial","originalMaterials","hiddenObjects","obj","pixels","depthMaterial","MeshDepthMaterial","RGBADepthPacking","targetLabel","sum","count","y","x","idx","g","b","a","iterations","current","iter","next","i","left","right","up","down","buckets","nextId","normalToId","nx","ny","nz","tolerance","qr","qg","qb","key","Vector3","parent","nextLabel","find","union","px","py","region","neighbors","minLabel","n","labelRemap","finalLabel","root","startX","startY","outer","dx","dy","dir","maxIter","found","checkDir","sumX","sumY","cx","normalId","points","epsilon","maxDist","maxIdx","first","last","dist","perpendicularDistance","point","lineStart","lineEnd","lenSq","t","projX","projY","j","computeHatchDirection","screenWidth","screenHeight","halfW","halfH","worldUp","worldForward","faceAxis","origin","farPoint","originScreen","farScreen","screenOrigin","direction","vpProjected","vanishingPoint","generatePerspectiveHatches","baseSpacing","minSpacing","maxSpacing","depthFactor","axisSettings","ax","ay","az","axis","settings","rotationDeg","spacingOverride","finalDirection","rad","cos","sin","perpDir","spacing","minX","maxX","minY","maxY","pt","centerX","centerY","center","diag","hatches","vpDist","numLines","angleStep","centerAngle","angle","clipped","clipLineToPolygon","offset","lineCenter","line","polygon","intersections","p1","p2","intersection","lineIntersection","result","midX","midY","pointInPolygon","clipLineOutsidePolygon","startInside","endInside","lineIntersectionFull","filtered","midT","x1","y1","x2","y2","x3","y3","x4","y4","denom","u","inside","xi","yi","xj","yj","EPSILON","Point","BoundingBox","BoundingCircle","r","Segment","segA","segB","GeomUtil","seg","SegmentCollection","pts","rot","ptA","segs","ptB","local","bb","bc","Segments","segments","arr","sA","sB","d","aA","aB","deg","oldY","oldX","rA","rB","angle1","angle2","scale","numSegs","perc","deltaX","deltaY","targetPt","sourcePt","delta","numFit","remain","travel","bbs","ab","p3","fn","ignoreTouching","s1_x","s1_y","s2_x","s2_y","s","atX","atY","intPt","ca","boundingBox","polySegs","startPt","aTouching","bTouching","aWithin","bWithin","v1","v2","v3","d1","d2","d3","has_neg","has_pos","out","polySegsA","polySegsB","ptC","divide","spts","Analyzer","splitTeeIntersections","splitCrossIntersections","cxs","originalPts","token","allPts","crossPts","da","db","newSegs","k","ta","tb","res","nekot","str","byNumConnections","oppIdx","endTokens","ang","searchMultiplier","cenTokens","pointGroups","minDx","minDy","ptArray","hDx","hDy","rayPts","rayPt","nearPts","nPt","nPtA","tokenA","ok","nPtB","tokenB","npA","npB","polyPts","cen","cenToken","Optimize","segCols","noSplit","trimSmall","smallDist","optimizePathOrder","allsegs","sc","noSplitColinear","sb","sn","aa","ba","heading","same","isRev","extractEdges","mesh","cameraPosition","geometry","position","index","edgeMap","SNAP","getEdgeKey","va","vb","bx","by","bz","keyA","keyB","getVertex","getFaceNormal","v0","edge1","edge2","numFaces","i0","i1","i2","faceMid","viewDir","edges","existing","filterBackfacing","edge","edgeMidpoint","facing1","facing2","classifyEdges","smoothThreshold","profiles","smoothFiltered","projectEdges","halfWidth","halfHeight","projectPoint","p3d","projected","SpatialHash","cellSize","cy","cells","steps","_a","findIntersection","e1","e2","t1","t2","eps","splitAtIntersections","splits","pointOnEdgeInterior","potentialStragglers","_b","tAonJ","_c","tBonJ","_d","tAonI","_e","tBonI","_f","edgeSplits","isStraggler","prevPoint","prevPoint3d","split","point3d","testOcclusionFaceID","meshes","isProfile","e","visibleEdges","renderTarget","RGBAFormat","UnsignedByteType","faceIdMaterial","ShaderMaterial","DoubleSide","faceIdMeshes","globalFaceOffset","geom","newPositions","faceColors","f","globalFaceId","newGeom","BufferGeometry","BufferAttribute","faceIdMesh","Mesh","tempScene","Scene","faceIdData","sx","sy","sampledFaceId","parentFaceId","m","pointInTriangle2D","c","sign","hasNeg","hasPos","edgeLiesAlongFaceEdge","edgeA","edgeB","faceEdgeA","faceEdgeB","projectAndCheck","findAdjacentFaces","projectedFaces","results","face","faceEdges","fe","barycentricDepth","depthA","depthB","depthC","dot00","dot01","dot02","dot11","dot12","v","filterSmoothSplitEdges","coplanarThreshold","distanceThreshold","filteredEdges","removedCount","adjacentFaces","shouldRemove","f1","f2","fn1","fn2","dot","similarity","distDiff","faces","af","allCoplanar","minSimilarity","sim","testOcclusionMath","cameraPos","testOcclusionMathJS","debugHitCount","debugOccludedCount","mid2d","mid3d","edgeDepth","occluded","testOcclusion","raycaster","Raycaster","toMidpoint","expectedDist","relEps","intersects","hit","optimizeEdges","unique","hashPoint","hashEdge","h1","h2","cleanupOrphanedEdges","maxExtension","vertexKey","vertices","endpoint","orphans","vertex","orphanPoint","otherPoint","len","cross","extensionsCount","processed","orphan","bestMatch","bestIntersection","bestDist","candidate","ix","iy","intersectDist","crosses1","segmentCrossesEdges","crosses2","totalLength","avgEdgeLength","snapThreshold","finalVertices","finalOrphans","snapCount","snapped","nearestOrphan","nearestDist","remainingOrphans","removeIsolatedEdges","vertexConnections","connectionsA","connectionsB","removed","excludeEdge1","excludeEdge2","d1x","d1y","d2x","d2y","computeHiddenLines","gridSize","occlusionEpsilon","skipOcclusion","edges3d","frontEdges","allEdges","edges2d","hash","processedEdges","splitEdges","cellKey","cellEdges","profileEdges","otherEdges","visibleOtherEdges","optimizedEdges","finalEdges","computeHiddenLinesMultiple","internalScale","allEdges3d","visibleHatch","threshold","hatch2d","constant","p0","a2d","b2d","c2d","classifySilhouettes","smoothFilteredEdges","cleanedEdges","optimizedFinal","totalLen","avgLen","perpX","perpY","leftHit","rayHitsAnyFace","rightHit","silCount","ox","oy","rayIntersectsTriangle","rdx","rdy","raySegmentIntersect","sdx","sdy","lop","SVGObject","node","Object3D","PlotterRenderer","_this","_svg","_silhouettes","_edges","_shading","_svgWidth","_svgHeight","_svgWidthHalf","_svgHeightHalf","_clearColor","Color","color","glRenderer","removeChildNodes","path","allRegionBounds","frontIdx","hatch","Camera"],"mappings":"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"}