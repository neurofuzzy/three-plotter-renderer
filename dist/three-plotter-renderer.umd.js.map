{"version":3,"file":"three-plotter-renderer.umd.js","sources":["../src/gpu-silhouette.js","../src/perspective-hatch.js","../src/geom/geom.js","../src/analyzer.js","../src/optimize.js","../src/hidden-line.js","../src/plotter-renderer.js"],"sourcesContent":["/**\n * GPU Normal-Region Polygon Extraction\n * \n * Renders quantized normals to texture, uses connected component labeling\n * to find contiguous regions with same normal, then traces boundaries.\n * \n * This approach is:\n * - Fast (GPU parallel rendering)\n * - 3D-aware (normals from actual geometry)\n * - Produces clean polygons grouped by normal direction\n */\n\nimport {\n    WebGLRenderTarget,\n    MeshNormalMaterial,\n    MeshDepthMaterial,\n    ShaderMaterial,\n    RGBADepthPacking,\n    NearestFilter,\n    FrontSide,\n    Vector2,\n    Vector3\n} from 'three';\n\n/**\n * @typedef {Object} NormalRegion\n * @property {Vector2[]} boundary - Closed boundary polygon points\n * @property {Vector3} normal - The normal direction for this region\n * @property {number} area - Region area in pixels\n * @property {number} regionId - Unique ID for this region\n */\n\n/**\n * Extract polygons grouped by normal direction\n * @param {WebGLRenderer} renderer\n * @param {Scene} scene\n * @param {Camera} camera\n * @param {Object} options\n * @returns {NormalRegion[]}\n */\nexport function extractNormalRegions(renderer, scene, camera, options = {}) {\n    const {\n        resolution = 2.0,        // Render at 2x for smooth boundaries\n        normalBuckets = 12,      // Quantize normals into N directions\n        minArea = 100,           // Minimum region area in pixels (at output scale)\n        simplifyTolerance = 2.0,\n        insetPixels = 0          // Inset boundaries by this many pixels (GPU erosion)\n    } = options;\n\n    const size = renderer.getSize(new Vector2());\n    const width = Math.floor(size.x * resolution);\n    const height = Math.floor(size.y * resolution);\n\n    // Scale inset by resolution\n    const insetAmount = Math.round(insetPixels * resolution);\n\n\n\n    // Step 1: Render normals and depth to textures\n    const normalPixels = renderNormals(renderer, scene, camera, width, height);\n    const depthPixels = renderDepth(renderer, scene, camera, width, height);\n\n    // Step 2: Quantize normals to region IDs\n    const { regionMap, normalLookup } = quantizeNormals(normalPixels, width, height, normalBuckets);\n\n    // Step 3: Connected component labeling\n    const { labels, regionCount, labelToNormalId } = connectedComponents(regionMap, width, height);\n\n    // Step 4: Trace boundaries for each region\n    const regions = [];\n    for (let regionId = 1; regionId <= regionCount; regionId++) {\n\n        const boundary = traceBoundary(labels, width, height, regionId);\n        if (boundary.length < 3) continue;\n\n        // Simplify boundary\n        const simplified = rdpSimplify(boundary, simplifyTolerance);\n        const area = Math.abs(polygonArea(simplified));\n\n        if (area < minArea) continue;\n\n        // Get normal directly from the mapping (no sampling needed!)\n        const normalId = labelToNormalId[regionId];\n        const normal = normalLookup[normalId] || new Vector3(0, 0, 1);\n\n        // Sample depth at region center\n        const depth = sampleRegionDepth(labels, depthPixels, width, height, regionId);\n\n        // Create inset boundary for hatch clipping (mathematical inset, not pixel erosion)\n        const scaledInset = insetAmount / resolution;  // Convert back to screen coords\n\n        // First convert to screen coords for inset calculation\n        const screenBoundary = simplified.map(p => ({\n            x: (p.x / resolution) - size.x / 2,\n            y: (p.y / resolution) - size.y / 2\n        }));\n\n        // Apply mathematical inset\n        const insetBoundaryScreen = insetPolygon(screenBoundary, scaledInset);\n\n        regions.push({\n            boundary: screenBoundary.map(p => new Vector2(p.x, p.y)),\n            hatchBoundary: insetBoundaryScreen.map(p => new Vector2(p.x, p.y)),\n            normal,\n            depth,  // 0-1 normalized depth\n            area: area / (resolution * resolution),\n            regionId\n        });\n    }\n\n\n    // Step 5: Detect holes (regions entirely inside another region)\n    detectHoles(regions);\n\n    return regions;\n}\n\n\n/**\n * Render normals to pixel buffer (exported for debugging)\n */\nexport function renderNormals(renderer, scene, camera, width, height) {\n    const target = new WebGLRenderTarget(width, height, {\n        minFilter: NearestFilter,\n        magFilter: NearestFilter\n    });\n\n    // Use MeshNormalMaterial for normal extraction\n    // This outputs VIEW SPACE normals - we'll transform to world space later\n    const normalMaterial = new MeshNormalMaterial({ flatShading: true });\n\n    const originalMaterials = new Map();\n    const hiddenObjects = [];\n\n    scene.traverse(obj => {\n        // Skip objects marked for SVG exclusion (including checking parent hierarchy)\n        let shouldExclude = false;\n        let parent = obj;\n        while (parent) {\n            if (parent.userData && parent.userData.excludeFromSVG) {\n                shouldExclude = true;\n                break;\n            }\n            parent = parent.parent;\n        }\n\n        if (shouldExclude) {\n            if (obj.visible) {\n                hiddenObjects.push(obj);\n                obj.visible = false;\n            }\n            return;\n        }\n\n        // Only render Mesh objects, hide helpers/lines\n        if (obj.isMesh) {\n            originalMaterials.set(obj, obj.material);\n            obj.material = normalMaterial;\n        } else if (obj.isLineSegments || obj.isLine || obj.isPoints) {\n            // Hide grid helpers, line helpers, etc.\n            if (obj.visible) {\n                hiddenObjects.push(obj);\n                obj.visible = false;\n            }\n        }\n    });\n\n    // Save and clear scene background to avoid it being rendered to the target\n    const originalBackground = scene.background;\n    scene.background = null;\n\n    renderer.setRenderTarget(target);\n    renderer.render(scene, camera);\n\n    // Restore scene background\n    scene.background = originalBackground;\n\n    scene.traverse(obj => {\n        if (obj.isMesh && originalMaterials.has(obj)) {\n            obj.material = originalMaterials.get(obj);\n        }\n    });\n\n    // Restore hidden objects (grid helpers, lines, etc.)\n    for (const obj of hiddenObjects) {\n        obj.visible = true;\n    }\n\n    renderer.setRenderTarget(null);\n\n    const pixels = new Uint8Array(width * height * 4);\n    renderer.readRenderTargetPixels(target, 0, 0, width, height, pixels);\n\n    target.dispose();\n    normalMaterial.dispose();\n\n    return pixels;\n}\n\n/**\n * Render depth to pixel buffer\n */\nfunction renderDepth(renderer, scene, camera, width, height) {\n    const target = new WebGLRenderTarget(width, height, {\n        minFilter: NearestFilter,\n        magFilter: NearestFilter\n    });\n\n    const depthMaterial = new MeshDepthMaterial({ depthPacking: RGBADepthPacking });\n\n    const originalMaterials = new Map();\n    const hiddenObjects = [];\n\n    scene.traverse(obj => {\n        // Skip objects marked for SVG exclusion (including checking parent hierarchy)\n        let shouldExclude = false;\n        let parent = obj;\n        while (parent) {\n            if (parent.userData && parent.userData.excludeFromSVG) {\n                shouldExclude = true;\n                break;\n            }\n            parent = parent.parent;\n        }\n\n        if (shouldExclude) {\n            if (obj.visible) {\n                hiddenObjects.push(obj);\n                obj.visible = false;\n            }\n            return;\n        }\n\n        if (obj.isMesh) {\n            originalMaterials.set(obj, obj.material);\n            obj.material = depthMaterial;\n        } else if (obj.isLineSegments || obj.isLine || obj.isPoints) {\n            if (obj.visible) {\n                hiddenObjects.push(obj);\n                obj.visible = false;\n            }\n        }\n    });\n\n    // Save and clear scene background to avoid it being rendered to the target\n    const originalBackground = scene.background;\n    scene.background = null;\n\n    renderer.setRenderTarget(target);\n    renderer.render(scene, camera);\n\n    // Restore scene background\n    scene.background = originalBackground;\n\n    scene.traverse(obj => {\n        if (obj.isMesh && originalMaterials.has(obj)) {\n            obj.material = originalMaterials.get(obj);\n        }\n    });\n\n    for (const obj of hiddenObjects) {\n        obj.visible = true;\n    }\n\n    renderer.setRenderTarget(null);\n\n    const pixels = new Uint8Array(width * height * 4);\n    renderer.readRenderTargetPixels(target, 0, 0, width, height, pixels);\n\n    target.dispose();\n    depthMaterial.dispose();\n\n    return pixels;\n}\n\n/**\n * Sample average depth for a region\n */\nfunction sampleRegionDepth(labels, depthPixels, width, height, targetLabel) {\n    let sum = 0, count = 0;\n\n    for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n            if (labels[y * width + x] === targetLabel) {\n                const idx = (y * width + x) * 4;\n                // Unpack RGBA depth\n                const r = depthPixels[idx] / 255;\n                const g = depthPixels[idx + 1] / 255;\n                const b = depthPixels[idx + 2] / 255;\n                const a = depthPixels[idx + 3] / 255;\n                const depth = r + g / 256 + b / 65536 + a / 16777216;\n                sum += depth;\n                count++;\n            }\n        }\n    }\n\n    return count > 0 ? sum / count : 0.5;\n}\n\n/**\n * Morphological erosion on region map\n * Only erodes pixels at the OUTER boundary (next to background 0)\n * Does NOT erode at boundaries between different regions (holes)\n */\nfunction erodeRegionMap(regionMap, width, height, iterations) {\n    let current = regionMap;\n\n    for (let iter = 0; iter < iterations; iter++) {\n        const next = new Uint16Array(current);  // Start with copy\n\n        for (let y = 1; y < height - 1; y++) {\n            for (let x = 1; x < width - 1; x++) {\n                const i = y * width + x;\n                const region = current[i];\n\n                if (region === 0) continue;\n\n                // Check 4-connected neighbors\n                // Only erode if ANY neighbor is background (0)\n                // Don't erode if neighbors are just different regions\n                const left = current[i - 1];\n                const right = current[i + 1];\n                const up = current[i - width];\n                const down = current[i + width];\n\n                if (left === 0 || right === 0 || up === 0 || down === 0) {\n                    next[i] = 0;  // Erode this pixel (it touches background)\n                }\n                // else: keep the pixel even if it touches other regions\n            }\n        }\n\n        current = next;\n    }\n\n    return current;\n}\n\n/**\n\n * Quantize normals into buckets and create region map\n * Returns regionMap (pixel -> regionId) and normalLookup (regionId -> Vector3)\n */\nfunction quantizeNormals(pixels, width, height, buckets) {\n    const regionMap = new Uint16Array(width * height);\n    const normalLookup = {}; // regionId -> Vector3 normal\n    let nextId = 1;\n    const normalToId = {}; // quantized normal string -> regionId\n\n    for (let i = 0; i < width * height; i++) {\n        const idx = i * 4;\n        const r = pixels[idx];\n        const g = pixels[idx + 1];\n        const b = pixels[idx + 2];\n\n        // Background check (black = no geometry)\n        if (r < 5 && g < 5 && b < 5) {\n            regionMap[i] = 0; // Background\n            continue;\n        }\n\n        // Decode normal from RGB (MeshNormalMaterial encodes: (n+1)/2 * 255)\n        const nx = (r / 255) * 2 - 1;\n        const ny = (g / 255) * 2 - 1;\n        const nz = (b / 255) * 2 - 1;\n\n        // Round RGB to nearest 4 for tolerance at grazing angles\n        // This groups very similar normals together to avoid sub-pixel noise\n        const tolerance = 4;\n        const qr = Math.round(r / tolerance) * tolerance;\n        const qg = Math.round(g / tolerance) * tolerance;\n        const qb = Math.round(b / tolerance) * tolerance;\n        const key = `${qr}|${qg}|${qb}`;\n\n        if (!normalToId[key]) {\n            normalToId[key] = nextId;\n            normalLookup[nextId] = new Vector3(nx, ny, nz).normalize();\n            nextId++;\n        }\n\n        regionMap[i] = normalToId[key];\n    }\n\n    return { regionMap, normalLookup };\n}\n\n/**\n * Connected component labeling using union-find\n */\nfunction connectedComponents(regionMap, width, height) {\n    const labels = new Uint32Array(width * height);\n    const parent = [];\n    let nextLabel = 1;\n\n    function find(x) {\n        if (parent[x] !== x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    function union(x, y) {\n        const px = find(x);\n        const py = find(y);\n        if (px !== py) {\n            parent[py] = px;\n        }\n    }\n\n    // First pass: assign labels\n    for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n            const i = y * width + x;\n            const region = regionMap[i];\n\n            if (region === 0) continue; // Background\n\n            const neighbors = [];\n\n            // Check left neighbor\n            if (x > 0 && regionMap[i - 1] === region && labels[i - 1] > 0) {\n                neighbors.push(labels[i - 1]);\n            }\n            // Check top neighbor\n            if (y > 0 && regionMap[i - width] === region && labels[i - width] > 0) {\n                neighbors.push(labels[i - width]);\n            }\n\n            if (neighbors.length === 0) {\n                // New label\n                labels[i] = nextLabel;\n                parent[nextLabel] = nextLabel;\n                nextLabel++;\n            } else {\n                // Use minimum neighbor label\n                const minLabel = Math.min(...neighbors);\n                labels[i] = minLabel;\n                // Union all neighbors\n                for (const n of neighbors) {\n                    union(minLabel, n);\n                }\n            }\n        }\n    }\n\n    // Second pass: flatten labels and track which normalId each label maps to\n    const labelRemap = {};\n    const labelToNormalId = {}; // Maps final label -> regionMap value (normalId)\n    let finalLabel = 0;\n\n    for (let i = 0; i < width * height; i++) {\n        if (labels[i] === 0) continue;\n        const root = find(labels[i]);\n        if (labelRemap[root] === undefined) {\n            finalLabel++;\n            labelRemap[root] = finalLabel;\n            // Capture the normalId for this label (from regionMap)\n            labelToNormalId[finalLabel] = regionMap[i];\n        }\n        labels[i] = labelRemap[root];\n    }\n\n    return { labels, regionCount: finalLabel, labelToNormalId };\n}\n\n/**\n * Trace boundary of a labeled region using Moore neighborhood\n */\nfunction traceBoundary(labels, width, height, targetLabel) {\n    const boundary = [];\n\n    // Find starting point (leftmost pixel on top row of region)\n    let startX = -1, startY = -1;\n    outer: for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n            if (labels[y * width + x] === targetLabel) {\n                // Check if it's on boundary (has non-region neighbor)\n                const hasEdge =\n                    x === 0 || labels[y * width + x - 1] !== targetLabel ||\n                    y === 0 || labels[(y - 1) * width + x] !== targetLabel;\n                if (hasEdge) {\n                    startX = x;\n                    startY = y;\n                    break outer;\n                }\n            }\n        }\n    }\n\n    if (startX === -1) return boundary;\n\n    // Moore neighborhood: 8 directions clockwise from right\n    const dx = [1, 1, 0, -1, -1, -1, 0, 1];\n    const dy = [0, 1, 1, 1, 0, -1, -1, -1];\n\n    let x = startX, y = startY;\n    let dir = 7; // Start looking up-right\n    const maxIter = width * height * 2;\n    let iter = 0;\n\n    do {\n        boundary.push({ x, y });\n\n        // Find next boundary pixel\n        let found = false;\n        for (let i = 0; i < 8; i++) {\n            const checkDir = (dir + 6 + i) % 8; // Start from dir-2 (backtrack)\n            const nx = x + dx[checkDir];\n            const ny = y + dy[checkDir];\n\n            if (nx >= 0 && nx < width && ny >= 0 && ny < height) {\n                if (labels[ny * width + nx] === targetLabel) {\n                    x = nx;\n                    y = ny;\n                    dir = checkDir;\n                    found = true;\n                    break;\n                }\n            }\n        }\n\n        if (!found) break;\n        iter++;\n    } while ((x !== startX || y !== startY) && iter < maxIter);\n\n    return boundary;\n}\n\n/**\n * Find representative normal for a region\n */\nfunction findRegionNormal(labels, regionMap, normalLookup, width, height, targetLabel) {\n    // Find center of region and sample normal\n    let sumX = 0, sumY = 0, count = 0;\n    for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n            if (labels[y * width + x] === targetLabel) {\n                sumX += x;\n                sumY += y;\n                count++;\n            }\n        }\n    }\n\n    if (count === 0) return new Vector3(0, 0, 1);\n\n    const cx = Math.round(sumX / count);\n    const cy = Math.round(sumY / count);\n    const i = cy * width + cx;\n    const normalId = regionMap[i];\n\n    return normalLookup[normalId] || new Vector3(0, 0, 1);\n}\n\n/**\n * Ramer-Douglas-Peucker simplification\n */\nfunction rdpSimplify(points, epsilon) {\n    if (points.length < 3) return points;\n\n    let maxDist = 0, maxIdx = 0;\n    const first = points[0];\n    const last = points[points.length - 1];\n\n    for (let i = 1; i < points.length - 1; i++) {\n        const dist = perpendicularDistance(points[i], first, last);\n        if (dist > maxDist) {\n            maxDist = dist;\n            maxIdx = i;\n        }\n    }\n\n    if (maxDist > epsilon) {\n        const left = rdpSimplify(points.slice(0, maxIdx + 1), epsilon);\n        const right = rdpSimplify(points.slice(maxIdx), epsilon);\n        return left.slice(0, -1).concat(right);\n    } else {\n        return [first, last];\n    }\n}\n\nfunction perpendicularDistance(point, lineStart, lineEnd) {\n    const dx = lineEnd.x - lineStart.x;\n    const dy = lineEnd.y - lineStart.y;\n    const lenSq = dx * dx + dy * dy;\n    if (lenSq < 1e-10) {\n        return Math.sqrt((point.x - lineStart.x) ** 2 + (point.y - lineStart.y) ** 2);\n    }\n    // Clamp t to [0,1] to get distance to segment, not infinite line\n    let t = ((point.x - lineStart.x) * dx + (point.y - lineStart.y) * dy) / lenSq;\n    t = Math.max(0, Math.min(1, t));\n    const projX = lineStart.x + t * dx;\n    const projY = lineStart.y + t * dy;\n    return Math.sqrt((point.x - projX) ** 2 + (point.y - projY) ** 2);\n}\n\nfunction polygonArea(points) {\n    let area = 0;\n    for (let i = 0; i < points.length; i++) {\n        const j = (i + 1) % points.length;\n        area += points[i].x * points[j].y;\n        area -= points[j].x * points[i].y;\n    }\n    return area / 2;\n}\n\n/**\n * Inset a polygon by a fixed distance (shrink inward)\n * Uses simple vertex offset along bisector of adjacent edges\n * @param {Array<{x: number, y: number}>} polygon\n * @param {number} amount - Inset amount in same units as polygon\n * @returns {Array<{x: number, y: number}>}\n */\nfunction insetPolygon(polygon, amount) {\n    if (polygon.length < 3 || amount <= 0) return polygon;\n\n    const n = polygon.length;\n    const result = [];\n\n    // Determine winding direction (positive area = CCW)\n    const area = polygonArea(polygon);\n    const sign = area > 0 ? 1 : -1;\n\n    for (let i = 0; i < n; i++) {\n        const prev = polygon[(i - 1 + n) % n];\n        const curr = polygon[i];\n        const next = polygon[(i + 1) % n];\n\n        // Compute edge vectors\n        const dx1 = curr.x - prev.x;\n        const dy1 = curr.y - prev.y;\n        const dx2 = next.x - curr.x;\n        const dy2 = next.y - curr.y;\n\n        // Normalize\n        const len1 = Math.sqrt(dx1 * dx1 + dy1 * dy1) || 1;\n        const len2 = Math.sqrt(dx2 * dx2 + dy2 * dy2) || 1;\n        const nx1 = dx1 / len1, ny1 = dy1 / len1;\n        const nx2 = dx2 / len2, ny2 = dy2 / len2;\n\n        // Inward normals (perpendicular, pointing inward based on winding)\n        const inx1 = -ny1 * sign, iny1 = nx1 * sign;\n        const inx2 = -ny2 * sign, iny2 = nx2 * sign;\n\n        // Average the two inward normals (bisector direction)\n        let bx = inx1 + inx2;\n        let by = iny1 + iny2;\n        const blen = Math.sqrt(bx * bx + by * by) || 1;\n        bx /= blen;\n        by /= blen;\n\n        // Scale by amount (adjust for angle at corner)\n        const dot = inx1 * inx2 + iny1 * iny2;\n        const scale = amount / Math.sqrt((1 + dot) / 2 + 0.001); // Miter factor\n\n        result.push({\n            x: curr.x + bx * Math.min(scale, amount * 3), // Cap miter\n            y: curr.y + by * Math.min(scale, amount * 3)\n        });\n    }\n\n    return result;\n}\n\n\n/**\n * Get axis-aligned bounding box for a polygon\n * @param {Array<{x: number, y: number}>} boundary\n * @returns {{minX: number, maxX: number, minY: number, maxY: number}}\n */\nfunction getBoundingBox(boundary) {\n    let minX = Infinity, maxX = -Infinity;\n    let minY = Infinity, maxY = -Infinity;\n    for (const pt of boundary) {\n        minX = Math.min(minX, pt.x);\n        maxX = Math.max(maxX, pt.x);\n        minY = Math.min(minY, pt.y);\n        maxY = Math.max(maxY, pt.y);\n    }\n    return { minX, maxX, minY, maxY };\n}\n\n/**\n * Check if inner bbox is fully contained within outer bbox\n */\nfunction bboxContains(outer, inner) {\n    return inner.minX >= outer.minX && inner.maxX <= outer.maxX &&\n        inner.minY >= outer.minY && inner.maxY <= outer.maxY;\n}\n\n/**\n * Point-in-polygon test using ray casting (even-odd rule)\n */\nfunction pointInPolygon(x, y, polygon) {\n    let inside = false;\n    const n = polygon.length;\n    for (let i = 0, j = n - 1; i < n; j = i++) {\n        const xi = polygon[i].x, yi = polygon[i].y;\n        const xj = polygon[j].x, yj = polygon[j].y;\n        if (((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) {\n            inside = !inside;\n        }\n    }\n    return inside;\n}\n\n/**\n * Detect which regions are holes (entirely inside another region)\n * Uses bounding box as early-out, then full point-in-polygon check\n */\nfunction detectHoles(regions) {\n    // Precompute bounding boxes\n    const bboxes = regions.map(r => getBoundingBox(r.boundary));\n\n    for (let i = 0; i < regions.length; i++) {\n        const region = regions[i];\n        region.isHole = false;\n        region.parentRegionId = null;\n\n        const bbox = bboxes[i];\n\n        for (let j = 0; j < regions.length; j++) {\n            if (i === j) continue;\n\n            const other = regions[j];\n            const otherBbox = bboxes[j];\n\n            // Early-out: bounding box check\n            if (!bboxContains(otherBbox, bbox)) continue;\n\n            // Full check: all boundary points must be inside other polygon\n            const allInside = region.boundary.every(pt =>\n                pointInPolygon(pt.x, pt.y, other.boundary)\n            );\n\n            if (allInside) {\n                region.isHole = true;\n                region.parentRegionId = other.regionId;\n                break;\n            }\n        }\n    }\n}\n\n\n\n\n/**\n * Debug visualization: show normal regions colored by their normal direction\n */\nexport function debugNormalRegions(renderer, scene, camera) {\n    const size = renderer.getSize(new Vector2());\n    const width = Math.floor(size.x);\n    const height = Math.floor(size.y);\n\n    const normalPixels = renderNormals(renderer, scene, camera, width, height);\n    const { regionMap, normalLookup } = quantizeNormals(normalPixels, width, height, 12);\n    const { labels, regionCount } = connectedComponents(regionMap, width, height);\n\n\n\n    // Create visualization\n    const canvas = document.createElement('canvas');\n    canvas.width = width;\n    canvas.height = height;\n    const ctx = canvas.getContext('2d');\n    const imageData = ctx.createImageData(width, height);\n\n    // Generate colors for each region\n    const regionColors = {};\n    for (let i = 1; i <= regionCount; i++) {\n        const hue = (i * 137.508) % 360; // Golden angle for good distribution\n        regionColors[i] = hslToRgb(hue / 360, 0.7, 0.5);\n    }\n\n    for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n            const srcIdx = (height - 1 - y) * width + x;\n            const dstIdx = (y * width + x) * 4;\n            const label = labels[srcIdx];\n\n            if (label === 0) {\n                imageData.data[dstIdx] = 30;\n                imageData.data[dstIdx + 1] = 30;\n                imageData.data[dstIdx + 2] = 30;\n            } else {\n                const [r, g, b] = regionColors[label] || [128, 128, 128];\n                imageData.data[dstIdx] = r;\n                imageData.data[dstIdx + 1] = g;\n                imageData.data[dstIdx + 2] = b;\n            }\n            imageData.data[dstIdx + 3] = 255;\n        }\n    }\n    ctx.putImageData(imageData, 0, 0);\n\n    // Show modal\n    const modal = document.createElement('div');\n    modal.style.cssText = 'position:fixed;top:0;left:0;width:100vw;height:100vh;background:rgba(0,0,0,0.8);display:flex;align-items:center;justify-content:center;z-index:10000;cursor:pointer;';\n    modal.onclick = () => modal.remove();\n    canvas.style.cssText = 'max-width:90vw;max-height:90vh;border:2px solid lime;';\n    const info = document.createElement('div');\n    info.style.cssText = 'position:absolute;top:20px;left:20px;color:lime;font-family:monospace;';\n    info.textContent = `${regionCount} regions, ${Object.keys(normalLookup).length} normal buckets (click to close)`;\n    modal.appendChild(canvas);\n    modal.appendChild(info);\n    document.body.appendChild(modal);\n}\n\nfunction hslToRgb(h, s, l) {\n    let r, g, b;\n    if (s === 0) {\n        r = g = b = l;\n    } else {\n        const hue2rgb = (p, q, t) => {\n            if (t < 0) t += 1;\n            if (t > 1) t -= 1;\n            if (t < 1 / 6) return p + (q - p) * 6 * t;\n            if (t < 1 / 2) return q;\n            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n            return p;\n        };\n        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n        const p = 2 * l - q;\n        r = hue2rgb(p, q, h + 1 / 3);\n        g = hue2rgb(p, q, h);\n        b = hue2rgb(p, q, h - 1 / 3);\n    }\n    return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];\n}\n","/**\n * Perspective Hatching\n * \n * Generates architect-style perspective hatches that converge toward\n * vanishing points based on face orientation.\n */\n\nimport { Vector2, Vector3 } from 'three';\n\n/**\n * @typedef {Object} HatchLine\n * @property {Vector2} start\n * @property {Vector2} end\n */\n\n/**\n * Compute the 2D hatch direction for a face based on its normal\n * Projects the face's primary axis to screen space\n * @param {Vector3} normal - Face normal in world space\n * @param {Camera} camera - Three.js camera\n * @param {number} screenWidth\n * @param {number} screenHeight\n * @returns {{direction: Vector2, vanishingPoint: Vector2|null}}\n */\nexport function computeHatchDirection(normal, camera, screenWidth, screenHeight) {\n    const halfW = screenWidth / 2;\n    const halfH = screenHeight / 2;\n\n    // Find a primary axis direction in the face plane\n    // For most faces, use the horizontal (XZ) direction projected onto the face\n    const worldUp = new Vector3(0, 1, 0);\n    const worldForward = new Vector3(0, 0, 1);\n\n    // Get a vector in the face plane\n    let faceAxis;\n\n    // For horizontal faces (floor/ceiling), use world Z direction\n    if (Math.abs(normal.y) > 0.9) {\n        faceAxis = worldForward.clone();\n    } else {\n        // For vertical/angled faces, use horizontal direction in face plane\n        // This is the cross product of normal with world up, gives horizontal direction in face\n        faceAxis = new Vector3().crossVectors(worldUp, normal).normalize();\n\n        // If face is vertical and facing up/down, cross product might be zero\n        if (faceAxis.lengthSq() < 0.01) {\n            faceAxis = worldForward.clone();\n        }\n    }\n\n    // Project two points along this axis to screen to get 2D direction\n    const origin = new Vector3(0, 0, 0);\n    const farPoint = faceAxis.clone().multiplyScalar(100);\n\n    const originScreen = origin.clone().project(camera);\n    const farScreen = farPoint.clone().project(camera);\n\n    // Convert to screen pixels\n    const screenOrigin = new Vector2(\n        originScreen.x * halfW,\n        -originScreen.y * halfH\n    );\n    const screenFar = new Vector2(\n        farScreen.x * halfW,\n        -farScreen.y * halfH\n    );\n\n    // 2D direction on screen\n    const direction = screenFar.clone().sub(screenOrigin).normalize();\n\n    // Compute vanishing point by projecting point at infinity along this direction\n    // VP is where parallel 3D lines converge in 2D\n    const veryFarPoint = faceAxis.clone().multiplyScalar(100000);\n    const vpProjected = veryFarPoint.clone().project(camera);\n\n    // Check if VP is visible/finite\n    let vanishingPoint = null;\n    if (Math.abs(vpProjected.x) < 100 && Math.abs(vpProjected.y) < 100 && vpProjected.z < 1) {\n        vanishingPoint = new Vector2(\n            vpProjected.x * halfW,\n            -vpProjected.y * halfH\n        );\n    }\n\n    return { direction, vanishingPoint };\n}\n\n/**\n * Generate perspective hatch lines for a region\n * @param {Object} region - Region from extractNormalRegions\n * @param {Camera} camera\n * @param {Object} options\n * @returns {HatchLine[]}\n */\nexport function generatePerspectiveHatches(region, camera, options = {}) {\n    const {\n        baseSpacing = 8,      // Base spacing in screen pixels\n        minSpacing = 3,       // Minimum spacing\n        maxSpacing = 20,      // Maximum spacing\n        depthFactor = 0.5,    // How much depth affects density\n        screenWidth = 1200,\n        screenHeight = 800,\n        axisSettings = {},    // { x: { rotation: 0, spacing: 10 }, y: ... }\n        brightness = null,    // 0-1 lighting brightness (null = disabled)\n        invertBrightness = false  // True for white-on-black (bright = dense)\n    } = options;\n\n    const { boundary, hatchBoundary, normal, depth = 0.5 } = region;\n    // Use hatchBoundary for clipping if available (inset boundary), otherwise use boundary\n    const clipBoundary = hatchBoundary || boundary;\n    if (clipBoundary.length < 3) return [];\n\n\n    // Normal is in VIEW SPACE (from MeshNormalMaterial)\n    // Transform to WORLD SPACE using camera quaternion\n    const worldNormal = normal.clone().applyQuaternion(camera.quaternion);\n\n    // Quantize to avoid floating-point variations for same-facing faces\n    const qx = Math.round(worldNormal.x * 10) / 10;\n    const qy = Math.round(worldNormal.y * 10) / 10;\n    const qz = Math.round(worldNormal.z * 10) / 10;\n\n    // Blend axis settings based on world-space normal alignment\n    const ax = Math.abs(qx);\n    const ay = Math.abs(qy);\n    const az = Math.abs(qz);\n    const total = ax + ay + az || 1;  // Avoid divide by zero\n\n    // Weight for each axis\n    const wx = ax / total;\n    const wy = ay / total;\n    const wz = az / total;\n\n    // Debug: Log first 5 regions\n    if (region.regionId <= 5) {\n        console.log(`[Hatch] Region ${region.regionId}: viewNormal=(${normal.x.toFixed(2)}, ${normal.y.toFixed(2)}, ${normal.z.toFixed(2)}) -> worldNormal=(${qx}, ${qy}, ${qz}) -> weights=(wx:${wx.toFixed(2)}, wy:${wy.toFixed(2)}, wz:${wz.toFixed(2)})`);\n    }\n\n    // Get settings for each axis (defaults)\n    const xSettings = axisSettings.x || { rotation: 0, spacing: baseSpacing };\n    const ySettings = axisSettings.y || { rotation: 0, spacing: baseSpacing };\n    const zSettings = axisSettings.z || { rotation: 0, spacing: baseSpacing };\n\n    // Blend spacing\n    const spacingOverride =\n        wx * (xSettings.spacing || baseSpacing) +\n        wy * (ySettings.spacing || baseSpacing) +\n        wz * (zSettings.spacing || baseSpacing);\n\n    // Blend rotation (weighted average)\n    const rotationDeg =\n        wx * (xSettings.rotation || 0) +\n        wy * (ySettings.rotation || 0) +\n        wz * (zSettings.rotation || 0);\n\n    // Get hatch direction from normal\n    const { direction, vanishingPoint } = computeHatchDirection(\n        normal, camera, screenWidth, screenHeight\n    );\n\n    // Apply rotation if needed\n    let finalDirection = direction;\n    if (rotationDeg !== 0) {\n        const rad = rotationDeg * (Math.PI / 180);\n        const cos = Math.cos(rad);\n        const sin = Math.sin(rad);\n        finalDirection = new Vector2(\n            direction.x * cos - direction.y * sin,\n            direction.x * sin + direction.y * cos\n        );\n    }\n\n    // Perpendicular direction for spacing\n    const perpDir = new Vector2(-finalDirection.y, finalDirection.x);\n\n    // Calculate spacing based on depth (closer = denser)\n    // Use override if available, otherwise baseSpacing\n    const effectiveBase = spacingOverride !== undefined ? spacingOverride : baseSpacing;\n    let spacing = Math.max(minSpacing, Math.min(maxSpacing,\n        effectiveBase + (depth * depthFactor * (maxSpacing - minSpacing))\n    ));\n\n    if (brightness !== null && brightness !== undefined) {\n        // brightness: 0 = shadow/dark, 1 = lit/bright\n        // \n        // For BOTH themes, lit faces should have LESS ink (more spacing):\n        // - Light theme (black ink on white): lit = sparse hatches (more white showing)\n        // - Dark theme (white ink on black): lit = sparse hatches (more black showing)\n        //\n        // invertBrightness: \n        //   false (light theme) = bright areas get more spacing (less ink)\n        //   true (dark theme) = ALSO bright areas get more spacing (less ink)\n        //\n        // So invert actually controls the paper color interpretation, not the brightness->spacing mapping\n        // Both cases want: bright = more spacing\n\n        // Map brightness to spacing multiplier (0.5x for dark to 2x for bright)\n        const brightnessMultiplier = 0.5 + brightness * 1.5;\n        spacing = spacing * brightnessMultiplier;\n\n        // If spacing exceeds maxSpacing, skip hatching entirely for this region\n        if (spacing > maxSpacing) {\n            return [];\n        }\n        spacing = Math.max(minSpacing, spacing);\n    }\n\n    // Get bounding box of region (use clipBoundary for hatch generation)\n    let minX = Infinity, maxX = -Infinity;\n    let minY = Infinity, maxY = -Infinity;\n    for (const pt of clipBoundary) {\n        minX = Math.min(minX, pt.x);\n        maxX = Math.max(maxX, pt.x);\n        minY = Math.min(minY, pt.y);\n        maxY = Math.max(maxY, pt.y);\n    }\n\n    const centerX = (minX + maxX) / 2;\n    const centerY = (minY + maxY) / 2;\n    const center = new Vector2(centerX, centerY);\n\n    // Size of region along perpendicular direction\n    const diag = Math.sqrt((maxX - minX) ** 2 + (maxY - minY) ** 2);\n\n    const hatches = [];\n\n    // If rotated, we can't easily use the VP logic unless we rotate the VP too, \n    // but typically architectural hatching with rotation implies a pattern override, \n    // so we'll often fall back to parallel for rotated patterns unless it's 0/90.\n    // For now, if rotation is significant, force parallel to avoid weird VP artifacts.\n    // OR: Rotate the vector from VP to center? \n    // Let's stick to parallel for significantly rotated hatches to keep it clean for now,\n    // as \"perspective rotated hatching\" is geometrically ambiguous.\n    const usePerspective = vanishingPoint && Math.abs(rotationDeg) < 5 && vanishingPoint.distanceTo(center) < diag * 5;\n\n    if (usePerspective) {\n        // Perspective lines converging to visible VP\n        const vpDist = vanishingPoint.distanceTo(center);\n\n        // Generate lines radiating from VP\n        const numLines = Math.ceil(diag / spacing) * 2;\n        const angularSpan = Math.atan2(diag, vpDist);\n        const angleStep = angularSpan * 2 / numLines;\n\n        // Angle from VP to center\n        const centerAngle = Math.atan2(\n            centerY - vanishingPoint.y,\n            centerX - vanishingPoint.x\n        );\n\n        for (let i = -numLines; i <= numLines; i++) {\n            const angle = centerAngle + i * angleStep;\n            const dir = new Vector2(Math.cos(angle), Math.sin(angle));\n\n            // Line from VP extending far past region\n            const lineStart = vanishingPoint.clone();\n            const lineEnd = vanishingPoint.clone().add(dir.clone().multiplyScalar(vpDist * 10));\n\n            const clipped = clipLineToPolygon({ start: lineStart, end: lineEnd }, clipBoundary);\n            hatches.push(...clipped);\n        }\n    } else {\n        // Parallel lines (VP at infinity or very far)\n        const numLines = Math.ceil(diag / spacing) + 2;\n\n        for (let i = -numLines; i <= numLines; i++) {\n            // Offset along perpendicular direction\n            const offset = perpDir.clone().multiplyScalar(i * spacing);\n            const lineCenter = center.clone().add(offset);\n\n            // Line extending in hatch direction\n            const lineStart = lineCenter.clone().add(finalDirection.clone().multiplyScalar(-diag));\n            const lineEnd = lineCenter.clone().add(finalDirection.clone().multiplyScalar(diag));\n\n            const clipped = clipLineToPolygon({ start: lineStart, end: lineEnd }, clipBoundary);\n            hatches.push(...clipped);\n        }\n    }\n\n    return hatches;\n}\n\n/**\n * Clip a line to a polygon\n */\nexport function clipLineToPolygon(line, polygon) {\n    const intersections = [];\n    const n = polygon.length;\n\n    for (let i = 0; i < n; i++) {\n        const p1 = polygon[i];\n        const p2 = polygon[(i + 1) % n];\n\n        const intersection = lineIntersection(\n            line.start.x, line.start.y, line.end.x, line.end.y,\n            p1.x, p1.y, p2.x, p2.y\n        );\n\n        if (intersection) {\n            intersections.push({\n                point: new Vector2(intersection.x, intersection.y),\n                t: intersection.t\n            });\n        }\n    }\n\n    if (intersections.length < 2) return [];\n\n    // Sort by parameter along line\n    intersections.sort((a, b) => a.t - b.t);\n\n    // Create segments between consecutive pairs, checking midpoint is inside\n    const result = [];\n    for (let i = 0; i < intersections.length - 1; i++) {\n        const midX = (intersections[i].point.x + intersections[i + 1].point.x) / 2;\n        const midY = (intersections[i].point.y + intersections[i + 1].point.y) / 2;\n\n        if (pointInPolygon(midX, midY, polygon)) {\n            result.push({\n                start: intersections[i].point,\n                end: intersections[i + 1].point\n            });\n        }\n    }\n\n    return result;\n}\n\n/**\n * Clip a line to OUTSIDE a polygon (inverse of clipLineToPolygon)\n * Returns segments that are OUTSIDE the polygon\n */\nexport function clipLineOutsidePolygon(line, polygon) {\n    const intersections = [];\n    const n = polygon.length;\n\n    // Add start and end points\n    const startInside = pointInPolygon(line.start.x, line.start.y, polygon);\n    const endInside = pointInPolygon(line.end.x, line.end.y, polygon);\n\n    intersections.push({ point: line.start.clone(), t: 0, inside: startInside });\n\n    // Find all intersections with polygon edges\n    for (let i = 0; i < n; i++) {\n        const p1 = polygon[i];\n        const p2 = polygon[(i + 1) % n];\n\n        const intersection = lineIntersectionFull(\n            line.start.x, line.start.y, line.end.x, line.end.y,\n            p1.x, p1.y, p2.x, p2.y\n        );\n\n        if (intersection && intersection.t > 0 && intersection.t < 1) {\n            intersections.push({\n                point: new Vector2(intersection.x, intersection.y),\n                t: intersection.t,\n                inside: null // will be determined by neighbors\n            });\n        }\n    }\n\n    intersections.push({ point: line.end.clone(), t: 1, inside: endInside });\n\n    // Sort by parameter\n    intersections.sort((a, b) => a.t - b.t);\n\n    // Remove duplicates (points too close together)\n    const filtered = [intersections[0]];\n    for (let i = 1; i < intersections.length; i++) {\n        if (intersections[i].t - filtered[filtered.length - 1].t > 0.0001) {\n            filtered.push(intersections[i]);\n        }\n    }\n\n    if (filtered.length < 2) return [line]; // No intersections, check if line is outside\n\n    // Build segments that are OUTSIDE\n    const result = [];\n    for (let i = 0; i < filtered.length - 1; i++) {\n        const midT = (filtered[i].t + filtered[i + 1].t) / 2;\n        const midX = line.start.x + midT * (line.end.x - line.start.x);\n        const midY = line.start.y + midT * (line.end.y - line.start.y);\n\n        // If midpoint is OUTSIDE polygon, include this segment\n        if (!pointInPolygon(midX, midY, polygon)) {\n            result.push({\n                start: filtered[i].point.clone(),\n                end: filtered[i + 1].point.clone()\n            });\n        }\n    }\n\n    return result;\n}\n\n// Full line intersection (both segments)\nfunction lineIntersectionFull(x1, y1, x2, y2, x3, y3, x4, y4) {\n    const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n    if (Math.abs(denom) < 1e-10) return null;\n\n    const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;\n    const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;\n\n    if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {\n        return {\n            x: x1 + t * (x2 - x1),\n            y: y1 + t * (y2 - y1),\n            t\n        };\n    }\n    return null;\n}\n\nfunction lineIntersection(x1, y1, x2, y2, x3, y3, x4, y4) {\n    const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n    if (Math.abs(denom) < 1e-10) return null;\n\n    const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;\n    const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;\n\n    if (u >= 0 && u <= 1) {\n        return {\n            x: x1 + t * (x2 - x1),\n            y: y1 + t * (y2 - y1),\n            t\n        };\n    }\n    return null;\n}\n\nfunction pointInPolygon(x, y, polygon) {\n    let inside = false;\n    const n = polygon.length;\n\n    for (let i = 0, j = n - 1; i < n; j = i++) {\n        const xi = polygon[i].x, yi = polygon[i].y;\n        const xj = polygon[j].x, yj = polygon[j].y;\n\n        if (((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) {\n            inside = !inside;\n        }\n    }\n\n    return inside;\n}\n","const EPSILON = 0.001;\n\nexport class Point {\n  /**\n   * @param {number} x\n   * @param {number} y\n   */\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n  /**\n   * @param {Point} pt\n   */\n  static clone(pt) {\n    return new Point(pt.x, pt.y);\n  }\n}\n\nexport class BoundingBox {\n  /**\n   * @param {number} minX\n   * @param {number} minY\n   * @param {number} maxX\n   * @param {number} maxY\n   */\n  constructor(minX, minY, maxX, maxY) {\n    this.minX = minX;\n    this.minY = minY;\n    this.maxX = maxX;\n    this.maxY = maxY;\n  }\n  width() {\n    return Math.abs(this.maxX - this.minX);\n  }\n  height() {\n    return Math.abs(this.maxY - this.minY);\n  }\n}\n\nexport class BoundingCircle {\n  /**\n   *\n   * @param {number} r radius\n   */\n  constructor(r = 0) {\n    this.r = r;\n  }\n}\n\nexport class Segment {\n  /**\n   *\n   * @param {Point} a start point\n   * @param {Point} b end point\n   */\n  constructor(a, b) {\n    this.a = a;\n    this.b = b;\n    this.tags = {};\n  }\n\n  /**\n   *\n   * @param {Segment} segA\n   * @param {Segment} segB\n   */\n  static isEqual(segA, segB) {\n    return (\n      (GeomUtil.pointsEqual(segA.a, segB.a) && GeomUtil.pointsEqual(segA.b, segB.b)) ||\n      (GeomUtil.pointsEqual(segA.b, segB.a) && GeomUtil.pointsEqual(segA.a, segB.b))\n    );\n  }\n\n  /**\n   * @param {Segment} seg\n   */\n  static clone(seg) {\n    return new Segment(new Point(seg.a.x, seg.a.y), new Point(seg.b.x, seg.b.y));\n  }\n}\n\nexport class SegmentCollection {\n  constructor() {\n    this.pivot = { x: 0, y: 0 };\n    this.rotation = 0;\n    this.isOpen = true;\n    this.isGroup = false;\n    this.isStrong = false;\n    /**\n     *\n     * @param {Point[]} pts\n     */\n    this._makeAbsolute = (pts) => {\n      let rot = (this.rotation * Math.PI) / 180;\n      pts.forEach((pt, idx) => {\n        const ptA = { x: pt.x, y: pt.y };\n        GeomUtil.rotatePoint(ptA, rot);\n        ptA.x += this.pivot.x;\n        ptA.y += this.pivot.y;\n        pts[idx] = ptA;\n      });\n    };\n    /**\n     *\n     * @param {Segment[]} segs\n     */\n    this._makeSegsAbsolute = (segs) => {\n      let rot = (this.rotation * Math.PI) / 180;\n      segs.forEach((seg) => {\n        const ptA = { x: seg.a.x, y: seg.a.y };\n        const ptB = { x: seg.b.x, y: seg.b.y };\n        GeomUtil.rotatePoint(ptA, rot);\n        GeomUtil.rotatePoint(ptB, rot);\n        GeomUtil.addToPoint(ptA, this.pivot);\n        GeomUtil.addToPoint(ptB, this.pivot);\n        seg.a = ptA;\n        seg.b = ptB;\n      });\n    };\n  }\n\n  /**\n   * @param {boolean} local\n   * @returns {Point[]}\n   */\n  toPoints(local = false) {\n    throw \"not implemented\";\n  }\n\n  /**\n   *\n   * @param {boolean} local\n   * @returns {Segment[]};\n   */\n  toSegments(local = false) {\n    throw \"not implemented\";\n  }\n\n  /**\n   *\n   * @param {boolean} local\n   * @returns {BoundingBox}\n   */\n  getBoundingBox(local = false) {\n    const bb = new BoundingBox(1000000, 1000000, -1000000, -1000000);\n    const pts = this.toPoints(local);\n    pts.forEach((pt) => {\n      bb.minX = Math.min(bb.minX, pt.x);\n      bb.minY = Math.min(bb.minY, pt.y);\n      bb.maxX = Math.max(bb.maxX, pt.x);\n      bb.maxY = Math.max(bb.maxY, pt.y);\n    });\n\n    return bb;\n  }\n\n  /**\n   * @returns {BoundingCircle}\n   */\n  getBoundingCircle() {\n    const bc = new BoundingCircle();\n    const pts = this.toPoints(true);\n    pts.forEach((pt) => {\n      bc.r = Math.max(bc.r, Math.sqrt(pt.x * pt.x + pt.y * pt.y));\n    });\n    return bc;\n  }\n}\n\nexport class Segments extends SegmentCollection {\n  /**\n   *\n   * @param {Segment[]} segments\n   */\n  constructor(segments) {\n    super();\n    /** @type {Segment[]} */\n    this._segments = segments;\n  }\n\n  /**\n   * @param {Segment[]} segs\n   */\n  add(...segs) {\n    this._segments = this._segments.concat(segs);\n  }\n\n  /**\n   * @param {boolean} local\n   * @returns {Point[]}\n   */\n  toPoints(local = false) {\n    return this.toSegments(local).reduce((arr, seg) => (seg ? arr.concat([seg.a, seg.b]) : arr), []);\n  }\n  /**\n   *\n   * @param {boolean} local\n   * @returns {Segment[]};\n   */\n  toSegments(local = false) {\n    let segs = this._segments.reduce((arr, seg) => (seg ? arr.concat(Segment.clone(seg)) : arr), []);\n    if (!local) {\n      this._makeSegsAbsolute(segs);\n    }\n    return segs;\n  }\n\n  bake() {\n    // noOp\n  }\n\n  result() {\n    return Segments.clone(this);\n  }\n\n  /**\n   *\n   * @param {Segments} segs\n   */\n  static clone(segs) {\n    let sA = segs._segments;\n    let sB = [];\n    let i = sA.length;\n    while (i--) {\n      sB.unshift(Segment.clone(sA[i]));\n    }\n    let s = new Segments(sB);\n    s.pivot.x = segs.pivot.x;\n    s.pivot.y = segs.pivot.y;\n    s.rotation = segs.rotation;\n    return s;\n  }\n}\n\nexport class GeomUtil {\n  /**\n   *\n   * @param {number} a\n   * @param {number} b\n   * @param {number} d\n   * @returns {number}\n   */\n  static lerp(a, b, d) {\n    return (1 - d) * a + d * b;\n  }\n\n  /**\n   *\n   * @param {Point} ptA\n   * @param {Point} ptB\n   */\n  static angleBetween(ptA, ptB) {\n    return Math.atan2(ptB.y - ptA.y, ptB.x - ptA.x);\n  }\n\n  /**\n   *\n   * @param {Segment} segA\n   * @param {Segment} segB\n   */\n  static sameAngle(segA, segB) {\n    let aA = GeomUtil.angleBetween(segA.a, segA.b);\n    let aB = GeomUtil.angleBetween(segB.a, segB.b);\n\n    return Math.abs(aA - aB) < EPSILON;\n  }\n\n  /**\n   *\n   * @param {Segment} segA\n   * @param {Segment} segB\n   */\n  static sameAngleRev(segA, segB) {\n    let aA = GeomUtil.angleBetween(segA.a, segA.b);\n    let aB = GeomUtil.angleBetween(segB.b, segB.a);\n\n    return Math.abs(aA - aB) < EPSILON;\n  }\n\n  /**\n   *\n   * @param {Point} ptA\n   * @param {Point} ptB\n   * @param {number} d\n   * @returns {Point}\n   */\n  static lerpPoints(ptA, ptB, d) {\n    return {\n      x: GeomUtil.lerp(ptA.x, ptB.x, d),\n      y: GeomUtil.lerp(ptA.y, ptB.y, d),\n    };\n  }\n\n  /**\n   *\n   * @param {Point} pt the point to rotate in place\n   * @param {number} deg angle in degrees\n   */\n  static rotatePointDeg(pt, deg) {\n    GeomUtil.rotatePoint(pt, (deg * Math.PI) / 180);\n  }\n\n  /**\n   *\n   * @param {Point} pt\n   * @param {*} rad\n   */\n  static rotatePoint(pt, rad) {\n    const cos = Math.cos(rad);\n    const sin = Math.sin(rad);\n\n    const oldY = pt.y;\n    const oldX = pt.x;\n\n    pt.y = cos * oldY - sin * oldX;\n    pt.x = sin * oldY + cos * oldX;\n  }\n\n  /**\n   *\n   * @param {number} rad\n   * @param  {...Point} points\n   */\n  static rotatePoints(rad, ...points) {\n    points.forEach((pt) => {\n      GeomUtil.rotatePoint(pt, rad);\n    });\n  }\n\n  /**\n   *\n   * @param {number} deg\n   * @param  {...Point} points\n   */\n  static rotatePointsDeg(deg, ...points) {\n    let rad = (deg * Math.PI) / 180;\n    points.forEach((pt) => {\n      GeomUtil.rotatePoint(pt, rad);\n    });\n  }\n\n  // Based on http://stackoverflow.com/a/12037737\n\n  static outerTangents(ptA, rA, ptB, rB) {\n    var dx = ptB.x - ptA.x;\n    var dy = ptB.y - ptA.y;\n    var dist = Math.sqrt(dx * dx + dy * dy);\n\n    if (dist <= Math.abs(rB - rA)) return []; // no valid tangents\n\n    // Rotation from x-axis\n    var angle1 = Math.atan2(dy, dx);\n    var angle2 = Math.acos((rA - rB) / dist);\n\n    return [\n      new Segment(\n        {\n          x: ptA.x + rA * Math.cos(angle1 + angle2),\n          y: ptA.y + rA * Math.sin(angle1 + angle2),\n        },\n        {\n          x: ptB.x + rB * Math.cos(angle1 + angle2),\n          y: ptB.y + rB * Math.sin(angle1 + angle2),\n        }\n      ),\n      new Segment(\n        {\n          x: ptA.x + rA * Math.cos(angle1 - angle2),\n          y: ptA.y + rA * Math.sin(angle1 - angle2),\n        },\n        {\n          x: ptB.x + rB * Math.cos(angle1 - angle2),\n          y: ptB.y + rB * Math.sin(angle1 - angle2),\n        }\n      ),\n    ];\n  }\n\n  /**\n   *\n   * @param {Point} pt\n   */\n  static cartesian2Polar(pt) {\n    const d = Math.sqrt(pt.x * pt.x + pt.y * pt.y);\n    const r = Math.atan2(pt.y, pt.x);\n    pt.x = d;\n    pt.y = r;\n  }\n\n  /**\n   *\n   * @param {Point} ptA\n   * @param {Point} ptB\n   * @param {number} [scale]\n   */\n  static pointsEqual(ptA, ptB, scale = 1) {\n    return (\n      Math.round(ptA.x * 10000 / scale) == Math.round(ptB.x * 10000 / scale) && Math.round(ptA.y * 10000 / scale) == Math.round(ptB.y * 10000 / scale)\n    );\n  }\n\n  /**\n   *\n   * @param {Point} ptA\n   * @param {Point} ptB\n   * @returns {number}\n   */\n  static distanceBetween(ptA, ptB) {\n    const dx = ptB.x - ptA.x;\n    const dy = ptB.y - ptA.y;\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n  /**\n   *\n   * @param {Point} ptA\n   * @param {Point} ptB\n   * @returns {number}\n   */\n  static distanceBetweenSquared(ptA, ptB) {\n    const dx = ptB.x - ptA.x;\n    const dy = ptB.y - ptA.y;\n    return dx * dx + dy * dy;\n  }\n\n  /**\n   *\n   * @param {Point} ptA\n   * @param {Point} ptB\n   * @param {number} numSegs\n   * @returns {Point[]}\n   */\n  static interpolatePoints(ptA, ptB, numSegs) {\n    let pts = [{ x: ptA.x, y: ptA.y }];\n    let perc = 1 / numSegs;\n    let deltaX = (ptB.x - ptA.x) * perc;\n    let deltaY = (ptB.y - ptA.y) * perc;\n    for (var i = 1; i < numSegs; i++) {\n      pts.push(new Point(ptA.x + deltaX * i, ptA.y + deltaY * i));\n    }\n    pts.push({ x: ptB.x, y: ptB.y });\n    return pts;\n  }\n\n  /**\n   *\n   * @param  {...Point} pts\n   */\n  static averagePoints(...pts) {\n    let a = new Point(0, 0);\n    pts.forEach((pt) => {\n      a.x += pt.x;\n      a.y += pt.y;\n    });\n    a.x /= pts.length;\n    a.y /= pts.length;\n    return a;\n  }\n\n  /**\n   *\n   * @param {Point} targetPt the point that will be added to\n   * @param {Point} sourcePt the point to add to the target\n   */\n  static addToPoint(targetPt, sourcePt) {\n    targetPt.x += sourcePt.x;\n    targetPt.y += sourcePt.y;\n  }\n\n  /**\n   *\n   * @param {Point} targetPt the point that will be subtracted from\n   * @param {Point} sourcePt the point tosubtract from the target\n   */\n  static subFromPoint(targetPt, sourcePt) {\n    targetPt.x -= sourcePt.x;\n    targetPt.y -= sourcePt.y;\n  }\n\n  /**\n   *\n   * @param {Point} ptA\n   * @param {Point} ptB\n   * @param {number} delta\n   * @returns {Point[]}\n   */\n  static subdivideByDistance(ptA, ptB, delta) {\n    if (delta === 0) {\n      return [ptA, ptB];\n    }\n    let pts = [{ x: ptA.x, y: ptA.y }];\n    let dist = GeomUtil.distanceBetween(ptA, ptB);\n    let perc = delta / dist;\n    let numFit = Math.floor(1 / perc);\n    let remain = dist % delta;\n    delta += remain / numFit;\n    perc = delta / dist;\n    let travel = perc;\n    let i = 1;\n    let deltaX = (ptB.x - ptA.x) * perc;\n    let deltaY = (ptB.y - ptA.y) * perc;\n    while (travel < 1) {\n      pts.push(new Point(ptA.x + deltaX * i, ptA.y + deltaY * i));\n      travel += perc;\n      i++;\n    }\n    pts.push({ x: ptB.x, y: ptB.y });\n    return pts;\n  }\n\n  /**\n   *\n   * @param {Segment} segA\n   * @param {Segment} segB\n   * @param {number} [scale]\n   */\n  static segmentsConnected(segA, segB, scale = 1) {\n    return GeomUtil.pointsEqual(segA.b, segB.a, scale) || GeomUtil.pointsEqual(segA.a, segB.b, scale);\n  }\n\n  /**\n   *\n   * @param {Segment[]} segs\n   * @returns {Point[]}\n   */\n  static segmentsToPoints(segs) {\n    let pts = segs.reduce((arr, seg) => {\n      return arr.concat(seg.a, seg.b);\n    }, []);\n    let i = pts.length;\n    while (i--) {\n      let pt = pts[i];\n      if (i > 0 && GeomUtil.pointsEqual(pt, pts[i - 1])) {\n        pts.splice(i, 1);\n      }\n    }\n    return pts;\n  }\n\n  /**\n   *\n   * @param {Point[]} pts\n   * @returns {number}\n   */\n  static polygonArea(pts) {\n    let area = 0;\n    let j = pts.length - 1;\n    for (var i = 0; i < pts.length; i++) {\n      area += pts[i].x * pts[j].y;\n      area -= pts[j].x * pts[i].y;\n      j = i;\n    }\n    return area / 2;\n  }\n\n  /**\n   *\n   * @param {Point[]} pts\n   * @returns {BoundingBox}\n   */\n  static pointsBoundingBox(pts) {\n    const b = new BoundingBox(1000000, 1000000, -1000000, -1000000);\n\n    pts.forEach((pt) => {\n      b.minX = Math.min(b.minX, pt.x);\n      b.minY = Math.min(b.minY, pt.y);\n      b.maxX = Math.max(b.maxX, pt.x);\n      b.maxY = Math.max(b.maxY, pt.y);\n    });\n\n    return b;\n  }\n\n  /**\n   *\n   * @param {BoundingBox[]} bbs\n   * @returns {BoundingBox}\n   */\n  static boundingBoxesBoundingBox(bbs) {\n    const b = new BoundingBox(1000000, 1000000, -1000000, -1000000);\n\n    bbs.forEach((bb) => {\n      b.minX = Math.min(b.minX, bb.minX);\n      b.minY = Math.min(b.minY, bb.minY);\n      b.maxX = Math.max(b.maxX, bb.maxX);\n      b.maxY = Math.max(b.maxY, bb.maxY);\n    });\n\n    return b;\n  }\n\n  /**\n   *\n   * @param {Segment[]} segs\n   * @returns {BoundingBox}\n   */\n  static segmentsBoundingBox(segs) {\n    const pts = [];\n    segs.forEach((seg) => {\n      pts.push(seg.a);\n      pts.push(seg.b);\n    });\n    return GeomUtil.pointsBoundingBox(pts);\n  }\n\n  /**\n   *\n   * @param {BoundingBox} ab\n   * @param {BoundingBox} bb\n   */\n  static boundingBoxesIntersect(ab, bb) {\n    return ab.maxX >= bb.minX && ab.maxY >= bb.minY && ab.minX <= bb.maxX && ab.minY <= bb.maxY;\n  }\n\n  /**\n   *\n   * @param {Point[]} pts\n   * @returns {boolean}\n   */\n  static polygonIsClockwise(pts) {\n    return GeomUtil.polygonArea(pts) > 0;\n  }\n\n  /**\n   *\n   * @param {Point} p1\n   * @param {Point} p2\n   * @param {Point} p3\n   */\n  static ccw(p1, p2, p3) {\n    return (p3.y - p1.y) * (p2.x - p1.x) > (p2.y - p1.y) * (p3.x - p1.x);\n  }\n\n  /**\n   *\n   * @param {Segment} segA\n   * @param {Segment} segB\n   * @returns {boolean}\n   */\n  static segmentsIntersect(segA, segB) {\n    const fn = GeomUtil.ccw;\n    return (\n      fn(segA.a, segB.a, segB.b) != fn(segA.b, segB.a, segB.b) &&\n      fn(segA.a, segA.b, segB.a) != fn(segA.a, segA.b, segB.b)\n    );\n  }\n\n  /**\n   *\n   * @param {Segment} segA\n   * @param {Segment} segB\n   * @returns {Point}\n   */\n  static segmentSegmentIntersect(segA, segB, ignoreTouching = false) {\n    const x1 = segA.a.x;\n    const y1 = segA.a.y;\n    const x2 = segA.b.x;\n    const y2 = segA.b.y;\n    const x3 = segB.a.x;\n    const y3 = segB.a.y;\n    const x4 = segB.b.x;\n    const y4 = segB.b.y;\n\n    const s1_x = x2 - x1;\n    const s1_y = y2 - y1;\n    const s2_x = x4 - x3;\n    const s2_y = y4 - y3;\n\n    const s = (-s1_y * (x1 - x3) + s1_x * (y1 - y3)) / (-s2_x * s1_y + s1_x * s2_y);\n    const t = (s2_x * (y1 - y3) - s2_y * (x1 - x3)) / (-s2_x * s1_y + s1_x * s2_y);\n\n    if (s >= 0 && s <= 1 && t >= 0 && t <= 1) {\n      const atX = x1 + t * s1_x;\n      const atY = y1 + t * s1_y;\n      let intPt = { x: atX, y: atY };\n      if (ignoreTouching) {\n        if (GeomUtil.pointsEqual(intPt, segB.a) || GeomUtil.pointsEqual(intPt, segB.b)) {\n          return;\n        }\n        if (GeomUtil.pointsEqual(intPt, segA.a) || GeomUtil.pointsEqual(intPt, segA.b)) {\n          return;\n        }\n      }\n      return intPt;\n    }\n\n    return null;\n  }\n\n  /**\n   *\n   * @param {Segment} segA\n   * @param {Segment[]} segs\n   * @returns {Point[]}\n   */\n  static segmentSegmentsIntersections(segA, segs, ignoreTouching = false) {\n    let pts = [];\n    segs.forEach((seg) => {\n      if (seg == segA) {\n        return;\n      }\n      let intPt = GeomUtil.segmentSegmentIntersect(segA, seg, ignoreTouching);\n      if (intPt) {\n        pts.push(intPt);\n      }\n    });\n    return pts;\n  }\n\n  /**\n   *\n   * @param {Point} ptA\n   * @param {Point} ptB\n   */\n  static dot(ptA, ptB) {\n    return ptA.x * ptB.x + ptA.y * ptB.y;\n  }\n\n  /**\n   *\n   * @param {Point} ptA\n   * @param {Point} ptB\n   */\n  static cross(ptA, ptB) {\n    return ptA.x * ptB.y - ptA.y * ptB.x;\n  }\n\n  /**\n   * \n   * @param {Point} pt \n   * @param {Point} ptA \n   * @param {Point} ptB \n   */\n  static lineSide (pt, ptA, ptB) {\n    return Math.round(((ptB.x - ptA.x) * (pt.y - ptA.y) - (ptB.y - ptA.y) * (pt.x - ptA.x)) * 100) / 100;\n  }\n\n  /**\n   *\n   * @param {Point} ptA\n   * @param {Point} ptB\n   */\n  static sub(ptA, ptB) {\n    return new Point(ptA.x - ptB.x, ptA.y - ptB.y);\n  }\n\n  /**\n   *\n   * @param {Point} ptA\n   * @param {Point} ptB\n   */\n  static add(ptA, ptB) {\n    return new Point(ptA.x + ptB.x, ptA.y + ptB.y);\n  }\n\n  /**\n   *\n   * @param {Point} pt\n   * @param {Segment} seg\n   * @returns {Point}\n   */\n  static closestPtPointSegment(pt, seg) {\n    var ab = GeomUtil.sub(seg.b, seg.a);\n    var ca = GeomUtil.sub(pt, seg.a);\n    var t = GeomUtil.dot(ca, ab);\n\n    if (t < 0) {\n      pt = seg.a;\n    } else {\n      var denom = GeomUtil.dot(ab, ab);\n      if (t >= denom) {\n        pt = seg.b;\n      } else {\n        t /= denom;\n        // reuse ca\n        ca.x = seg.a.x + t * ab.x;\n        ca.y = seg.a.y + t * ab.y;\n        pt = ca;\n      }\n    }\n\n    return Point.clone(pt);\n  }\n\n  /**\n   *\n   * @param {Point} pt\n   * @param {Segment} seg\n   */\n  static distancePointSegment(pt, seg) {\n    return GeomUtil.distanceBetween(pt, GeomUtil.closestPtPointSegment(pt, seg));\n  }\n\n  /**\n   *\n   * @param {*} pt\n   * @param {*} boundingBox\n   * @returns {boolean}\n   */\n  static pointWithinBoundingBox(pt, boundingBox) {\n    return pt.x >= boundingBox.minX && pt.y >= boundingBox.minY && pt.x <= boundingBox.maxX && pt.y <= boundingBox.maxY;\n  }\n\n  /**\n   *\n   * @param {Point} pt\n   * @param {Segment[]} polySegs\n   * @returns {boolean}\n   */\n  static pointWithinPolygon(pt, polySegs, ignoreTouching) {\n    const b = GeomUtil.segmentsBoundingBox(polySegs);\n    // early out\n    if (!this.pointWithinBoundingBox(pt, b)) {\n      return false;\n    }\n\n    let startPt = new Point(100000, 100000);\n    let seg = new Segment(startPt, pt);\n\n    let pts = GeomUtil.segmentSegmentsIntersections(seg, polySegs);\n\n    if (!(pts.length % 2 == 0)) {\n      if (ignoreTouching && GeomUtil.pointsEqual(pt, pts[0])) {\n        return false;\n      }\n    }\n    return !(pts.length % 2 == 0);\n  }\n\n  /**\n   *\n   * @param {Segment} seg\n   * @param {Segment[]} polySegs\n   * @returns {boolean}\n   */\n  static segmentWithinPolygon(seg, polySegs) {\n    let aTouching = this.pointWithinPolygon(seg.a, polySegs, false);\n    let bTouching = this.pointWithinPolygon(seg.b, polySegs, false);\n    let aWithin = this.pointWithinPolygon(seg.a, polySegs, true);\n    let bWithin = this.pointWithinPolygon(seg.b, polySegs, true);\n    return (aWithin && bWithin) || (aWithin && bTouching) || (bWithin && aTouching);\n  }\n\n  static sign(p1, p2, p3) {\n    return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);\n  }\n\n  /**\n   *\n   * @param {Point} pt\n   * @param {Point} v1\n   * @param {Point} v2\n   * @param {Point} v3\n   * @returns {boolean}\n   */\n  static pointWithinTriangle(pt, v1, v2, v3, ignoreTouching) {\n    const d1 = GeomUtil.sign(pt, v1, v2);\n    const d2 = GeomUtil.sign(pt, v2, v3);\n    const d3 = GeomUtil.sign(pt, v3, v1);\n\n    const has_neg = d1 < 0 || d2 < 0 || d3 < 0;\n    const has_pos = d1 > 0 || d2 > 0 || d3 > 0;\n\n    if (!(has_neg && has_pos) && ignoreTouching) {\n      let seg = { a: v1, b: v2, tags: null };\n      if (GeomUtil.distancePointSegment(pt, seg) < 1) return false;\n      seg.a = v2;\n      seg.b = v3;\n      if (GeomUtil.distancePointSegment(pt, seg) < 1) return false;\n      seg.a = v3;\n      seg.b = v1;\n      if (GeomUtil.distancePointSegment(pt, seg) < 1) return false;\n    }\n\n    return !(has_neg && has_pos);\n  }\n\n  /**\n   *\n   * @param {Segment} seg\n   * @param {Point} v1\n   * @param {Point} v2\n   * @param {Point} v3\n   * @returns {boolean}\n   */\n  static segmentWithinTriangle(seg, v1, v2, v3) {\n    let aTouching = this.pointWithinTriangle(seg.a, v1, v2, v3, false);\n    let bTouching = this.pointWithinTriangle(seg.b, v1, v2, v3, false);\n    let aWithin = this.pointWithinTriangle(seg.a, v1, v2, v3, true);\n    let bWithin = this.pointWithinTriangle(seg.b, v1, v2, v3, true);\n    let pt = GeomUtil.averagePoints(seg.a, seg.b);\n    return (aWithin && bWithin) || (aWithin && bTouching) || (bWithin && aTouching) || (aTouching && bTouching);\n  }\n\n  /**\n   *\n   * @param {Point[]} pts\n   * @returns {Segment[]}\n   */\n  static pointsToClosedPolySegments(...pts) {\n    let out = [];\n    for (let i = 0; i < pts.length; i++) {\n      out.push(new Segment(pts[i], i < pts.length - 1 ? pts[i + 1] : pts[0]));\n    }\n    return out;\n  }\n\n  /**\n   *\n   * @param {Segment[]} polySegsA\n   * @param {Segment[]} polySegsB\n   * @returns {boolean}\n   */\n  static polygonWithinPolygon(polySegsA, polySegsB) {\n    const ab = GeomUtil.segmentsBoundingBox(polySegsA);\n    const bb = GeomUtil.segmentsBoundingBox(polySegsB);\n\n    // early out\n    if (!GeomUtil.boundingBoxesIntersect(ab, bb)) {\n      return false;\n    }\n\n    const startPt = new Point(bb.minX - 100, bb.minY - 100);\n\n    for (let i = 0; i < polySegsA.length; i++) {\n      let seg = polySegsA[i];\n      let pts = GeomUtil.segmentSegmentsIntersections(seg, polySegsB);\n\n      if (pts.length % 2 == 0) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   *\n   * @param {Point} ptA\n   * @param {Point} ptB\n   * @param {Point} ptC\n   * @param {number} iterations\n   */\n  static splinePoints(ptA, ptB, ptC, iterations = 0) {\n    let divide = (pts) => {\n      let out = [pts[0]];\n      for (let i = 0; i < pts.length - 1; i++) {\n        let pt = new Point(0, 0);\n        if (i + 1 < pts.length * 0.4) {\n          pt.x = (pts[i].x * 40 + pts[i + 1].x * 60) * 0.01;\n          pt.y = (pts[i].y * 40 + pts[i + 1].y * 60) * 0.01;\n        } else if (i + 1 > pts.length * 0.6) {\n          pt.x = (pts[i].x * 60 + pts[i + 1].x * 40) * 0.01;\n          pt.y = (pts[i].y * 60 + pts[i + 1].y * 40) * 0.01;\n        } else {\n          pt.x = (pts[i].x + pts[i + 1].x) * 0.5;\n          pt.y = (pts[i].y + pts[i + 1].y) * 0.5;\n        }\n        out.push(pt);\n      }\n      out.push(pts[pts.length - 1]);\n      return out;\n    };\n\n    let spts = [ptA, ptB, ptC];\n\n    for (let i = 0; i < iterations; i++) {\n      spts = divide(spts);\n    }\n\n    return spts;\n  }\n}","import { Segment, Point, GeomUtil } from \"./geom/geom.js\";\nimport { PolygonShape } from \"./geom/shapes.js\";\n\nexport class Analyzer {\n\n  /**\n   * @property {Segment[]} segs\n   * @property {boolean} splitTeeIntersections\n   * @returns {{ originalPts: Object.<string, Point>, pts: string[], cxs: Object.<string,string[]> }}\n   */\n  static getSegsAndConnections(segs, splitTeeIntersections = false, splitCrossIntersections = false) {\n\n    /** @type {Object.<string,string[]>} */\n    let cxs = {};\n    /** @type {string[]} */\n    let pts = [];\n    /** @type {Object.<string, Point>} */\n    let originalPts = {};\n\n    let token = pt => {\n      let t = `${Math.round(pt.x * 1)}|${Math.round(pt.y * 1)}`;\n      originalPts[t] = pt;\n      return t;\n    }\n\n    if (splitTeeIntersections) {\n\n      // step 0, split segments that cross a point (T intersections);\n\n      let allPts = segs.reduce((arr, seg) => arr.concat(seg.a, seg.b), []);\n      let j = allPts.length;\n\n      while (j--) {\n        let ptA = allPts[j];\n        let i = j;\n        while (i--) {\n          let ptB = allPts[i];\n          if (GeomUtil.pointsEqual(ptA, ptB)) {\n            allPts.splice(j, 1);\n            break;\n          }\n        }\n      }\n\n      let i = segs.length;\n\n      while (i--) {\n\n        let seg = segs[i];\n\n        let crossPts = [];\n\n        allPts.forEach(pt => {\n          if (GeomUtil.distancePointSegment(pt, seg) < 0.1) {\n            if (!GeomUtil.pointsEqual(pt, seg.a) && !GeomUtil.pointsEqual(pt, seg.b)) {\n              crossPts.push(pt);\n            }\n          }\n        });\n\n        if (crossPts.length) {\n\n          crossPts.sort((ptA, ptB) => {\n            const da = GeomUtil.distanceBetweenSquared(ptA, seg.a);\n            const db = GeomUtil.distanceBetweenSquared(ptB, seg.a);\n            if (da < db) {\n              return -1;\n            } else if (da > db) {\n              return 1;\n            }\n            return 0;\n          });\n\n          const newSegs = [];\n\n          let ptA = seg.a;\n          for (let k = 0; k < crossPts.length; k++) {\n            let ptB = crossPts[k];\n            newSegs.push(new Segment(ptA, ptB));\n            ptA = ptB;\n          }\n          newSegs.push(new Segment(ptA, seg.b));\n\n          segs.splice(i, 1, ...newSegs);\n\n        }\n\n      }\n\n    }\n\n    if (splitCrossIntersections) {\n\n      let j = segs.length;\n      while (j--) {\n        let i = j;\n        let found = false\n        while (i--) {\n          let segA = segs[j];\n          let segB = segs[i];\n          let intPt = GeomUtil.segmentSegmentIntersect(segA, segB, true);\n          if (intPt) {\n            found = true;\n            segs.splice(j, 1, new Segment(Point.clone(segA.a), Point.clone(intPt)), new Segment(Point.clone(intPt), Point.clone(segA.b)));\n            segs.splice(i, 1, new Segment(Point.clone(segB.a), Point.clone(intPt)), new Segment(Point.clone(intPt), Point.clone(segB.b)));\n          }\n        }\n        if (found) {\n          j = segs.length;\n        }\n      }\n\n    }\n\n    // step 1, collect endpoints\n    // step 2, filter out dupes\n    // step 3, collect connected endpoints for each endpoint\n\n    segs.forEach(seg => {\n      let ta = token(seg.a);\n      let tb = token(seg.b);\n      if (!cxs[ta]) cxs[ta] = [];\n      if (!cxs[tb]) cxs[tb] = [];\n      if (cxs[ta].indexOf(tb) === -1) {\n        cxs[ta].push(tb);\n      }\n      if (cxs[tb].indexOf(ta) === -1) {\n        cxs[tb].push(ta);\n      }\n      if (pts.indexOf(ta) === -1) {\n        pts.push(ta);\n      }\n      if (pts.indexOf(tb) === -1) {\n        pts.push(tb);\n      }\n    });\n\n    return {\n      originalPts,\n      pts,\n      cxs\n    };\n\n  }\n\n  /**\n   * @property {Segment[]} segs\n   * @property {boolean} splitTeeIntersections\n   * @returns {Segment[]}\n   */\n  static pathOrder(segs, splitTeeIntersections = false, splitCrossIntersections = false) {\n\n    let res = [];\n    let { originalPts, pts, cxs } = Analyzer.getSegsAndConnections(segs, splitTeeIntersections, splitCrossIntersections);\n\n    let nekot = str => {\n      return originalPts[str];\n    };\n\n    let byNumConnections = (ta, tb) => {\n      if (cxs[ta].length > cxs[tb].length) {\n        return 1;\n      } else if (cxs[ta].length < cxs[tb].length) {\n        return -1;\n      }\n      return 0;\n    }\n\n    // step 1, sort by number of connections, desc\n    // step 2, choose first endpoint\n    // step 3, pick the connected one with the lowest index that isn't in the stack, remove from connections list, push onto stack\n    // step 4, resort by number of connections, desc\n    // step 5, repeat step 6 until no more connections\n\n    pts.sort(byNumConnections);\n\n    while (pts.length) {\n\n      pts.sort(byNumConnections);\n      let ptA = pts.shift();\n\n      while (ptA) {\n\n        if (cxs[ptA].length) {\n\n          cxs[ptA].sort(byNumConnections);\n          let ptB = cxs[ptA].shift();\n\n          let oppIdx = cxs[ptB].indexOf(ptA);\n          if (oppIdx !== -1) cxs[ptB].splice(oppIdx, 1);\n\n          res.push(new Segment(nekot(ptA), nekot(ptB)));\n\n          if (cxs[ptA].length) {\n            pts.unshift(ptA);\n          }\n\n          ptA = ptB;\n\n        } else {\n\n          ptA = null;\n\n        }\n\n      }\n\n    }\n\n    return res;\n\n  }\n\n  /**\n   * @property {Segment[]} segs\n   * @property {number} offset\n   * @returns {Point[]}\n   */\n  static getEndingSegmentPoints(segs, offset = 0) {\n\n    segs = segs.concat();\n    segs = Analyzer.pathOrder(segs, true, true);\n\n    let { originalPts, pts, cxs } = Analyzer.getSegsAndConnections(segs, true);\n\n    let nekot = str => {\n      return originalPts[str];\n    };\n\n    // return all points with one connection\n\n    const endTokens = pts.filter(ta => cxs[ta].length === 1);\n\n    const out = [];\n    endTokens.forEach(tb => {\n      const ptB = Point.clone(nekot(tb));\n      if (offset === 0) {\n        out.push(ptB);\n        return;\n      }\n      const ptA = nekot(cxs[tb]);\n      const ang = GeomUtil.angleBetween(ptA, ptB);\n      const pt = new Point(0, offset);\n      GeomUtil.rotatePoint(pt, Math.PI * 0.5 - ang);\n      GeomUtil.addToPoint(ptB, pt);\n      out.push(ptB);\n    });\n\n    return out;\n\n  }\n\n  /**\n   * @property {Segment[]} segs\n   * @property {number} searchMultiplier multiple of typical segmentation distance to search for flood-fill points\n   * @returns {Point[][]}\n   */\n  static getFills(segs, searchMultiplier = 5) {\n\n    segs = segs.concat();\n\n    let { originalPts, pts, cxs } = Analyzer.getSegsAndConnections(segs, true, true);\n\n    let token = pt => {\n      let t = `${Math.round(pt.x * 1)}|${Math.round(pt.y * 1)}`;\n      originalPts[t] = pt;\n      return t;\n    }\n\n    let cenTokens = [];\n    let pointGroups = [];\n\n    // 1. iterate through all points\n    // 2. for each point pick a each connection\n    // 3. for each pair, proceed to find a winding polygon\n\n    let minX = 100000;\n    let minY = 100000;\n    let maxX = -100000;\n    let maxY = -100000;\n    let minDx = 100000;\n    let minDy = 100000;\n\n    let ptArray = [];\n\n    // get extents\n\n    for (let token in originalPts) {\n      let pt = originalPts[token];\n      ptArray.push(pt);\n      minX = Math.min(minX, pt.x);\n      minY = Math.min(minY, pt.y);\n      maxX = Math.max(maxX, pt.x);\n      maxY = Math.max(maxY, pt.y);\n    }\n\n    // get minimum spacing\n\n    ptArray.sort((a, b) => {\n      if (a.x < b.x) {\n        return -1;\n      } else if (a.x > b.x) {\n        return 1;\n      }\n      return 0;\n    });\n\n    ptArray.forEach((ptA, idx) => {\n      if (idx > 0) {\n        let ptB = ptArray[idx - 1];\n        let dx = Math.round(Math.abs(ptA.x - ptB.x));\n        if (dx > 1) {\n          minDx = Math.min(minDx, dx);\n        }\n      }\n    });\n\n    ptArray.sort((a, b) => {\n      if (a.y < b.y) {\n        return -1;\n      } else if (a.y > b.y) {\n        return 1;\n      }\n      return 0;\n    });\n\n    ptArray.forEach((ptA, idx) => {\n      if (idx > 0) {\n        let ptB = ptArray[idx - 1];\n        let dy = Math.round(Math.abs(ptA.y - ptB.y));\n        if (dy > 1) {\n          minDy = Math.min(minDy, dy);\n        }\n      }\n    });\n\n    let hDx = minDx * 0.5;\n    let hDy = minDy * 0.5;\n\n    let rayPts = [];\n\n    for (let j = minY; j < maxY; j += minDy) {\n      for (let i = minX; i < maxX; i += minDx) {\n        rayPts.push(new Point(i + hDx, j + hDy));\n      }\n    }\n\n    rayPts.forEach(rayPt => {\n      let nearPts = [];\n      ptArray.forEach(pt => {\n        let dist = GeomUtil.distanceBetween(pt, rayPt);\n        if (dist < Math.max(minDx, minDy) * searchMultiplier) {\n          let ang = GeomUtil.angleBetween(pt, rayPt);\n          nearPts.push({\n            pt,\n            dist,\n            ang\n          });\n        }\n      });\n      if (nearPts.length < 4) {\n        return;\n      }\n      let i = nearPts.length;\n      while (i--) {\n        let nPt = nearPts[i].pt;\n        let seg = new Segment(rayPt, nPt);\n        let hits = GeomUtil.segmentSegmentsIntersections(seg, segs, true);\n        if (hits.length > 0) {\n          nearPts.splice(i, 1);\n        }\n      }\n      nearPts.sort((a, b) => {\n        if (a.ang < b.ang) {\n          return -1;\n        } else if (a.ang > b.ang) {\n          return 1;\n        }\n        return 0;\n      });\n      i = nearPts.length;\n      while (i--) {\n        let nPtA = nearPts[i].pt;\n        let tokenA = token(nPtA);\n        let j = nearPts.length;\n        let ok = false;\n        while (j--) {\n          if (i === j) {\n            continue;\n          }\n          let nPtB = nearPts[j].pt;\n          let tokenB = token(nPtB);\n          if (cxs[tokenA].indexOf(tokenB) === -1) {\n            ok = true;\n            break;\n          }\n        }\n        if (!ok) {\n          nearPts.splice(i, 1);\n        }\n      }\n      let ok = true;\n      nearPts.forEach((npA, idx) => {\n        let npB = nearPts[(idx + 1) % nearPts.length];\n        let tokenA = token(npA.pt);\n        let tokenB = token(npB.pt);\n        if (cxs[tokenA].indexOf(tokenB) === -1) {\n          ok = false;\n        }\n      });\n      if (ok) {\n        let polyPts = nearPts.map(nPt => nPt.pt);\n        let cen = GeomUtil.averagePoints(...polyPts);\n        let cenToken = token(cen);\n        if (cenTokens.indexOf(cenToken) === -1) {\n          cenTokens.push(cenToken);\n          pointGroups.push(polyPts);\n        }\n      }\n    });\n\n    return pointGroups;\n\n  }\n\n}\n\n","import { Segment, Segments, SegmentCollection, Point, GeomUtil } from \"./geom/geom.js\";\nimport { Analyzer } from \"./analyzer.js\";\n\nexport class Optimize {\n  /**\n   *\n   * @param {SegmentCollection[]} segCols\n   * @param {boolean} [noSplit]\n   * @param {boolean} [trimSmall]\n   * @param {number} [smallDist]\n   * @param {boolean} [optimizePathOrder]\n   * @param {boolean} [splitTeeIntersections]\n   * @returns {Segments}\n   */\n  static segmentCollections(segCols, noSplit = false, trimSmall = true, smallDist = 1, optimizePathOrder = false, splitTeeIntersections = false, splitCrossIntersections = false) {\n    let allsegs = segCols.reduce((arr, sc) => arr.concat(sc.toSegments()), []);\n    return Optimize.segments(allsegs, noSplit, trimSmall, smallDist, optimizePathOrder, splitTeeIntersections, splitCrossIntersections);\n  }\n  /**\n   *\n   * @param {SegmentCollection[]} segCols\n   * @param {boolean} [splitTeeIntersections]\n   * @returns {Segments}\n   */\n  static segmentCollectionsPathOrder(segCols, splitTeeIntersections = false, splitCrossIntersections = false) {\n    let allsegs = segCols.reduce((arr, sc) => arr.concat(sc.toSegments()), []);\n    return new Segments(Analyzer.pathOrder(allsegs, splitTeeIntersections, splitCrossIntersections));\n  }\n  /**\n   *\n   * @param {Segment[]} segs\n   * @param {boolean} [noSplitColinear]\n   * @param {boolean} [trimSmall]\n   * @param {number} [smallDist]\n   * @param {boolean} [optimizePathOrder]\n   * @param {boolean} [splitTeeIntersections]\n   * @returns {Segments}\n   */\n  static segments(segs, noSplitColinear = false, trimSmall = true, smallDist = 1, optimizePathOrder = false, splitTeeIntersections = false, splitCrossIntersections = false) {\n\n    segs = Optimize._segments(segs, noSplitColinear, trimSmall, smallDist);\n\n    if (optimizePathOrder) {\n      segs = Analyzer.pathOrder(segs, splitTeeIntersections, splitCrossIntersections);\n    }\n\n    return new Segments(segs);\n  }\n\n  /**\n   * JS fallback for segment optimization  \n   * @private\n   */\n  static _segments(segs, noSplitColinear, trimSmall, smallDist) {\n    const sb = segs;\n    segs = [];\n\n    // Dedupe\n    while (sb.length) {\n      let s = sb.shift();\n      let n = segs.length\n      let found = false;\n      while (n--) {\n        const sn = segs[n];\n        if (Segment.isEqual(s, sn)) {\n          found = true;\n          break;\n        }\n      }\n      if (!found) {\n        segs.push(s);\n      }\n    }\n\n    // Merge colinear\n    if (!noSplitColinear) {\n\n      for (let n = 0; n < 3; n++) {\n        let i = segs.length;\n        let overlaps = 0;\n\n        while (i--) {\n          let segA = segs[i];\n          let aa, ab, ba, bb, heading;\n          for (let j = i - 1; j >= 0; j--) {\n            let segB = segs[j];\n            let same = false;\n            let isRev = false;\n            if (GeomUtil.sameAngle(segA, segB)) {\n              same = true;\n              aa = Point.clone(segA.a);\n              ab = Point.clone(segA.b);\n              ba = Point.clone(segB.a);\n              bb = Point.clone(segB.b);\n            } else if (GeomUtil.sameAngleRev(segA, segB)) {\n              same = isRev = true;\n              aa = Point.clone(segA.b);\n              ab = Point.clone(segA.a);\n              ba = Point.clone(segB.a);\n              bb = Point.clone(segB.b);\n            }\n            if (same) {\n              heading = GeomUtil.angleBetween(aa, ab);\n              GeomUtil.rotatePoints(heading, aa, ab, ba, bb);\n              if (Math.abs(aa.y - ba.y) < 0.1 && ab.x >= ba.x - 0.0001 && aa.x <= bb.x + 0.0001) {\n                overlaps++;\n                if (aa.x < ba.x) {\n                  if (!isRev) {\n                    segB.a = segA.a;\n                  } else {\n                    segB.a = segA.b;\n                  }\n                }\n                if (ab.x > bb.x) {\n                  if (!isRev) {\n                    segB.b = segA.b;\n                  } else {\n                    segB.b = segA.a;\n                  }\n                }\n                segs.splice(i, 1);\n                break;\n              }\n            }\n          }\n        }\n      }\n\n    }\n\n    // Trim small\n    let i = segs.length;\n    while (i--) {\n      let seg = segs[i];\n      if (!seg) {\n        segs.splice(i, 1);\n        continue;\n      }\n      if (trimSmall && GeomUtil.distanceBetween(seg.a, seg.b) < smallDist) {\n        segs.splice(i, 1);\n        continue;\n      }\n    }\n\n    console.log(`[JS] Optimize: ${sb.length + segs.length} -> ${segs.length} segments`);\n    return segs;\n  }\n\n}\n","// @ts-check\n/**\n * Edge-Based Hidden Line Renderer\n * \n * A faster alternative to clipper-based boolean operations.\n * Uses per-edge occlusion testing.\n */\n\nimport { Optimize } from './optimize.js';\n\nimport {\n    Vector3,\n    Vector2,\n    Raycaster,\n    Camera,\n    Scene,\n    Mesh,\n    WebGLRenderTarget,\n    NearestFilter,\n    RGBAFormat,\n    UnsignedByteType,\n    MeshDepthMaterial,\n    RGBADepthPacking,\n    ShaderMaterial,\n    BufferAttribute,\n    BufferGeometry,\n    DoubleSide\n} from \"three\";\n\n/**\n * @typedef {Object} Edge3D\n * @property {Vector3} a - Start point (world space)\n * @property {Vector3} b - End point (world space)\n * @property {Vector3} normal1 - First face normal\n * @property {Vector3} [normal2] - Second face normal (if shared edge)\n * @property {number} faceIdx1 - First face index\n * @property {number} [faceIdx2] - Second face index\n * @property {Mesh} mesh - Parent mesh\n * @property {boolean} [isHatch] - Is this a hatch line?\n */\n\n/**\n * @typedef {Object} Edge2D\n * @property {Vector2} a - Start point (screen space)\n * @property {Vector2} b - End point (screen space)\n * @property {Vector3} a3d - Start point (world space)\n * @property {Vector3} b3d - End point (world space)\n * @property {Vector3} midpoint3d - Midpoint in world space\n * @property {boolean} isProfile - Is this a silhouette edge?\n * @property {boolean} visible - Is this edge visible?\n * @property {number} faceIdx - Parent face index\n * @property {number} [faceIdx2] - Second face index (if shared edge)\n * @property {Mesh} mesh - Parent mesh\n * @property {boolean} [isHatch] - Is this a hatch line?\n * @property {boolean} [isSilhouette] - Is this a silhouette edge (borders void)?\n * @property {Vector3} [normal1] - First face normal (propagated)\n * @property {Vector3} [normal2] - Second face normal (propagated)\n * @property {number} [adjacentFaceCount] - Number of adjacent faces (debug/filtering)\n * @property {number} [faceSimilarity] - Similarity of adjacent face normals (debug/filtering)\n * @property {boolean} [isTJunctionStraggler] - Is this edge a result of a T-junction split?\n */\n\n/**\n * @typedef {Object} Point2D\n * @property {number} x\n * @property {number} y\n */\n\n/**\n * @typedef {Object} ProjectedFace\n * @property {Vector2} a2d - Screen space vertex A\n * @property {Vector2} b2d - Screen space vertex B\n * @property {Vector2} c2d - Screen space vertex C\n * @property {number} depthA - Depth at vertex A\n * @property {number} depthB - Depth at vertex B\n * @property {number} depthC - Depth at vertex C\n * @property {Mesh} mesh - Source mesh\n * @property {number} faceIdx - Original face index\n * @property {Vector3} normal - Face normal (world space)\n * @property {number} constant - Plane constant d\n */\n\n/**\n * Extract edges from a mesh with face normal information\n * Only extracts edges from front-facing faces (skips back-facing)\n * @param {Mesh} mesh \n * @param {Vector3} cameraPosition - Camera position for face culling\n * @returns {Edge3D[]}\n */\nexport function extractEdges(mesh, cameraPosition) {\n    const geometry = mesh.geometry;\n    const position = geometry.attributes.position;\n    const index = geometry.index;\n\n    if (!position) return [];\n\n    /** @type {Map<string, Edge3D>} */\n    const edgeMap = new Map();\n\n    // Snap tolerance for position-based edge matching\n    const SNAP = 1000; // Precision: 3 decimal places\n\n    // Position-based edge key (not index-based, handles duplicate vertices)\n    /**\n     * \n     * @param {Vector3} va \n     * @param {Vector3} vb \n     * @returns \n     */\n    const getEdgeKey = (va, vb) => {\n        const ax = Math.round(va.x * SNAP);\n        const ay = Math.round(va.y * SNAP);\n        const az = Math.round(va.z * SNAP);\n        const bx = Math.round(vb.x * SNAP);\n        const by = Math.round(vb.y * SNAP);\n        const bz = Math.round(vb.z * SNAP);\n\n        const keyA = `${ax},${ay},${az}`;\n        const keyB = `${bx},${by},${bz}`;\n\n        // Consistent ordering for undirected edges\n        return keyA < keyB ? `${keyA}|${keyB}` : `${keyB}|${keyA}`;\n    };\n\n    /**\n     * \n     * @param {number} idx \n     * @returns \n     */\n    const getVertex = (idx) => {\n        const v = new Vector3(\n            position.getX(idx),\n            position.getY(idx),\n            position.getZ(idx)\n        );\n        return v.applyMatrix4(mesh.matrixWorld);\n    };\n\n    /**\n     * \n     * @param {Vector3} v0 \n     * @param {Vector3} v1 \n     * @param {Vector3} v2 \n     * @returns \n     */\n    const getFaceNormal = (v0, v1, v2) => {\n        const edge1 = new Vector3().subVectors(v1, v0);\n        const edge2 = new Vector3().subVectors(v2, v0);\n        return new Vector3().crossVectors(edge1, edge2).normalize();\n    };\n\n    const numFaces = index ? index.count / 3 : position.count / 3;\n\n    for (let f = 0; f < numFaces; f++) {\n        let i0, i1, i2;\n\n        if (index) {\n            i0 = index.getX(f * 3);\n            i1 = index.getX(f * 3 + 1);\n            i2 = index.getX(f * 3 + 2);\n        } else {\n            i0 = f * 3;\n            i1 = f * 3 + 1;\n            i2 = f * 3 + 2;\n        }\n\n        const v0 = getVertex(i0);\n        const v1 = getVertex(i1);\n        const v2 = getVertex(i2);\n        const normal = getFaceNormal(v0, v1, v2);\n\n        // Skip back-facing faces - only extract edges from front-facing faces\n        const faceMid = new Vector3().addVectors(v0, v1).add(v2).divideScalar(3);\n        const viewDir = new Vector3().subVectors(cameraPosition, faceMid);\n        if (normal.dot(viewDir) <= 0) {\n            continue; // Skip back-facing face\n        }\n\n        // Process three edges of the triangle\n        const edges = [\n            [v0, v1],\n            [v1, v2],\n            [v2, v0]\n        ];\n\n        for (const [va, vb] of edges) {\n            const key = getEdgeKey(va, vb);\n\n            if (edgeMap.has(key)) {\n                // Edge already exists - add second face normal\n                const existing = edgeMap.get(key);\n                if (existing && !existing.normal2) {\n                    existing.normal2 = normal.clone();\n                    existing.faceIdx2 = f;\n                }\n            } else {\n                edgeMap.set(key, {\n                    a: va.clone(),\n                    b: vb.clone(),\n                    normal1: normal.clone(),\n                    faceIdx1: f,\n                    mesh\n                });\n            }\n        }\n    }\n\n    return Array.from(edgeMap.values());\n}\n\n/**\n * Filter edges: remove those where both faces are back-facing\n * @param {Edge3D[]} edges \n * @param {Vector3} cameraPosition \n * @returns {Edge3D[]}\n */\nexport function filterBackfacing(edges, cameraPosition) {\n    return edges.filter(edge => {\n        const edgeMidpoint = new Vector3().addVectors(edge.a, edge.b).multiplyScalar(0.5);\n        const viewDir = new Vector3().subVectors(cameraPosition, edgeMidpoint).normalize();\n\n        const facing1 = edge.normal1.dot(viewDir) > 0;\n\n        // Boundary edges (only one face) are always kept - they're silhouettes\n        if (!edge.normal2) {\n            return true;\n        }\n\n        const facing2 = edge.normal2.dot(viewDir) > 0;\n\n        // Keep edge if at least one face is front-facing\n        return facing1 || facing2;\n    });\n}\n\n/**\n * Detect profile (silhouette) edges and mark smooth edges for removal\n * @param {Edge3D[]} edges \n * @param {Vector3} cameraPosition \n * @param {number} smoothThreshold - Dot product threshold for similar normals (default 0.99)\n * @returns {{profiles: Edge3D[], smoothFiltered: Edge3D[]}}\n */\nexport function classifyEdges(edges, cameraPosition, smoothThreshold = 0.99) {\n    const profiles = [];\n    const smoothFiltered = [];\n\n    // Debug counters\n    let boundaryCount = 0;\n    let profileCount = 0;\n    let smoothCount = 0;\n    let discardedCount = 0;\n\n    for (const edge of edges) {\n        const edgeMidpoint = new Vector3().addVectors(edge.a, edge.b).multiplyScalar(0.5);\n        const viewDir = new Vector3().subVectors(cameraPosition, edgeMidpoint).normalize();\n\n        const facing1 = edge.normal1.dot(viewDir) > 0;\n        const facing2 = edge.normal2 ? edge.normal2.dot(viewDir) > 0 : true; // Boundary edges count as profile\n\n        // Profile edge: one face front, one face back (or boundary)\n        if (facing1 !== facing2 || !edge.normal2) {\n            profiles.push(edge);\n            continue;\n        }\n\n        // Check if normals are similar (smooth shading edge)\n        if (edge.normal2) {\n            const similarity = edge.normal1.dot(edge.normal2);\n            // Keep edge only if normals are different enough (crease/hard edge)\n            // Filter out smooth edges where normals are nearly parallel\n            if (similarity < smoothThreshold) {\n                smoothFiltered.push(edge);\n            }\n            // Edges with similar normals (similarity >= threshold) are discarded as smooth surface edges\n        }\n    }\n\n    console.log(`classifyEdges: ${profiles.length} profiles, ${smoothFiltered.length} smooth/crease edges`);\n\n    return { profiles, smoothFiltered };\n}\n\n/**\n * Project 3D edges to screen space\n * @param {Edge3D[]} edges \n * @param {Camera} camera \n * @param {number} width \n * @param {number} height \n * @param {number} scale - Internal scale factor for precision (default 1)\n * @returns {Edge2D[]}\n */\nexport function projectEdges(edges, camera, width, height, scale = 1) {\n    const halfWidth = width / 2;\n    const halfHeight = height / 2;\n\n    /**\n     * \n     * @param {Vector3} p3d \n     * @returns \n     */\n    const projectPoint = (p3d) => {\n        const projected = p3d.clone().project(camera);\n        return new Vector2(\n            projected.x * halfWidth * scale,\n            -projected.y * halfHeight * scale\n        );\n    };\n\n    return edges.map(edge => ({\n        a: projectPoint(edge.a),\n        b: projectPoint(edge.b),\n        a3d: edge.a.clone(),\n        b3d: edge.b.clone(),\n        midpoint3d: new Vector3().addVectors(edge.a, edge.b).multiplyScalar(0.5),\n        isProfile: false, // Will be set by classifyEdges\n        visible: true,\n        faceIdx: edge.faceIdx1,\n        faceIdx2: edge.faceIdx2,\n        mesh: edge.mesh,\n        isHatch: edge.isHatch,\n        normal1: edge.normal1,  // Propagate normals for straggler detection\n        normal2: edge.normal2\n    }));\n}\n\n/**\n * Spatial hash for efficient edge queries\n */\nexport class SpatialHash {\n    /**\n     * @param {number} cellSize \n     */\n    constructor(cellSize) {\n        this.cellSize = cellSize;\n        /** @type {Map<string, Edge2D[]>} */\n        this.cells = new Map();\n    }\n\n    /**\n     * Get cell key for a point\n     * @param {number} x \n     * @param {number} y \n     * @returns {string}\n     */\n    getCellKey(x, y) {\n        const cx = Math.floor(x / this.cellSize);\n        const cy = Math.floor(y / this.cellSize);\n        return `${cx},${cy}`;\n    }\n\n    /**\n     * Get all cells an edge crosses\n     * @param {Edge2D} edge \n     * @returns {string[]}\n     */\n    getCellsCrossed(edge) {\n        const cells = new Set();\n\n        // Use line rasterization to find all cells\n        const dx = Math.abs(edge.b.x - edge.a.x);\n        const dy = Math.abs(edge.b.y - edge.a.y);\n        const steps = Math.max(dx, dy) / this.cellSize + 1;\n\n        for (let i = 0; i <= steps; i++) {\n            const t = i / steps;\n            const x = edge.a.x + t * (edge.b.x - edge.a.x);\n            const y = edge.a.y + t * (edge.b.y - edge.a.y);\n            cells.add(this.getCellKey(x, y));\n        }\n\n        return Array.from(cells);\n    }\n\n    /**\n     * Insert an edge into the spatial hash\n     * @param {Edge2D} edge \n     */\n    insert(edge) {\n        const cells = this.getCellsCrossed(edge);\n        for (const key of cells) {\n            if (!this.cells.has(key)) {\n                this.cells.set(key, []);\n            }\n            this.cells.get(key)?.push(edge);\n        }\n    }\n\n    /**\n     * Get all edges in a cell\n     * @param {string} key \n     * @returns {Edge2D[]}\n     */\n    query(key) {\n        return this.cells.get(key) || [];\n    }\n\n    /**\n     * Get all cell keys\n     * @returns {string[]}\n     */\n    getAllCells() {\n        return Array.from(this.cells.keys());\n    }\n\n    clear() {\n        this.cells.clear();\n    }\n}\n\n/**\n * Find intersection point of two 2D line segments\n * @param {Edge2D} e1 \n * @param {Edge2D} e2 \n * @returns {{t1: number, t2: number, point: Vector2} | null}\n */\nexport function findIntersection(e1, e2) {\n    const x1 = e1.a.x, y1 = e1.a.y;\n    const x2 = e1.b.x, y2 = e1.b.y;\n    const x3 = e2.a.x, y3 = e2.a.y;\n    const x4 = e2.b.x, y4 = e2.b.y;\n\n    const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n    if (Math.abs(denom) < 1e-10) return null; // Parallel\n\n    const t1 = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;\n    const t2 = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;\n\n    const eps = 0.001;\n    // Check if intersection is within both segments (excluding endpoints)\n    if (t1 > eps && t1 < 1 - eps && t2 > eps && t2 < 1 - eps) {\n        return {\n            t1,\n            t2,\n            point: new Vector2(\n                x1 + t1 * (x2 - x1),\n                y1 + t1 * (y2 - y1)\n            )\n        };\n    }\n\n    return null;\n}\n\n/**\n * Split edges at intersection points within a cell\n * @param {Edge2D[]} edges \n * @returns {Edge2D[]}\n */\nexport function splitAtIntersections(edges) {\n    /** @type {Map<Edge2D, {t: number, point: Vector2}[]>} */\n    const splits = new Map();\n\n    const eps = 0.01;\n\n    // Helper: check if point p lies on edge interior (not endpoints)\n    // Returns t parameter (0,1) if on edge, null otherwise\n    /**\n     * \n     * @param {Vector2} p \n     * @param {Edge2D} edge \n     * @returns \n     */\n    const pointOnEdgeInterior = (p, edge) => {\n        const dx = edge.b.x - edge.a.x;\n        const dy = edge.b.y - edge.a.y;\n        const lenSq = dx * dx + dy * dy;\n        if (lenSq < 1e-10) return null; // Degenerate edge\n\n        // Project p onto edge line\n        const t = ((p.x - edge.a.x) * dx + (p.y - edge.a.y) * dy) / lenSq;\n\n        // Check if t is in interior (not at endpoints)\n        if (t <= eps || t >= 1 - eps) return null;\n\n        // Check distance from point to projected point on line\n        const projX = edge.a.x + t * dx;\n        const projY = edge.a.y + t * dy;\n        const distSq = (p.x - projX) * (p.x - projX) + (p.y - projY) * (p.y - projY);\n\n        // Tolerance for \"on the edge\"\n        if (distSq < 1.0) { // 1 pixel tolerance\n            return t;\n        }\n        return null;\n    };\n\n    // Track edges that might be stragglers (their endpoint caused a T-junction)\n    const potentialStragglers = new Set();\n\n    // Find all intersections (crossing + T-junctions)\n    for (let i = 0; i < edges.length; i++) {\n        for (let j = i + 1; j < edges.length; j++) {\n            // Check for crossing intersection\n            const intersection = findIntersection(edges[i], edges[j]);\n            if (intersection) {\n                // Record split points for both edges\n                if (!splits.has(edges[i])) splits.set(edges[i], []);\n                if (!splits.has(edges[j])) splits.set(edges[j], []);\n\n                splits.get(edges[i])?.push({ t: intersection.t1, point: intersection.point });\n                splits.get(edges[j])?.push({ t: intersection.t2, point: intersection.point });\n            } else {\n                // Check for T-junctions: endpoint of one edge on interior of other\n                // Mark BOTH edges as potential stragglers\n\n                // Edge i's endpoints on edge j\n                const tAonJ = pointOnEdgeInterior(edges[i].a, edges[j]);\n                if (tAonJ !== null) {\n                    if (!splits.has(edges[j])) splits.set(edges[j], []);\n                    splits.get(edges[j])?.push({ t: tAonJ, point: edges[i].a.clone() });\n                    potentialStragglers.add(edges[i]);\n                    potentialStragglers.add(edges[j]);  // Mark BOTH\n                }\n\n                const tBonJ = pointOnEdgeInterior(edges[i].b, edges[j]);\n                if (tBonJ !== null) {\n                    if (!splits.has(edges[j])) splits.set(edges[j], []);\n                    splits.get(edges[j])?.push({ t: tBonJ, point: edges[i].b.clone() });\n                    potentialStragglers.add(edges[i]);\n                    potentialStragglers.add(edges[j]);  // Mark BOTH\n                }\n\n                // Edge j's endpoints on edge i\n                const tAonI = pointOnEdgeInterior(edges[j].a, edges[i]);\n                if (tAonI !== null) {\n                    if (!splits.has(edges[i])) splits.set(edges[i], []);\n                    splits.get(edges[i])?.push({ t: tAonI, point: edges[j].a.clone() });\n                    potentialStragglers.add(edges[i]);  // Mark BOTH\n                    potentialStragglers.add(edges[j]);\n                }\n\n                const tBonI = pointOnEdgeInterior(edges[j].b, edges[i]);\n                if (tBonI !== null) {\n                    if (!splits.has(edges[i])) splits.set(edges[i], []);\n                    splits.get(edges[i])?.push({ t: tBonI, point: edges[j].b.clone() });\n                    potentialStragglers.add(edges[i]);  // Mark BOTH\n                    potentialStragglers.add(edges[j]);\n                }\n            }\n        }\n    }\n\n    console.log(`T-junction detection: ${potentialStragglers.size} potential straggler edges`);\n\n    // Split edges at recorded points\n    const result = [];\n\n    for (const edge of edges) {\n        const edgeSplits = splits.get(edge);\n        const isStraggler = potentialStragglers.has(edge);\n\n        if (!edgeSplits || edgeSplits.length === 0) {\n            // Mark the edge as potential straggler if it was identified\n            edge.isTJunctionStraggler = isStraggler;\n            result.push(edge);\n            continue;\n        }\n\n        // Sort splits by t value\n        edgeSplits.sort((a, b) => a.t - b.t);\n\n        // Create sub-edges\n        let prevT = 0;\n        let prevPoint = edge.a;\n        let prevPoint3d = edge.a3d;\n\n        for (const split of edgeSplits) {\n            const point3d = new Vector3().lerpVectors(edge.a3d, edge.b3d, split.t);\n\n            result.push({\n                a: prevPoint.clone(),\n                b: split.point.clone(),\n                a3d: prevPoint3d.clone(),\n                b3d: point3d.clone(),\n                midpoint3d: new Vector3().addVectors(prevPoint3d, point3d).multiplyScalar(0.5),\n                isProfile: edge.isProfile,\n                visible: edge.visible,\n                faceIdx: edge.faceIdx,\n                mesh: edge.mesh,\n                isHatch: edge.isHatch,\n                normal1: edge.normal1,  // Propagate normal for smooth filter\n                isTJunctionStraggler: isStraggler\n            });\n\n            prevT = split.t;\n            prevPoint = split.point;\n            prevPoint3d = point3d;\n        }\n\n        // Final segment\n        result.push({\n            a: prevPoint.clone(),\n            b: edge.b.clone(),\n            a3d: prevPoint3d.clone(),\n            b3d: edge.b3d.clone(),\n            midpoint3d: new Vector3().addVectors(prevPoint3d, edge.b3d).multiplyScalar(0.5),\n            isProfile: edge.isProfile,\n            visible: edge.visible,\n            faceIdx: edge.faceIdx,\n            mesh: edge.mesh,\n            isHatch: edge.isHatch,\n            normal1: edge.normal1,  // Propagate normal for smooth filter\n            isTJunctionStraggler: isStraggler\n        });\n    }\n\n    return result;\n}\n\n/**\n * Test edge visibility using GPU depth buffer (fast O(1) per edge)\n * Uses a render target with depth material to read depth as RGBA\n * @param {Edge2D[]} edges \n * @param {Scene} scene \n * @param {Camera} camera \n * @param {number} epsilon - Depth tolerance (normalized 0-1)\n * @param {number} width - Viewport width\n * @param {number} height - Viewport height\n * @param {any} renderer - THREE.WebGLRenderer instance\n * @returns {Edge2D[]}\n */\nexport function testOcclusionDepthBuffer(edges, scene, camera, epsilon, width, height, renderer) {\n    const visibleEdges = [];\n\n    if (!renderer) {\n        console.warn('No renderer provided, skipping occlusion test');\n        return edges;\n    }\n\n    // Create render target for depth\n    const renderTarget = new WebGLRenderTarget(width, height, {\n        minFilter: NearestFilter,\n        magFilter: NearestFilter,\n        format: RGBAFormat,\n        type: UnsignedByteType\n    });\n\n    // Create depth material that encodes depth as color\n    const depthMaterial = new MeshDepthMaterial({\n        depthPacking: RGBADepthPacking\n    });\n\n    // Store original material overrides\n    const originalOverrideMaterial = scene.overrideMaterial;\n\n    // Render scene with depth material\n    scene.overrideMaterial = depthMaterial;\n    renderer.setRenderTarget(renderTarget);\n    renderer.render(scene, camera);\n\n    // Read the render target as RGBA\n    const depthData = new Uint8Array(width * height * 4);\n    renderer.readRenderTargetPixels(renderTarget, 0, 0, width, height, depthData);\n\n    // Restore scene\n    scene.overrideMaterial = originalOverrideMaterial;\n    renderer.setRenderTarget(null);\n\n    // Check if we got valid data\n    let hasData = false;\n    for (let i = 0; i < Math.min(4000, depthData.length); i += 4) {\n        if (depthData[i] !== 0 || depthData[i + 1] !== 0 || depthData[i + 2] !== 0) {\n            hasData = true;\n            break;\n        }\n    }\n\n    // Debug: sample center of depth buffer\n    const centerIdx = Math.floor(height / 2) * width * 4 + Math.floor(width / 2) * 4;\n    console.log(`Depth buffer center pixel (RGBA): ${depthData[centerIdx]}, ${depthData[centerIdx + 1]}, ${depthData[centerIdx + 2]}, ${depthData[centerIdx + 3]}`);\n\n    if (!hasData) {\n        console.warn('Could not read depth buffer, falling back to all-visible');\n        renderTarget.dispose();\n        depthMaterial.dispose();\n        return edges;\n    }\n\n    // Decode depth from RGBA using three.js formula\n    // See: https://github.com/mrdoob/three.js/blob/master/src/renderers/shaders/ShaderChunk/packing.glsl.js\n    // UnpackDownscale = 255/256\n    // UnpackFactors4 = (UnpackDownscale/1, UnpackDownscale/256, UnpackDownscale/65536, 1/16777216)\n    const UnpackDownscale = 255.0 / 256.0;\n    const PackFactors = [1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0];\n    const UnpackFactors4 = [\n        UnpackDownscale / PackFactors[0],  // 0.99609375\n        UnpackDownscale / PackFactors[1],  // 0.00389099...\n        UnpackDownscale / PackFactors[2],  // 0.0000152...\n        1.0 / PackFactors[3]               // 0.0000000059...\n    ];\n\n    /**\n     * \n     * @param {number} r \n     * @param {number} g \n     * @param {number} b \n     * @param {number} a \n     * @returns \n     */\n    const unpackDepth = (r, g, b, a) => {\n        // Normalize from 0-255 to 0-1\n        const rn = r / 255.0;\n        const gn = g / 255.0;\n        const bn = b / 255.0;\n        const an = a / 255.0;\n        // dot product with UnpackFactors4\n        return rn * UnpackFactors4[0] + gn * UnpackFactors4[1] + bn * UnpackFactors4[2] + an * UnpackFactors4[3];\n    };\n\n    // @ts-ignore\n    const near = camera.near;\n    // @ts-ignore  \n    const far = camera.far;\n\n    // Debug: log first few depth comparisons\n    let debugCount = 0;\n\n    for (const edge of edges) {\n        // Get screen-space coordinates of edge midpoint\n        const midX = (edge.a.x + edge.b.x) / 2;\n        const midY = (edge.a.y + edge.b.y) / 2;\n\n        const sx = Math.round(midX + width / 2);\n        const sy = Math.round(height / 2 + midY); // projectEdges already negates Y\n\n        // Check bounds\n        if (sx < 0 || sx >= width || sy < 0 || sy >= height) {\n            edge.visible = true;\n            visibleEdges.push(edge);\n            continue;\n        }\n\n        // Sample depth buffer (note: readRenderTargetPixels returns bottom-up)\n        const depthIdx = ((height - 1 - sy) * width + sx) * 4;\n        const sampledDepth = unpackDepth(\n            depthData[depthIdx],\n            depthData[depthIdx + 1],\n            depthData[depthIdx + 2],\n            depthData[depthIdx + 3]\n        );\n\n        // Compute expected depth using view-space Z (linear depth)\n        // MeshDepthMaterial stores: (viewZ - near) / (far - near) where viewZ is distance along camera's look direction\n        // For perspective cameras, we need to transform the midpoint to view space\n        const midpoint3d = edge.midpoint3d;\n\n        // Transform to view space (camera-relative coordinates)\n        const viewMatrix = camera.matrixWorldInverse;\n        const viewPos = midpoint3d.clone().applyMatrix4(viewMatrix);\n\n        // viewPos.z is negative in front of camera, so we negate it\n        const viewZ = -viewPos.z;\n\n        // Convert to 0-1 range matching MeshDepthMaterial\n        const expectedDepth = (viewZ - near) / (far - near);\n\n        // Debug logging\n        if (debugCount < 10) {\n            console.log(`Edge ${debugCount}: sample=${sampledDepth.toFixed(4)}, expected=${expectedDepth.toFixed(4)}, diff=${(sampledDepth - expectedDepth).toFixed(6)}`);\n            debugCount++;\n        }\n\n        // Compare: edge is visible if sampled depth >= expected depth (within tolerance)\n        // sampledDepth is depth of closest surface at this pixel\n        // expectedDepth is depth of the edge\n        // Edge is visible if it's at or in front of (closer than) the sampled surface\n        const isVisible = Math.abs(sampledDepth - expectedDepth) < epsilon || sampledDepth >= expectedDepth - epsilon;\n\n        if (isVisible) {\n            edge.visible = true;\n            visibleEdges.push(edge);\n        }\n    }\n\n    // Cleanup\n    renderTarget.dispose();\n    depthMaterial.dispose();\n\n    return visibleEdges;\n}\n\n/**\n * Test edge visibility using face ID buffer (correct occlusion)\n * Renders each face with a unique color = face index\n * Samples at edge midpoint to check if parent face is visible\n * @param {Edge2D[]} edges \n * @param {Mesh[]} meshes - All meshes in scene\n * @param {Camera} camera \n * @param {number} width - Viewport width\n * @param {number} height - Viewport height\n * @param {any} renderer - THREE.WebGLRenderer instance\n * @param {boolean} isProfile - If true, these are profile edges (always visible)\n * @returns {Edge2D[]}\n */\nexport function testOcclusionFaceID(edges, meshes, camera, width, height, renderer, isProfile = false) {\n    // Profile edges are ALWAYS visible (silhouette edges)\n    if (isProfile) {\n        edges.forEach(e => e.visible = true);\n        return edges;\n    }\n\n    const visibleEdges = [];\n\n    if (!renderer) {\n        console.warn('No renderer provided, skipping occlusion test');\n        return edges;\n    }\n\n    // Create render target for face IDs\n    const renderTarget = new WebGLRenderTarget(width, height, {\n        minFilter: NearestFilter,\n        magFilter: NearestFilter,\n        format: RGBAFormat,\n        type: UnsignedByteType\n    });\n\n    // Create face ID shader material\n    const faceIdMaterial = new ShaderMaterial({\n        vertexShader: `\n            attribute vec3 faceColor;\n            varying vec3 vFaceColor;\n            void main() {\n                vFaceColor = faceColor;\n                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n            }\n        `,\n        fragmentShader: `\n            varying vec3 vFaceColor;\n            void main() {\n                gl_FragColor = vec4(vFaceColor, 1.0);\n            }\n        `,\n        side: DoubleSide\n    });\n\n    // Build meshes with face ID colors\n    const faceIdMeshes = [];\n    let globalFaceOffset = 0;\n\n    for (const mesh of meshes) {\n        // @ts-ignore - Attach offset for later lookup\n        mesh.__globalFaceOffset = globalFaceOffset;\n        const geom = mesh.geometry;\n        const position = geom.attributes.position;\n        const index = geom.index;\n\n        const numFaces = index ? index.count / 3 : position.count / 3;\n\n        // Create new geometry with face colors - APPLY WORLD TRANSFORM\n        const newPositions = [];\n        const faceColors = [];\n\n        for (let f = 0; f < numFaces; f++) {\n            let i0, i1, i2;\n            if (index) {\n                i0 = index.getX(f * 3);\n                i1 = index.getX(f * 3 + 1);\n                i2 = index.getX(f * 3 + 2);\n            } else {\n                i0 = f * 3;\n                i1 = f * 3 + 1;\n                i2 = f * 3 + 2;\n            }\n\n            // Get vertices and APPLY WORLD TRANSFORM\n            const v0 = new Vector3(position.getX(i0), position.getY(i0), position.getZ(i0));\n            const v1 = new Vector3(position.getX(i1), position.getY(i1), position.getZ(i1));\n            const v2 = new Vector3(position.getX(i2), position.getY(i2), position.getZ(i2));\n\n            v0.applyMatrix4(mesh.matrixWorld);\n            v1.applyMatrix4(mesh.matrixWorld);\n            v2.applyMatrix4(mesh.matrixWorld);\n\n            // Add world-space positions\n            newPositions.push(v0.x, v0.y, v0.z, v1.x, v1.y, v1.z, v2.x, v2.y, v2.z);\n\n            // Encode face ID as RGB (globalFaceOffset + f + 1, reserve 0 for background)\n            const globalFaceId = globalFaceOffset + f + 1;\n            const r = (globalFaceId & 0xFF) / 255;\n            const g = ((globalFaceId >> 8) & 0xFF) / 255;\n            const b = ((globalFaceId >> 16) & 0xFF) / 255;\n\n            // Same color for all 3 vertices of this face\n            faceColors.push(r, g, b, r, g, b, r, g, b);\n        }\n\n        // Create geometry with world-space positions\n        const newGeom = new BufferGeometry();\n        newGeom.setAttribute('position', new BufferAttribute(new Float32Array(newPositions), 3));\n        newGeom.setAttribute('faceColor', new BufferAttribute(new Float32Array(faceColors), 3));\n\n        // Create mesh - no need for matrix since positions are already in world space\n        const faceIdMesh = new Mesh(newGeom, faceIdMaterial);\n        faceIdMeshes.push(faceIdMesh);\n\n        globalFaceOffset += numFaces;\n    }\n\n    // Create temporary scene with ALL face ID meshes\n    const tempScene = new Scene();\n    for (const faceIdMesh of faceIdMeshes) {\n        tempScene.add(faceIdMesh);\n    }\n\n    // Render ALL meshes TOGETHER in one pass\n    renderer.setRenderTarget(renderTarget);\n    renderer.setClearColor(0x000000, 1);\n    renderer.clear();\n    renderer.render(tempScene, camera);\n\n    // Read the render target\n    const faceIdData = new Uint8Array(width * height * 4);\n    renderer.readRenderTargetPixels(renderTarget, 0, 0, width, height, faceIdData);\n\n    // Restore renderer\n    renderer.setRenderTarget(null);\n\n    // Process edges\n    for (const edge of edges) {\n        const midX = (edge.a.x + edge.b.x) / 2;\n        const midY = (edge.a.y + edge.b.y) / 2;\n\n        const sx = Math.round(midX + width / 2);\n        const sy = Math.round(height / 2 + midY);\n\n        if (sx < 0 || sx >= width || sy < 0 || sy >= height) {\n            edge.visible = true;\n            visibleEdges.push(edge);\n            continue;\n        }\n\n        const idx = ((height - 1 - sy) * width + sx) * 4;\n        const r = faceIdData[idx];\n        const g = faceIdData[idx + 1];\n        const b = faceIdData[idx + 2];\n\n        const sampledFaceId = r + (g << 8) + (b << 16);\n\n        // If 0 (background), edge is visible\n        if (sampledFaceId === 0) {\n            edge.visible = true;\n            visibleEdges.push(edge);\n            continue;\n        }\n\n        // Edge parent face ID is faceIdx + 1 (we offset by 1 to reserve 0 for background)\n        // Add the mesh's global offset to its local face index.\n        // @ts-ignore - __globalFaceOffset is attached during mesh processing\n        const parentMeshOffset = edge.mesh.__globalFaceOffset || 0;\n        const parentFaceId = parentMeshOffset + edge.faceIdx + 1;\n\n        // Edge is visible if sampled face matches parent face\n        if (sampledFaceId === parentFaceId) {\n            edge.visible = true;\n            visibleEdges.push(edge);\n        } else {\n            // Also check the second face if it's a shared edge\n            if (edge.faceIdx2 !== undefined) {\n                const parentFaceId2 = parentMeshOffset + edge.faceIdx2 + 1;\n                if (sampledFaceId === parentFaceId2) {\n                    edge.visible = true;\n                    visibleEdges.push(edge);\n                    continue;\n                }\n            }\n            edge.visible = false;\n        }\n    }\n\n    // Cleanup\n    renderTarget.dispose();\n    faceIdMaterial.dispose();\n    for (const m of faceIdMeshes) {\n        m.geometry.dispose();\n    }\n\n    return visibleEdges;\n}\n\n/**\n * Pure mathematical point-in-triangle test (2D)\n * @param {Vector2} p - Point to test\n * @param {Vector2} a - Triangle vertex A\n * @param {Vector2} b - Triangle vertex B\n * @param {Vector2} c - Triangle vertex C\n * @returns {boolean}\n */\nfunction pointInTriangle2D(p, a, b, c) {\n    /**\n     * \n     * @param {Vector2} p1 \n     * @param {Vector2} p2 \n     * @param {Vector2} p3 \n     * @returns \n     */\n    const sign = (p1, p2, p3) =>\n        (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);\n\n    const d1 = sign(p, a, b);\n    const d2 = sign(p, b, c);\n    const d3 = sign(p, c, a);\n\n    const hasNeg = (d1 < 0) || (d2 < 0) || (d3 < 0);\n    const hasPos = (d1 > 0) || (d2 > 0) || (d3 > 0);\n\n    return !(hasNeg && hasPos);\n}\n\n/**\n * Check if edge lies along a face edge (collinear and within)\n * @param {Vector2} edgeA - Edge start point\n * @param {Vector2} edgeB - Edge end point\n * @param {Vector2} faceEdgeA - Face edge start point\n * @param {Vector2} faceEdgeB - Face edge end point\n * @param {number} tolerance - Distance tolerance in pixels\n * @returns {boolean}\n */\nfunction edgeLiesAlongFaceEdge(edgeA, edgeB, faceEdgeA, faceEdgeB, tolerance = 2.0) {\n    // Get face edge direction and length\n    const dx = faceEdgeB.x - faceEdgeA.x;\n    const dy = faceEdgeB.y - faceEdgeA.y;\n    const lenSq = dx * dx + dy * dy;\n    if (lenSq < 1e-10) return false;  // Degenerate face edge\n\n    // Project edge endpoints onto face edge line\n    /** @param {{x:number, y:number}} p - Point with x,y */\n    const projectAndCheck = (p) => {\n        // Project p onto line defined by faceEdgeA->faceEdgeB\n        const t = ((p.x - faceEdgeA.x) * dx + (p.y - faceEdgeA.y) * dy) / lenSq;\n\n        // Projected point\n        const projX = faceEdgeA.x + t * dx;\n        const projY = faceEdgeA.y + t * dy;\n\n        // Distance from p to projected point\n        const distSq = (p.x - projX) * (p.x - projX) + (p.y - projY) * (p.y - projY);\n\n        // Check if close to line and within segment (with small margin)\n        return distSq < tolerance * tolerance && t >= -0.01 && t <= 1.01;\n    };\n\n    // Both edge endpoints must lie along the face edge\n    return projectAndCheck(edgeA) && projectAndCheck(edgeB);\n}\n\n/**\n * Find all faces adjacent to an edge geometrically\n * @param {Edge2D} edge - Edge with a, b (2D points)\n * @param {ProjectedFace[]} projectedFaces - Array of projected faces\n * @returns {{ face: ProjectedFace, matchedEdge: string, matchType: string}[]} - Array of matching faces with match type\n */\nexport function findAdjacentFaces(edge, projectedFaces) {\n    const results = [];\n\n    for (const face of projectedFaces) {\n        // Get the three edges of the face\n        const faceEdges = [\n            { a: face.a2d, b: face.b2d, name: 'AB' },\n            { a: face.b2d, b: face.c2d, name: 'BC' },\n            { a: face.c2d, b: face.a2d, name: 'CA' }\n        ];\n\n        for (const fe of faceEdges) {\n            if (edgeLiesAlongFaceEdge(edge.a, edge.b, fe.a, fe.b)) {\n                results.push({\n                    face,\n                    matchedEdge: fe.name,\n                    matchType: 'collinear'\n                });\n                break;  // Found a match for this face, move to next\n            }\n        }\n    }\n\n    return results;\n}\n\n/**\n * Compute depth at point inside triangle using barycentric interpolation\n * @param {Vector2} p - Point to compute depth at\n * @param {Vector2} a - Triangle vertex A (2D)\n * @param {Vector2} b - Triangle vertex B (2D)\n * @param {Vector2} c - Triangle vertex C (2D)\n * @param {number} depthA - Depth at vertex A\n * @param {number} depthB - Depth at vertex B\n * @param {number} depthC - Depth at vertex C\n * @returns {number} - Interpolated depth at p\n */\nfunction barycentricDepth(p, a, b, c, depthA, depthB, depthC) {\n    // Compute barycentric coordinates\n    const v0 = { x: c.x - a.x, y: c.y - a.y };\n    const v1 = { x: b.x - a.x, y: b.y - a.y };\n    const v2 = { x: p.x - a.x, y: p.y - a.y };\n\n    const dot00 = v0.x * v0.x + v0.y * v0.y;\n    const dot01 = v0.x * v1.x + v0.y * v1.y;\n    const dot02 = v0.x * v2.x + v0.y * v2.y;\n    const dot11 = v1.x * v1.x + v1.y * v1.y;\n    const dot12 = v1.x * v2.x + v1.y * v2.y;\n\n    const denom = dot00 * dot11 - dot01 * dot01;\n    if (Math.abs(denom) < 1e-10) return Infinity;\n\n    const u = (dot11 * dot02 - dot01 * dot12) / denom;\n    const v = (dot00 * dot12 - dot01 * dot02) / denom;\n    const w = 1 - u - v;\n\n    return w * depthA + v * depthB + u * depthC;\n}\n\n/**\n * Post-split smooth filter: removes T-junction straggler edges that lie on a coplanar face\n * This catches \"straggler\" edges from T-junctions that extend into smooth surfaces\n * @param {Edge2D[]} edges - Split edges to filter\n * @param {ProjectedFace[]} projectedFaces - Projected faces with normals\n * @param {number} coplanarThreshold - Normal dot product threshold (default 0.99)\n * @param {number} distanceThreshold - Plane distance threshold (default 0.5)\n * @returns {Edge2D[]}\n */\nexport function filterSmoothSplitEdges(edges, projectedFaces, coplanarThreshold = 0.99, distanceThreshold = 0.5) {\n    const filteredEdges = [];\n    let removedCount = 0;\n\n    for (const edge of edges) {\n        // Find all adjacent faces geometrically\n        const adjacentFaces = findAdjacentFaces(edge, projectedFaces);\n\n        // Store adjacent face count for debugging\n        edge.adjacentFaceCount = adjacentFaces.length;\n\n        let shouldRemove = false;\n\n        // Only remove if we have exactly 2 faces with matching normals AND matching plane constants\n        if (adjacentFaces.length === 2) {\n            const f1 = adjacentFaces[0].face;\n            const f2 = adjacentFaces[1].face;\n            const fn1 = f1.normal;\n            const fn2 = f2.normal;\n\n            if (fn1 && fn2) {\n                const dot = fn1.dot(fn2);\n                const similarity = Math.abs(dot);\n                edge.faceSimilarity = similarity;\n\n                // Check distance between planes (must be very close to be truly coplanar)\n                // If normals are parallel (dot > 0), d1 ~ d2 => diff ~ 0\n                // If normals are anti-parallel (dot < 0), d1 ~ -d2 => sum ~ 0\n                let distDiff;\n                if (dot > 0) {\n                    distDiff = Math.abs(f1.constant - f2.constant);\n                } else {\n                    distDiff = Math.abs(f1.constant + f2.constant);\n                }\n\n                if (similarity >= coplanarThreshold && distDiff < distanceThreshold) {\n                    // Edge lies between exactly 2 coplanar faces - remove it\n                    shouldRemove = true;\n                    removedCount++;\n                }\n            }\n        } else if (adjacentFaces.length > 2) {\n            // 3+ faces: check if ALL normals match AND ALL planes match\n            const faces = adjacentFaces.map(af => af.face).filter(f => f.normal);\n            if (faces.length >= 2) {\n                let allCoplanar = true;\n                let minSimilarity = 1;\n\n                for (let i = 1; i < faces.length; i++) {\n                    const dot = faces[0].normal.dot(faces[i].normal);\n                    const sim = Math.abs(dot);\n\n                    let distDiff;\n                    if (dot > 0) {\n                        distDiff = Math.abs(faces[0].constant - faces[i].constant);\n                    } else {\n                        distDiff = Math.abs(faces[0].constant + faces[i].constant);\n                    }\n\n                    minSimilarity = Math.min(minSimilarity, sim);\n\n                    if (sim < coplanarThreshold || distDiff >= distanceThreshold) {\n                        allCoplanar = false;\n                        break;\n                    }\n                }\n                edge.faceSimilarity = minSimilarity;\n\n                if (allCoplanar) {\n                    shouldRemove = true;\n                    removedCount++;\n                }\n            }\n        }\n\n        if (!shouldRemove) {\n            filteredEdges.push(edge);\n        }\n    }\n\n    console.log(`Geometric straggler filter: removed ${removedCount} coplanar edges`);\n    return filteredEdges;\n}\n/**\n * Test edge visibility using pure math (point-in-triangle + depth)\n * No GPU, no raycasting - fully mathematical\n * @param {Edge2D[]} edges \n * @param {ProjectedFace[]} projectedFaces - Array of {a2d, b2d, c2d, depthA, depthB, depthC, mesh, faceIdx}\n * @param {Camera} camera\n * @returns {Edge2D[]}\n */\nexport function testOcclusionMath(edges, projectedFaces, camera) {\n    const cameraPos = camera.position;\n    const viewMatrix = camera.matrixWorldInverse;\n\n    // JS fallback\n    return testOcclusionMathJS(edges, projectedFaces, cameraPos, viewMatrix);\n}\n\n/**\n * JS fallback for occlusion testing\n * @param {Edge2D[]} edges \n * @param {ProjectedFace[]} projectedFaces \n * @param {Vector3} cameraPos \n * @param {import('three').Matrix4} [viewMatrix] - Optional view matrix for proper depth calculation\n * @returns {Edge2D[]}\n */\nfunction testOcclusionMathJS(edges, projectedFaces, cameraPos, viewMatrix) {\n    const visibleEdges = [];\n    let debugHitCount = 0;\n    let debugOccludedCount = 0;\n\n    for (const edge of edges) {\n        // Get midpoint in 2D and 3D\n        const mid2d = new Vector2(\n            (edge.a.x + edge.b.x) / 2,\n            (edge.a.y + edge.b.y) / 2\n        );\n\n        // Compute edge midpoint depth using view-space Z-coordinate\n        // This correctly handles perspective distortion (not Euclidean distance)\n        const mid3d = edge.midpoint3d;\n        let edgeDepth;\n        if (viewMatrix) {\n            // Use view-space Z for proper perspective handling\n            edgeDepth = -mid3d.clone().applyMatrix4(viewMatrix).z;\n        } else {\n            // Fallback to Euclidean distance if no view matrix\n            edgeDepth = cameraPos.distanceTo(mid3d);\n        }\n\n        let occluded = false;\n\n        // Check against ALL faces\n        for (const face of projectedFaces) {\n            // Skip if this is the edge's parent face\n            if (face.mesh === edge.mesh &&\n                (face.faceIdx === edge.faceIdx || face.faceIdx === edge.faceIdx2)) {\n                continue;\n            }\n\n            // Point-in-triangle test in 2D\n            if (!pointInTriangle2D(mid2d, face.a2d, face.b2d, face.c2d)) {\n                continue;\n            }\n\n            // Compute depth of the face at this 2D point\n            const faceDepthAtPoint = barycentricDepth(\n                mid2d, face.a2d, face.b2d, face.c2d,\n                face.depthA, face.depthB, face.depthC\n            );\n\n            // If face is closer  edge is occluded\n            if (faceDepthAtPoint < edgeDepth - 0.001) {\n                occluded = true;\n                debugOccludedCount++;\n                break;\n            }\n            debugHitCount++;\n        }\n\n        if (!occluded) {\n            edge.visible = true;\n            visibleEdges.push(edge);\n        } else {\n            edge.visible = false;\n        }\n    }\n\n    console.log(`[JS] Occlusion debug: ${debugHitCount} point-in-triangle hits, ${debugOccludedCount} occluded`);\n    return visibleEdges;\n}\n\n/**\n * Test edge visibility using raycasting (slow fallback)\n * @param {Edge2D[]} edges \n * @param {Scene} scene \n * @param {Camera} camera \n * @param {number} epsilon - Distance tolerance (as fraction of distance)\n * @returns {Edge2D[]}\n */\nexport function testOcclusion(edges, scene, camera, epsilon = 0.05) {\n    const raycaster = new Raycaster();\n    const visibleEdges = [];\n\n    // Collect all meshes in the scene for intersection testing\n    /** @type {any[]} */\n    const meshes = [];\n    scene.traverse((obj) => {\n        // @ts-ignore - isMesh exists on Mesh objects\n        if (obj.isMesh) {\n            meshes.push(obj);\n        }\n    });\n\n    for (const edge of edges) {\n        // Get direction from camera to midpoint\n        const toMidpoint = new Vector3().subVectors(edge.midpoint3d, camera.position);\n        const direction = toMidpoint.clone().normalize();\n        const expectedDist = toMidpoint.length();\n\n        // Use relative epsilon based on distance\n        const relEps = expectedDist * epsilon;\n\n        // Raycast from camera towards the edge midpoint\n        raycaster.set(camera.position.clone(), direction);\n\n        const intersects = raycaster.intersectObjects(meshes, true);\n\n        if (intersects.length === 0) {\n            // No hit - edge is visible\n            edge.visible = true;\n            visibleEdges.push(edge);\n        } else {\n            // Check if any hit is significantly in front of the edge\n            let occluded = false;\n\n            for (const hit of intersects) {\n                // Skip hits at or beyond the edge's depth\n                if (hit.distance >= expectedDist - relEps) {\n                    continue;\n                }\n\n                // For same-mesh hits, check if it's the edge's own face\n                if (hit.object === edge.mesh) {\n                    // Skip if this is the same face the edge belongs to\n                    if (hit.faceIndex === edge.faceIdx) {\n                        continue;\n                    }\n                }\n\n                // Something is in front of the edge - it's occluded\n                occluded = true;\n                break;\n            }\n\n            if (!occluded) {\n                edge.visible = true;\n                visibleEdges.push(edge);\n            } else {\n                edge.visible = false;\n            }\n        }\n    }\n\n    return visibleEdges;\n}\n\n/**\n * Remove duplicate segments and merge colinear ones\n * @param {Edge2D[]} edges \n * @param {number} tolerance \n * @returns {Edge2D[]}\n */\nexport function optimizeEdges(edges, tolerance = 0.5) {\n    // Deduplicate using hash\n    /** @type {Map<string, Edge2D>} */\n    const unique = new Map();\n\n    /** @param {Point2D} p */\n    const hashPoint = (p) => `${Math.round(p.x / tolerance)},${Math.round(p.y / tolerance)}`;\n    /** @param {Edge2D} e */\n    const hashEdge = (e) => {\n        const h1 = hashPoint(e.a);\n        const h2 = hashPoint(e.b);\n        return h1 < h2 ? `${h1}-${h2}` : `${h2}-${h1}`;\n    };\n\n    for (const edge of edges) {\n        const key = hashEdge(edge);\n        if (!unique.has(key)) {\n            unique.set(key, edge);\n        }\n    }\n\n    // TODO: Merge colinear segments\n\n    return Array.from(unique.values());\n}\n\n/**\n * Cleanup orphaned edges by extending to find intersections\n * An orphaned endpoint is a vertex with only 1 connected edge\n * Strategy: extend orphan edges and find line-line intersections\n * @param {Edge2D[]} edges - Edges to clean up\n * @param {number} tolerance - Distance tolerance for vertex matching\n * @param {number} maxExtension - Maximum distance to extend an edge\n * @returns {Edge2D[]}\n */\nexport function cleanupOrphanedEdges(edges, tolerance = 1.0, maxExtension = 50) {\n    // Build vertex -> edge connectivity map\n\n    const vertexKey = (/** @type {Point2D} */ p) => `${Math.round(p.x / tolerance)},${Math.round(p.y / tolerance)}`;\n\n    // Map of vertex hash -> { edges: [{edge, endpoint: 'a'|'b'}], point: Point2D }\n    const vertices = new Map();\n\n    for (const edge of edges) {\n        for (const endpoint of /** @type {const} */ (['a', 'b'])) {\n            /** @type {Point2D} */\n            const p = endpoint === 'a' ? edge.a : edge.b;\n            const key = vertexKey(p);\n            if (!vertices.has(key)) {\n                vertices.set(key, { edges: [], point: { x: p.x, y: p.y } });\n            }\n            vertices.get(key).edges.push({ edge, endpoint });\n        }\n    }\n\n    // Find orphaned endpoints (vertices with only 1 edge)\n    const orphans = [];\n    for (const [key, vertex] of vertices) {\n        if (vertex.edges.length === 1) {\n            const { edge, endpoint } = vertex.edges[0];\n            const orphanPoint = vertex.point;\n            const otherPoint = endpoint === 'a' ? edge.b : edge.a;\n\n            // Compute direction (from fixed end toward orphan end)\n            const dx = orphanPoint.x - otherPoint.x;\n            const dy = orphanPoint.y - otherPoint.y;\n            const len = Math.sqrt(dx * dx + dy * dy);\n            if (len < 0.001) continue;\n\n            orphans.push({\n                key,\n                edge,\n                endpoint,\n                point: orphanPoint,\n                otherPoint,\n                dirX: dx / len,\n                dirY: dy / len,\n                len\n            });\n        }\n    }\n\n    console.log(`Edge cleanup: found ${orphans.length} orphaned endpoints`);\n    if (orphans.length === 0) return edges;\n\n    // Line-line intersection helper\n    // Returns t values for intersection point on both lines, or null if parallel\n    /**\n     * \n     * @param {Point2D} p1 \n     * @param {Point2D} d1 \n     * @param {Point2D} p2 \n     * @param {Point2D} d2 \n     * @returns {{t1: number, t2: number}|null}\n     */\n    const lineIntersection = (p1, d1, p2, d2) => {\n        const cross = d1.x * d2.y - d1.y * d2.x;\n        if (Math.abs(cross) < 0.0001) return null; // Parallel\n\n        const dx = p2.x - p1.x;\n        const dy = p2.y - p1.y;\n\n        const t1 = (dx * d2.y - dy * d2.x) / cross;\n        const t2 = (dx * d1.y - dy * d1.x) / cross;\n\n        return { t1, t2 };\n    };\n\n    let extensionsCount = 0;\n    const processed = new Set();\n\n    for (let i = 0; i < orphans.length; i++) {\n        const orphan = orphans[i];\n        if (processed.has(orphan.key)) continue;\n\n        let bestMatch = null;\n        /** @type {Point2D | null} */\n        let bestIntersection = null;\n        let bestDist = Infinity;\n\n        for (let j = 0; j < orphans.length; j++) {\n            if (i === j) continue;\n            const candidate = orphans[j];\n            if (processed.has(candidate.key)) continue;\n\n            // Check if candidate's orphan point is reasonably close\n            const dist = Math.sqrt(\n                (candidate.point.x - orphan.point.x) ** 2 +\n                (candidate.point.y - orphan.point.y) ** 2\n            );\n            if (dist > maxExtension * 2) continue;\n\n            // Extend both lines and find intersection\n            // orphan: starts at orphan.point, direction orphan.dirX/dirY\n            // candidate: starts at candidate.point, direction candidate.dirX/dirY\n            const result = lineIntersection(\n                { x: orphan.point.x, y: orphan.point.y },\n                { x: orphan.dirX, y: orphan.dirY },\n                { x: candidate.point.x, y: candidate.point.y },\n                { x: candidate.dirX, y: candidate.dirY }\n            );\n\n            if (!result) continue; // Parallel lines\n\n            // t1 > 0 means intersection is in forward direction from orphan\n            // t2 > 0 means intersection is in forward direction from candidate\n            // Both must be positive (extending, not backtracking)\n            if (result.t1 < -0.1 || result.t2 < -0.1) continue;\n            if (result.t1 > maxExtension || result.t2 > maxExtension) continue;\n\n            // Compute intersection point\n            const ix = orphan.point.x + result.t1 * orphan.dirX;\n            const iy = orphan.point.y + result.t1 * orphan.dirY;\n\n            // Prefer closer intersections\n            const intersectDist = result.t1 + result.t2;\n            if (intersectDist < bestDist) {\n                bestDist = intersectDist;\n                bestMatch = candidate;\n                bestIntersection = { x: ix, y: iy };\n            }\n        }\n\n        if (bestMatch && bestIntersection) {\n            // Check if extension would cross any other edges\n            // Check segment from orphan.point to intersection\n            const crosses1 = segmentCrossesEdges(\n                orphan.point,\n                bestIntersection,\n                edges,\n                orphan.edge,\n                bestMatch.edge\n            );\n            // Check segment from bestMatch.point to intersection\n            const crosses2 = segmentCrossesEdges(\n                bestMatch.point,\n                bestIntersection,\n                edges,\n                orphan.edge,\n                bestMatch.edge\n            );\n\n            if (crosses1 || crosses2) {\n                // Skip this extension - it would cross existing edges\n                continue;\n            }\n\n            // Extend both edges to meet at intersection point\n            if (orphan.endpoint === 'a') {\n                orphan.edge.a.x = bestIntersection.x;\n                orphan.edge.a.y = bestIntersection.y;\n            } else {\n                orphan.edge.b.x = bestIntersection.x;\n                orphan.edge.b.y = bestIntersection.y;\n            }\n\n            if (bestMatch.endpoint === 'a') {\n                bestMatch.edge.a.x = bestIntersection.x;\n                bestMatch.edge.a.y = bestIntersection.y;\n            } else {\n                bestMatch.edge.b.x = bestIntersection.x;\n                bestMatch.edge.b.y = bestIntersection.y;\n            }\n\n            processed.add(orphan.key);\n            processed.add(bestMatch.key);\n            extensionsCount++;\n        }\n    }\n\n    console.log(`Edge cleanup: extended ${extensionsCount} pairs of edges to intersections`);\n\n    // Calculate average edge length for threshold\n    let totalLength = 0;\n    for (const edge of edges) {\n        const dx = edge.b.x - edge.a.x;\n        const dy = edge.b.y - edge.a.y;\n        totalLength += Math.sqrt(dx * dx + dy * dy);\n    }\n    const avgEdgeLength = totalLength / edges.length;\n    const snapThreshold = avgEdgeLength / 8;\n\n    console.log(`Edge cleanup: average edge length = ${avgEdgeLength.toFixed(2)}, snap threshold = ${snapThreshold.toFixed(2)}`);\n\n    // Rebuild orphan list after extensions\n    const finalVertices = new Map();\n    for (const edge of edges) {\n        for (const endpoint of /** @type {const} */ (['a', 'b'])) {\n            /** @type {Point2D} */\n            const p = endpoint === 'a' ? edge.a : edge.b;\n            const key = vertexKey(p);\n            if (!finalVertices.has(key)) {\n                finalVertices.set(key, { edges: [], point: p });\n            }\n            finalVertices.get(key).edges.push({ edge, endpoint });\n        }\n    }\n\n    // Find remaining orphans\n    const finalOrphans = [];\n    for (const [key, vertex] of finalVertices) {\n        if (vertex.edges.length === 1) {\n            finalOrphans.push({ key, ...vertex.edges[0], point: vertex.point });\n        }\n    }\n\n    console.log(`Edge cleanup: ${finalOrphans.length} orphaned endpoints before snap pass`);\n\n    // Snap nearby orphans together\n    let snapCount = 0;\n    const snapped = new Set();\n\n    for (let i = 0; i < finalOrphans.length; i++) {\n        const orphan = finalOrphans[i];\n        if (snapped.has(orphan.key)) continue;\n\n        let nearestOrphan = null;\n        let nearestDist = Infinity;\n\n        for (let j = 0; j < finalOrphans.length; j++) {\n            if (i === j) continue;\n            const candidate = finalOrphans[j];\n            if (snapped.has(candidate.key)) continue;\n\n            const dist = Math.sqrt(\n                (candidate.point.x - orphan.point.x) ** 2 +\n                (candidate.point.y - orphan.point.y) ** 2\n            );\n\n            if (dist < nearestDist) {\n                nearestDist = dist;\n                nearestOrphan = candidate;\n            }\n        }\n\n        if (nearestOrphan && nearestDist < snapThreshold) {\n            // Snap both to the midpoint\n            const midX = (orphan.point.x + nearestOrphan.point.x) / 2;\n            const midY = (orphan.point.y + nearestOrphan.point.y) / 2;\n\n            if (orphan.endpoint === 'a') {\n                orphan.edge.a.x = midX;\n                orphan.edge.a.y = midY;\n            } else {\n                orphan.edge.b.x = midX;\n                orphan.edge.b.y = midY;\n            }\n\n            if (nearestOrphan.endpoint === 'a') {\n                nearestOrphan.edge.a.x = midX;\n                nearestOrphan.edge.a.y = midY;\n            } else {\n                nearestOrphan.edge.b.x = midX;\n                nearestOrphan.edge.b.y = midY;\n            }\n\n            snapped.add(orphan.key);\n            snapped.add(nearestOrphan.key);\n            snapCount++;\n        }\n    }\n\n    console.log(`Edge cleanup: snapped ${snapCount} pairs of nearby orphans`);\n\n    // Final count\n    const remainingOrphans = finalOrphans.length - (snapCount * 2);\n    console.log(`Edge cleanup: ${remainingOrphans} orphaned endpoints remaining`);\n\n    return edges;\n}\n\n/**\n * Remove isolated edges where BOTH endpoints are orphaned (no connections to other edges)\n * These are floating edge fragments that don't connect to anything\n * @param {Edge2D[]} edges - Edges to filter\n * @param {number} tolerance - Distance tolerance for vertex matching\n * @returns {Edge2D[]} Filtered edges\n */\nexport function removeIsolatedEdges(edges, tolerance = 1.0) {\n\n    const vertexKey = (/** @type {Vector2} */ p) => `${Math.round(p.x / tolerance)},${Math.round(p.y / tolerance)}`;\n\n    // Count connections per vertex\n    const vertexConnections = new Map();\n\n    for (const edge of edges) {\n        const keyA = vertexKey(edge.a);\n        const keyB = vertexKey(edge.b);\n\n        vertexConnections.set(keyA, (vertexConnections.get(keyA) || 0) + 1);\n        vertexConnections.set(keyB, (vertexConnections.get(keyB) || 0) + 1);\n    }\n\n    // Filter out edges where both endpoints have only 1 connection (orphaned at both ends)\n    const filtered = edges.filter(edge => {\n        const keyA = vertexKey(edge.a);\n        const keyB = vertexKey(edge.b);\n        const connectionsA = vertexConnections.get(keyA) || 0;\n        const connectionsB = vertexConnections.get(keyB) || 0;\n\n        // Keep edge if at least one endpoint has 2+ connections\n        return connectionsA >= 2 || connectionsB >= 2;\n    });\n\n    const removed = edges.length - filtered.length;\n    if (removed > 0) {\n        console.log(`Edge cleanup: removed ${removed} isolated edges (orphaned at both ends)`);\n    }\n\n    return filtered;\n}\n\n/**\n * Check if a segment from p1 to p2 crosses any existing edge\n * @param {Point2D} p1 - Start point\n * @param {Point2D} p2 - End point\n * @param {Edge2D[]} edges - Existing edges to check against\n * @param {Edge2D} excludeEdge1 - Edge to exclude from check\n * @param {Edge2D} excludeEdge2 - Edge to exclude from check\n * @returns {boolean} True if segment crosses an edge\n */\nfunction segmentCrossesEdges(p1, p2, edges, excludeEdge1, excludeEdge2) {\n    const eps = 0.001;\n\n    for (const edge of edges) {\n        if (edge === excludeEdge1 || edge === excludeEdge2) continue;\n\n        // Check if segment p1->p2 intersects edge.a->edge.b\n        const d1x = p2.x - p1.x;\n        const d1y = p2.y - p1.y;\n        const d2x = edge.b.x - edge.a.x;\n        const d2y = edge.b.y - edge.a.y;\n\n        const cross = d1x * d2y - d1y * d2x;\n        if (Math.abs(cross) < eps) continue; // Parallel\n\n        const dx = edge.a.x - p1.x;\n        const dy = edge.a.y - p1.y;\n\n        const t1 = (dx * d2y - dy * d2x) / cross;\n        const t2 = (dx * d1y - dy * d1x) / cross;\n\n        // Check if intersection is within both segments (with small margin)\n        if (t1 > eps && t1 < 1 - eps && t2 > eps && t2 < 1 - eps) {\n            return true; // Crosses an edge\n        }\n    }\n\n    return false;\n}\n\n/**\n * Main hidden line removal function\n * @param {Mesh} mesh \n * @param {Camera} camera \n * @param {Scene} scene \n * @param {Object} options\n * @param {number} [options.smoothThreshold] - Threshold for smooth edge removal (default 0.99)\n * @param {number} [options.gridSize] - Spatial hash grid size (default 32)\n * @param {number} [options.occlusionEpsilon] - Occlusion test tolerance (relative to camera distance)\n * @param {boolean} [options.skipOcclusion] - Skip occlusion testing (debug mode)\n * @param {number} [options.width] - Viewport width\n * @param {number} [options.height] - Viewport height\n * @param {any} [options.renderer] - THREE.WebGLRenderer for depth buffer occlusion (fast)\n * @returns {{edges: Edge2D[], profiles: Edge2D[]}}\n */\nexport function computeHiddenLines(mesh, camera, scene, options = {}) {\n    const {\n        smoothThreshold = 0.99,\n        gridSize = 32,\n        occlusionEpsilon = 0.01, // 1% depth tolerance for depth buffer\n        skipOcclusion = false,\n        width = 800,\n        height = 600,\n        renderer = null\n    } = options;\n\n    console.time('extractEdges');\n    const edges3d = extractEdges(mesh, camera.position);\n    console.timeEnd('extractEdges');\n    console.log(`Extracted ${edges3d.length} edges`);\n\n    console.time('filterBackfacing');\n    const frontEdges = filterBackfacing(edges3d, camera.position);\n    console.timeEnd('filterBackfacing');\n    console.log(`After backface filter: ${frontEdges.length} edges`);\n\n    console.time('classifyEdges');\n    const { profiles, smoothFiltered } = classifyEdges(frontEdges, camera.position, smoothThreshold);\n    console.timeEnd('classifyEdges');\n    console.log(`Profiles: ${profiles.length}, Smooth edges: ${smoothFiltered.length}`);\n\n    // Combine profile and smooth edges for processing\n    const allEdges = [...profiles, ...smoothFiltered];\n\n    console.time('projectEdges');\n    let edges2d = projectEdges(allEdges, camera, width, height);\n    console.timeEnd('projectEdges');\n\n    // Mark profile edges\n    for (let i = 0; i < profiles.length; i++) {\n        edges2d[i].isProfile = true;\n    }\n\n    console.time('spatialHash');\n    const cellSize = Math.max(width, height) / gridSize;\n    const hash = new SpatialHash(cellSize);\n    for (const edge of edges2d) {\n        hash.insert(edge);\n    }\n    console.timeEnd('spatialHash');\n\n    console.time('splitIntersections');\n    // Process each cell\n    const processedEdges = new Set();\n    let splitEdges = [];\n\n    for (const cellKey of hash.getAllCells()) {\n        const cellEdges = hash.query(cellKey).filter(e => !processedEdges.has(e));\n        const split = splitAtIntersections(cellEdges);\n        splitEdges.push(...split);\n        for (const e of cellEdges) processedEdges.add(e);\n    }\n    console.timeEnd('splitIntersections');\n    console.log(`After splitting: ${splitEdges.length} edges`);\n\n    let visibleEdges;\n    if (skipOcclusion) {\n        console.log('Skipping occlusion test (debug mode)');\n        visibleEdges = splitEdges;\n    } else if (renderer) {\n        console.time('testOcclusion (face ID buffer)');\n        // Separate profile and non-profile edges\n        const profileEdges = splitEdges.filter(e => e.isProfile);\n        const otherEdges = splitEdges.filter(e => !e.isProfile);\n\n        // Profile edges are ALWAYS visible (silhouette edges)\n        profileEdges.forEach(e => e.visible = true);\n\n        // Test occlusion only for non-profile edges using face ID buffer\n        const visibleOtherEdges = testOcclusionFaceID(otherEdges, [mesh], camera, width, height, renderer, false);\n\n        visibleEdges = [...profileEdges, ...visibleOtherEdges];\n        console.timeEnd('testOcclusion (face ID buffer)');\n    } else {\n        console.time('testOcclusion (raycaster - slow)');\n        visibleEdges = testOcclusion(splitEdges, scene, camera, occlusionEpsilon);\n        console.timeEnd('testOcclusion (raycaster - slow)');\n    }\n    console.log(`Visible edges: ${visibleEdges.length}`);\n\n    console.time('optimize');\n    const optimizedEdges = optimizeEdges(visibleEdges);\n    console.timeEnd('optimize');\n\n    console.time('cleanup orphans');\n    const finalEdges = cleanupOrphanedEdges(optimizedEdges);\n    console.timeEnd('cleanup orphans');\n    console.log(`Final edges: ${finalEdges.length}`);\n\n    return {\n        edges: finalEdges,\n        profiles: finalEdges.filter(e => e.isProfile)\n    };\n}\n\n/**\n * Hidden line removal for multiple meshes with cross-object occlusion\n * All meshes are rendered to a single face ID buffer for correct occlusion\n * @param {Mesh[]} meshes \n * @param {Camera} camera \n * @param {Scene} scene \n * @param {Object} options\n * @param {number} [options.smoothThreshold]\n * @param {number} [options.gridSize]\n * @param {boolean} [options.skipOcclusion]\n * @param {number} [options.width]\n * @param {number} [options.height]\n * @param {any} [options.renderer]\n * @param {Edge3D[]} [options.hatchEdges] - Optional array of Edge3D objects for hatching\n * @param {number} [options.minHatchDotProduct] - Minimum dot product with view vector to keep hatch edges (0-1)\n * @param {number} [options.internalScale] - Internal scale factor (default: 4)\n * @param {number} [options.distanceThreshold] - Distance threshold for coplanar detection (default: 0.5)\n * @returns {{edges: Edge2D[], profiles: Edge2D[], allEdges: Edge2D[], projectedFaces: ProjectedFace[]}}\n */\nexport function computeHiddenLinesMultiple(meshes, camera, scene, options = {}) {\n    const {\n        smoothThreshold = 0.99,\n        gridSize = 32,\n        skipOcclusion = false,\n        width = 800,\n        height = 600,\n        renderer = null,\n        internalScale = 4,  // Scale up internally for better precision\n        distanceThreshold = 0.5 // Default plane distance threshold\n    } = options;\n\n    // Process each mesh to extract edges (keep local face indices with mesh reference)\n    let allEdges3d = [];\n\n    for (const mesh of meshes) {\n        mesh.updateMatrixWorld(true);\n        const edges3d = extractEdges(mesh, camera.position);\n        // Edges already have mesh reference and local faceIdx1/faceIdx2 from extractEdges\n        allEdges3d.push(...edges3d);\n    }\n\n    console.log(`Extracted ${allEdges3d.length} edges from ${meshes.length} meshes`);\n\n    // Classify edges: identify profiles and filter smooth edges\n    const { profiles, smoothFiltered } = classifyEdges(allEdges3d, camera.position, smoothThreshold);\n    console.log(`Profiles: ${profiles.length}, Crease edges: ${smoothFiltered.length}`);\n\n    const allEdges = [...profiles, ...smoothFiltered];\n    console.log(`After smooth filter: ${allEdges.length} edges`);\n\n    // Project to 2D (with internal scale for precision)\n    let edges2d = projectEdges(allEdges, camera, width, height, internalScale);\n\n    // Process additional hatch edges if provided\n    if (options.hatchEdges && options.hatchEdges.length > 0) {\n        console.log(`Processing ${options.hatchEdges.length} hatch edges...`);\n        // Filter backfacing hatch edges\n        let visibleHatch = filterBackfacing(options.hatchEdges, camera.position);\n\n        // Filter over-dense hatching based on view angle\n        if (options.minHatchDotProduct !== undefined) {\n            const threshold = options.minHatchDotProduct;\n            visibleHatch = visibleHatch.filter(edge => {\n                const edgeMidpoint = new Vector3().addVectors(edge.a, edge.b).multiplyScalar(0.5);\n                const viewDir = new Vector3().subVectors(camera.position, edgeMidpoint).normalize();\n                const dot = edge.normal1.dot(viewDir);\n                return Math.abs(dot) >= threshold;\n            });\n            console.log(`Density filter: kept ${visibleHatch.length} hatch edges (threshold ${threshold})`);\n        }\n\n        // Project\n        const hatch2d = projectEdges(visibleHatch, camera, width, height, internalScale);\n\n        // Mark explicitly (in case projectEdges didn't catch it from source)\n        hatch2d.forEach(e => e.isHatch = true);\n\n        // Add to main list\n        edges2d.push(...hatch2d);\n        console.log(`Added ${hatch2d.length} visible hatch edges`);\n    }\n\n    // Mark profile edges\n    // Split all edges at intersections (direct O(n) comparison - no spatial hash)\n    console.time('splitIntersections');\n    const splitEdges = splitAtIntersections(edges2d);\n    console.timeEnd('splitIntersections');\n    console.log(`After splitting: ${splitEdges.length} edges`);\n\n    // Build projected faces array for math occlusion\n    console.time('buildProjectedFaces');\n    /** @type {ProjectedFace[]} */\n    const projectedFaces = [];\n    const cameraPos = camera.position;\n    const halfWidth = width / 2;\n    const halfHeight = height / 2;\n\n    for (const mesh of meshes) {\n        const geom = mesh.geometry;\n        const position = geom.attributes.position;\n        const index = geom.index;\n        const numFaces = index ? index.count / 3 : position.count / 3;\n\n        for (let f = 0; f < numFaces; f++) {\n            let i0, i1, i2;\n            if (index) {\n                i0 = index.getX(f * 3);\n                i1 = index.getX(f * 3 + 1);\n                i2 = index.getX(f * 3 + 2);\n            } else {\n                i0 = f * 3;\n                i1 = f * 3 + 1;\n                i2 = f * 3 + 2;\n            }\n\n            // Get world-space vertices\n            const v0 = new Vector3(position.getX(i0), position.getY(i0), position.getZ(i0)).applyMatrix4(mesh.matrixWorld);\n            const v1 = new Vector3(position.getX(i1), position.getY(i1), position.getZ(i1)).applyMatrix4(mesh.matrixWorld);\n            const v2 = new Vector3(position.getX(i2), position.getY(i2), position.getZ(i2)).applyMatrix4(mesh.matrixWorld);\n\n            // Compute face normal and check if front-facing\n            const edge1 = new Vector3().subVectors(v1, v0);\n            const edge2 = new Vector3().subVectors(v2, v0);\n            const normal = new Vector3().crossVectors(edge1, edge2).normalize();\n            const faceMid = new Vector3().addVectors(v0, v1).add(v2).divideScalar(3);\n            const viewDir = new Vector3().subVectors(cameraPos, faceMid);\n\n            // Plane constant d for the plane equation ax + by + cz + d = 0\n            // d = -(n . p)\n            const constant = -normal.dot(v0);\n\n            // Only include front-facing faces (back-facing can't occlude)\n            if (normal.dot(viewDir) <= 0) continue;\n\n            // Project to 2D\n            const p0 = v0.clone().project(camera);\n            const p1 = v1.clone().project(camera);\n            const p2 = v2.clone().project(camera);\n\n            // Convert to screen coordinates (with same scale as edges)\n            const a2d = new Vector2(p0.x * halfWidth * internalScale, -p0.y * halfHeight * internalScale);\n            const b2d = new Vector2(p1.x * halfWidth * internalScale, -p1.y * halfHeight * internalScale);\n            const c2d = new Vector2(p2.x * halfWidth * internalScale, -p2.y * halfHeight * internalScale);\n\n            // Compute depths using view-space Z-coordinate (not Euclidean distance)\n            // This correctly handles perspective distortion for barycentric interpolation\n            const viewMatrix = camera.matrixWorldInverse;\n            const depthA = -v0.clone().applyMatrix4(viewMatrix).z;\n            const depthB = -v1.clone().applyMatrix4(viewMatrix).z;\n            const depthC = -v2.clone().applyMatrix4(viewMatrix).z;\n\n            projectedFaces.push({\n                a2d, b2d, c2d,\n                depthA, depthB, depthC,\n                mesh, faceIdx: f,\n                normal,  // Store normal for post-split smooth filter\n                constant // Store plane constant for coplanar detection\n            });\n        }\n    }\n    console.timeEnd('buildProjectedFaces');\n    console.log(`Built ${projectedFaces.length} projected faces for occlusion`);\n\n    // Classify silhouette edges (edges that border the void) - BEFORE cleanup/optimization\n    console.time('classifySilhouettes');\n    classifySilhouettes(splitEdges, projectedFaces);\n    console.timeEnd('classifySilhouettes');\n\n    // Geometric straggler filter: remove edges lying between coplanar faces\n    console.time('filterSmoothSplitEdges');\n    const smoothFilteredEdges = filterSmoothSplitEdges(splitEdges, projectedFaces, smoothThreshold, distanceThreshold);\n    console.timeEnd('filterSmoothSplitEdges');\n\n    // Occlusion using pure math\n    let visibleEdges;\n    if (skipOcclusion) {\n        visibleEdges = smoothFilteredEdges;\n    } else {\n        console.time('testOcclusion (math)');\n        // Test ALL edges through occlusion (no special treatment for profiles)\n        visibleEdges = testOcclusionMath(smoothFilteredEdges, projectedFaces, camera);\n        console.timeEnd('testOcclusion (math)');\n    }\n    console.log(`Visible edges: ${visibleEdges.length}`);\n\n    console.time('optimize');\n    const optimizedEdges = optimizeEdges(visibleEdges);\n    console.timeEnd('optimize');\n\n    console.time('cleanup orphans');\n    const cleanedEdges = cleanupOrphanedEdges(optimizedEdges);\n    console.timeEnd('cleanup orphans');\n\n    // Remove completely isolated edges (orphaned at both ends)\n    const filteredEdges = removeIsolatedEdges(cleanedEdges);\n    console.log(`Final edges before optimization: ${filteredEdges.length}`);\n\n    // Run through Optimize.js\n    let optimizedFinal = filteredEdges;\n    if (filteredEdges.length > 0) {\n        let totalLen = 0;\n        for (const e of filteredEdges) {\n            const dx = e.b.x - e.a.x;\n            const dy = e.b.y - e.a.y;\n            totalLen += Math.sqrt(dx * dx + dy * dy);\n        }\n        const avgLen = totalLen / filteredEdges.length;\n        const smallDist = avgLen / 10;\n        console.log(`Optimization: avgLen=${avgLen.toFixed(2)}, trim limit=${smallDist.toFixed(2)}`);\n\n        console.time('Optimize.segments');\n        // @ts-ignore - _segments is private but we need the raw objects to preserve metadata\n        optimizedFinal = Optimize.segments(filteredEdges, false, true, smallDist, false, false, false)._segments;\n        console.timeEnd('Optimize.segments');\n        console.log(`After optimization: ${optimizedFinal.length} edges`);\n    }\n\n\n\n    // Scale edges back down to original coordinate space\n    for (const edge of optimizedFinal) {\n        edge.a.x /= internalScale;\n        edge.a.y /= internalScale;\n        edge.b.x /= internalScale;\n        edge.b.y /= internalScale;\n    }\n    const finalEdges = optimizedFinal;\n\n    return {\n        edges: finalEdges,\n        profiles: finalEdges.filter(e => e.isProfile),\n        allEdges: splitEdges, // For debug visualization\n        projectedFaces: projectedFaces  // For face visualization\n    };\n}\n\n/**\n * Classify edges as silhouettes if they border the void (one side has no mesh)\n * Uses 2D ray casting from edge midpoint perpendicular to the edge\n * @param {Edge2D[]} edges - Edges to classify\n * @param {ProjectedFace[]} projectedFaces - Projected triangles for hit testing\n */\nfunction classifySilhouettes(edges, projectedFaces) {\n    const RAY_LENGTH = 1000; // Long ray to ensure we hit any face on that side\n\n    for (const edge of edges) {\n        // Hatches are never silhouettes\n        if (edge.isHatch) {\n            edge.isSilhouette = false;\n            continue;\n        }\n\n        // Calculate midpoint\n        const midX = (edge.a.x + edge.b.x) / 2;\n        const midY = (edge.a.y + edge.b.y) / 2;\n\n        // Calculate edge direction and perpendicular\n        const dx = edge.b.x - edge.a.x;\n        const dy = edge.b.y - edge.a.y;\n        const len = Math.sqrt(dx * dx + dy * dy);\n\n        if (len < 0.001) {\n            edge.isSilhouette = false;\n            continue;\n        }\n\n        // Perpendicular direction (normalized)\n        const perpX = -dy / len;\n        const perpY = dx / len;\n\n        // Raycast on each side - check if ray intersects any face edge\n        const leftHit = rayHitsAnyFace(midX, midY, perpX, perpY, RAY_LENGTH, projectedFaces);\n        const rightHit = rayHitsAnyFace(midX, midY, -perpX, -perpY, RAY_LENGTH, projectedFaces);\n\n        // Silhouette if one side has no intersection\n        edge.isSilhouette = !leftHit || !rightHit;\n    }\n\n    const silCount = edges.filter(e => e.isSilhouette).length;\n    console.log(`Classified ${silCount} silhouette edges out of ${edges.length}`);\n}\n\n/**\n * Check if a 2D ray from origin in direction (dx, dy) intersects any projected triangle\n * @param {number} ox - Ray origin X\n * @param {number} oy - Ray origin Y\n * @param {number} dx - Ray direction X\n * @param {number} dy - Ray direction Y\n * @param {number} maxDist - Maximum ray distance\n * @param {ProjectedFace[]} faces - Array of projected faces\n * @returns {boolean}\n */\nfunction rayHitsAnyFace(ox, oy, dx, dy, maxDist, faces) {\n    for (const face of faces) {\n        if (rayIntersectsTriangle(ox, oy, dx, dy, maxDist, face.a2d, face.b2d, face.c2d)) {\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * Check if 2D ray intersects a triangle (any of its 3 edges)\n * @param {number} ox - Ray origin X\n * @param {number} oy - Ray origin Y\n * @param {number} rdx - Ray direction X\n * @param {number} rdy - Ray direction Y\n * @param {number} maxDist\n * @param {Vector2} a - Triangle vertex A\n * @param {Vector2} b - Triangle vertex B\n * @param {Vector2} c - Triangle vertex C\n * @returns {boolean}\n */\nfunction rayIntersectsTriangle(ox, oy, rdx, rdy, maxDist, a, b, c) {\n    if (raySegmentIntersect(ox, oy, rdx, rdy, maxDist, a.x, a.y, b.x, b.y)) return true;\n    if (raySegmentIntersect(ox, oy, rdx, rdy, maxDist, b.x, b.y, c.x, c.y)) return true;\n    if (raySegmentIntersect(ox, oy, rdx, rdy, maxDist, c.x, c.y, a.x, a.y)) return true;\n    return false;\n}\n\n/**\n * Check if 2D ray (origin ox,oy, direction rdx,rdy) intersects line segment (x1,y1)-(x2,y2)\n * @param {number} ox\n * @param {number} oy\n * @param {number} rdx\n * @param {number} rdy\n * @param {number} maxDist\n * @param {number} x1\n * @param {number} y1\n * @param {number} x2\n * @param {number} y2\n * @returns {boolean}\n */\nfunction raySegmentIntersect(ox, oy, rdx, rdy, maxDist, x1, y1, x2, y2) {\n    const sdx = x2 - x1;\n    const sdy = y2 - y1;\n\n    const denom = rdx * sdy - rdy * sdx;\n    if (Math.abs(denom) < 1e-10) return false; // Parallel\n\n    const t = ((x1 - ox) * sdy - (y1 - oy) * sdx) / denom;\n    const u = ((x1 - ox) * rdy - (y1 - oy) * rdx) / denom;\n\n    // t > 0.1 (past origin, small epsilon), t <= maxDist, u in [0,1] (on segment)\n    return t > 0.1 && t <= maxDist && u >= 0 && u <= 1;\n}\n\n/**\n * Check if a 2D point is inside any projected triangle\n * @param {number} px \n * @param {number} py \n * @param {ProjectedFace[]} faces \n * @returns {boolean}\n */\nfunction pointInAnyFace(px, py, faces) {\n    for (const face of faces) {\n        if (pointInTriangle(px, py, face.a2d, face.b2d, face.c2d)) {\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * Check if point (px, py) is inside triangle (a, b, c) using barycentric coordinates\n * @param {number} px \n * @param {number} py \n * @param {Vector2} a \n * @param {Vector2} b \n * @param {Vector2} c \n * @returns {boolean}\n */\nfunction pointInTriangle(px, py, a, b, c) {\n    const v0x = c.x - a.x;\n    const v0y = c.y - a.y;\n    const v1x = b.x - a.x;\n    const v1y = b.y - a.y;\n    const v2x = px - a.x;\n    const v2y = py - a.y;\n\n    const dot00 = v0x * v0x + v0y * v0y;\n    const dot01 = v0x * v1x + v0y * v1y;\n    const dot02 = v0x * v2x + v0y * v2y;\n    const dot11 = v1x * v1x + v1y * v1y;\n    const dot12 = v1x * v2x + v1y * v2y;\n\n    const invDenom = 1 / (dot00 * dot11 - dot01 * dot01);\n    const u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n    const v = (dot00 * dot12 - dot01 * dot02) * invDenom;\n\n    return (u >= 0) && (v >= 0) && (u + v <= 1);\n}\n","/**\n * PlotterRenderer - GPU-based SVG renderer for Three.js\n * Based on SVGRenderer by @mrdoob / http://mrdoob.com/\n */\n\nimport { Camera, Color, Object3D, Vector3, DirectionalLight, PointLight, SpotLight } from \"three\";\nimport { extractNormalRegions, renderNormals as debugRenderNormals } from \"./gpu-silhouette.js\";\nexport { debugRenderNormals };\nimport { generatePerspectiveHatches, clipLineOutsidePolygon } from \"./perspective-hatch.js\";\nimport { computeHiddenLinesMultiple } from \"./hidden-line.js\";\n\nvar lop = (n) => {\n  return Math.round(n * 100) / 100;\n};\n\nvar SVGObject = function (node) {\n  Object3D.call(this);\n  this.node = node;\n};\n\nSVGObject.prototype = Object.create(Object3D.prototype);\nSVGObject.prototype.constructor = SVGObject;\n\nvar PlotterRenderer = function () {\n  var _this = this,\n    _svg = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\"),\n    _silhouettes = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\"),\n    _edges = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\"),\n    _shading = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\"),\n    _svgWidth,\n    _svgHeight,\n    _svgWidthHalf,\n    _svgHeightHalf,\n    _clearColor = new Color();\n\n  // Add proper SVG namespace attributes for macOS and native rendering\n  _svg.setAttribute(\"xmlns\", \"http://www.w3.org/2000/svg\");\n  _svg.setAttribute(\"xmlns:inkscape\", \"http://www.inkscape.org/namespaces/inkscape\");\n  _svg.setAttribute(\"xmlns:xlink\", \"http://www.w3.org/1999/xlink\");\n  _svg.setAttribute(\"version\", \"1.1\");\n\n  // Setup SVG layers (order determines z-index: later = on top)\n  _silhouettes.setAttribute(\"inkscape:label\", \"Silhouettes\");\n  _silhouettes.setAttribute(\"inkscape:groupmode\", \"layer\");\n  _silhouettes.id = \"silhouettes_layer\";\n  _svg.appendChild(_silhouettes);\n\n  _shading.setAttribute(\"inkscape:label\", \"Shading\");\n  _shading.setAttribute(\"inkscape:groupmode\", \"layer\");\n  _shading.id = \"shading_layer\";\n  _svg.appendChild(_shading);\n\n  _edges.setAttribute(\"inkscape:label\", \"Edges\");\n  _edges.setAttribute(\"inkscape:groupmode\", \"layer\");\n  _edges.id = \"edges_layer\";\n  _svg.appendChild(_edges);\n\n  this.domElement = _svg;\n\n  // Layer toggles\n  this.showSilhouettes = true;\n  this.showEdges = true;\n  this.showHatches = true;\n\n  // Theme definitions\n  this.themes = {\n    light: {\n      background: '#ffffff',\n      edgeStroke: '#000000',\n      hatchStroke: '#444444',\n      silhouetteFill: (n) => `rgba(${Math.floor((n.x * 0.5 + 0.5) * 40 + 200)},${Math.floor((n.y * 0.5 + 0.5) * 40 + 200)},${Math.floor((n.z * 0.5 + 0.5) * 40 + 200)},0.3)`\n    },\n    dark: {\n      background: '#222222',\n      edgeStroke: '#ffffff',\n      hatchStroke: '#aaaaaa',\n      silhouetteFill: (n) => `rgba(${Math.floor((n.x * 0.5 + 0.5) * 255)},${Math.floor((n.y * 0.5 + 0.5) * 255)},${Math.floor((n.z * 0.5 + 0.5) * 255)},0.3)`\n    }\n  };\n\n  // Current theme\n  this.theme = 'dark';\n\n  // Silhouette options (GPU normal regions)\n  this.silhouetteOptions = {\n    normalBuckets: 12,\n    simplifyTolerance: 2.0,\n    minArea: 100\n  };\n\n  // Hatch options (perspective hatching)\n  this.hatchOptions = {\n    baseSpacing: 8,\n    minSpacing: 3,\n    maxSpacing: 40,\n    depthFactor: 0.5,\n    insetPixels: 2,\n    stroke: null,  // null = use theme\n    strokeWidth: '1px',\n    axisSettings: {\n      x: { rotation: 0, spacing: 8 },\n      y: { rotation: 0, spacing: 8 },\n      z: { rotation: 0, spacing: 8 }\n    },\n    // Brightness-based shading\n    brightnessShading: {\n      enabled: false,           // Enable lighting-based density\n      invert: false,            // True for white pen on black paper\n      lightDirection: null      // Override: Vector3 or null (auto from scene)\n    },\n    // Async rendering options\n    frameBudgetMs: 16,          // Max ms per frame (16ms = ~60fps)\n    progressCallback: null      // Optional: (progress: 0-1) => void\n  };\n\n\n  // Edge options (hidden line edges)\n  this.edgeOptions = {\n    stroke: null,  // null = use theme\n    strokeWidth: '1px'\n  };\n\n  // Hidden-line options\n  this.hiddenLineOptions = {\n    smoothThreshold: 0.99\n  };\n\n  // WebGL renderer reference (needed for GPU operations)\n  this._glRenderer = null;\n\n  this.autoClear = true;\n\n  this.setClearColor = function (color) {\n    _clearColor.set(color);\n  };\n\n  this.setPixelRatio = function () { };\n\n  this.setSize = function (width, height) {\n    _svgWidth = width;\n    _svgHeight = height;\n    _svgWidthHalf = _svgWidth / 2;\n    _svgHeightHalf = _svgHeight / 2;\n\n    _svg.setAttribute(\"viewBox\", -_svgWidthHalf + \" \" + -_svgHeightHalf + \" \" + _svgWidth + \" \" + _svgHeight);\n    _svg.setAttribute(\"width\", _svgWidth);\n    _svg.setAttribute(\"height\", _svgHeight);\n  };\n\n  this.getSize = function () {\n    return {\n      width: _svgWidth,\n      height: _svgHeight,\n    };\n  };\n\n  this.setGLRenderer = function (glRenderer) {\n    _this._glRenderer = glRenderer;\n  };\n\n  function removeChildNodes() {\n    while (_silhouettes.childNodes.length > 0) {\n      _silhouettes.removeChild(_silhouettes.childNodes[0]);\n    }\n    while (_edges.childNodes.length > 0) {\n      _edges.removeChild(_edges.childNodes[0]);\n    }\n    while (_shading.childNodes.length > 0) {\n      _shading.removeChild(_shading.childNodes[0]);\n    }\n  }\n\n  this.clear = function () {\n    removeChildNodes();\n    _svg.style.backgroundColor = _clearColor.getStyle();\n  };\n\n  /**\n   * Render GPU-based layers (silhouettes and hatches)\n   * Returns a Promise that resolves when rendering is complete.\n   * Uses frame budgeting to avoid blocking the browser on complex models.\n   * @param {Object} scene - Three.js scene\n   * @param {Object} camera - Three.js camera\n   * @returns {Promise<void>}\n   */\n  this.renderGPULayers = async function (scene, camera) {\n    if (!_this._glRenderer) {\n      console.warn(\"PlotterRenderer: WebGL renderer not set. Call setGLRenderer() first.\");\n      return;\n    }\n\n\n    const glRenderer = _this._glRenderer;\n\n    // GPU Silhouettes (region fills based on normal direction)\n    if (_this.showSilhouettes || _this.showHatches) {\n      const regions = extractNormalRegions(glRenderer, scene, camera, {\n        normalBuckets: _this.silhouetteOptions.normalBuckets,\n        simplifyTolerance: _this.silhouetteOptions.simplifyTolerance,\n        minArea: _this.silhouetteOptions.minArea,\n        insetPixels: _this.showHatches ? _this.hatchOptions.insetPixels : 0\n      });\n\n      // Draw silhouette fills\n      if (_this.showSilhouettes) {\n        regions.forEach(region => {\n          if (region.boundary.length < 3) return;\n\n          const path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n          let d = \"\";\n          region.boundary.forEach((pt, i) => {\n            const x = pt.x;\n            const y = -pt.y; // GPU regions use different Y convention\n            d += (i === 0 ? \"M\" : \"L\") + lop(x) + \",\" + lop(y);\n          });\n          d += \"Z\";\n\n          // Color based on normal direction (use theme if available)\n          const n = region.normal;\n          const currentTheme = _this.themes[_this.theme] || _this.themes.dark;\n          const fillColor = currentTheme.silhouetteFill ? currentTheme.silhouetteFill(n) : `rgba(${Math.floor((n.x * 0.5 + 0.5) * 255)},${Math.floor((n.y * 0.5 + 0.5) * 255)},${Math.floor((n.z * 0.5 + 0.5) * 255)},0.3)`;\n\n          path.setAttribute(\"d\", d);\n          path.setAttribute(\"fill\", fillColor);\n          path.setAttribute(\"stroke\", \"none\");\n          _silhouettes.appendChild(path);\n        });\n      }\n\n      // GPU Perspective Hatches (render before edges so edges appear on top)\n      if (_this.showHatches) {\n        // Sort by depth (front first) for occlusion\n        regions.sort((a, b) => a.depth - b.depth);\n        // Use hatchBoundary for clipping (inset boundary, falls back to regular boundary)\n        const allRegionBounds = regions.map(r => r.hatchBoundary || r.boundary);\n\n        // Compute zoom-invariant spacing scale factor\n        // Project scene bounding box to screen space, use that size relative to canvas\n        let spacingScale = 1.0;\n        {\n          // Compute world-space bounding box of all meshes in scene\n          let minX = Infinity, maxX = -Infinity;\n          let minY = Infinity, maxY = -Infinity;\n          let minZ = Infinity, maxZ = -Infinity;\n\n          scene.traverse((obj) => {\n            if (!obj.isMesh || !obj.geometry) return;\n            obj.geometry.computeBoundingBox();\n            const bbox = obj.geometry.boundingBox;\n            if (!bbox) return;\n\n            // Transform bbox corners to world space\n            const corners = [\n              new Vector3(bbox.min.x, bbox.min.y, bbox.min.z),\n              new Vector3(bbox.max.x, bbox.max.y, bbox.max.z),\n              new Vector3(bbox.min.x, bbox.min.y, bbox.max.z),\n              new Vector3(bbox.min.x, bbox.max.y, bbox.min.z),\n              new Vector3(bbox.max.x, bbox.min.y, bbox.min.z),\n              new Vector3(bbox.min.x, bbox.max.y, bbox.max.z),\n              new Vector3(bbox.max.x, bbox.min.y, bbox.max.z),\n              new Vector3(bbox.max.x, bbox.max.y, bbox.min.z)\n            ];\n            for (const corner of corners) {\n              corner.applyMatrix4(obj.matrixWorld);\n              minX = Math.min(minX, corner.x);\n              maxX = Math.max(maxX, corner.x);\n              minY = Math.min(minY, corner.y);\n              maxY = Math.max(maxY, corner.y);\n              minZ = Math.min(minZ, corner.z);\n              maxZ = Math.max(maxZ, corner.z);\n            }\n          });\n\n          // Project bbox corners to screen space and compute screen-space bbox\n          if (isFinite(minX)) {\n            const worldCorners = [\n              new Vector3(minX, minY, minZ),\n              new Vector3(maxX, maxY, maxZ),\n              new Vector3(minX, minY, maxZ),\n              new Vector3(minX, maxY, minZ),\n              new Vector3(maxX, minY, minZ),\n              new Vector3(minX, maxY, maxZ),\n              new Vector3(maxX, minY, maxZ),\n              new Vector3(maxX, maxY, minZ)\n            ];\n\n            let screenMinX = Infinity, screenMaxX = -Infinity;\n            let screenMinY = Infinity, screenMaxY = -Infinity;\n\n            for (const corner of worldCorners) {\n              const projected = corner.clone().project(camera);\n              const screenX = (projected.x + 1) * _svgWidth / 2;\n              const screenY = (1 - projected.y) * _svgHeight / 2;\n              screenMinX = Math.min(screenMinX, screenX);\n              screenMaxX = Math.max(screenMaxX, screenX);\n              screenMinY = Math.min(screenMinY, screenY);\n              screenMaxY = Math.max(screenMaxY, screenY);\n            }\n\n            const screenWidth = screenMaxX - screenMinX;\n            const screenHeight = screenMaxY - screenMinY;\n            const screenSize = Math.max(screenWidth, screenHeight);\n            const canvasSize = Math.max(_svgWidth, _svgHeight);\n\n            // Scale factor: model screen size / canvas size\n            // When model fills canvas, spacingScale = 1\n            // When model is smaller, spacingScale < 1 (denser relative spacing)\n            if (screenSize > 0 && canvasSize > 0) {\n              spacingScale = screenSize / canvasSize;\n            }\n\n          }\n        }\n\n\n\n\n\n\n        // Collect hole regions for clipping (regardless of depth order)\n        const holeRegions = regions.filter(r => r.isHole);\n\n\n        // Compute light direction for brightness shading\n        let lightDir = null;\n        const shadingOpts = _this.hatchOptions.brightnessShading || {};\n        if (shadingOpts.enabled) {\n          if (shadingOpts.lightDirection) {\n            lightDir = shadingOpts.lightDirection.clone().normalize();\n          } else {\n            // Auto-detect from scene: find first directional/point/spot light\n            scene.traverse((obj) => {\n              if (lightDir) return;\n              if (obj.isDirectionalLight) {\n                // Direction = from target toward light position\n                lightDir = new Vector3().subVectors(obj.position, obj.target.position).normalize();\n              } else if (obj.isPointLight) {\n                lightDir = obj.position.clone().normalize();\n              } else if (obj.isSpotLight) {\n                lightDir = obj.position.clone().normalize();\n              }\n            });\n            if (!lightDir) {\n              lightDir = new Vector3(1, 1, 1).normalize();\n            }\n          }\n\n          // Transform to view space (MeshNormalMaterial gives view-space normals)\n          lightDir = lightDir.clone().transformDirection(camera.matrixWorldInverse);\n        }\n\n        // Frame budget settings\n        const frameBudgetMs = _this.hatchOptions.frameBudgetMs || 16;\n        const progressCallback = _this.hatchOptions.progressCallback;\n        let frameStartTime = performance.now();\n\n        // Process regions with frame budgeting (yields control to browser)\n        for (let idx = 0; idx < regions.length; idx++) {\n          const region = regions[idx];\n\n          // Compute brightness: NL (Lambertian)\n          let brightness = null;\n          if (lightDir && shadingOpts.enabled) {\n            brightness = Math.max(0, region.normal.dot(lightDir));\n          }\n\n          // Time budget for this region (abort if taking too long)\n          const regionStartTime = performance.now();\n          const regionTimeBudget = _this.hatchOptions.regionTimeBudget || 100; // ms per region\n\n          // Scale axisSettings spacing values too\n          const scaledAxisSettings = {};\n          const rawAxisSettings = _this.hatchOptions.axisSettings || {};\n          for (const axis of ['x', 'y', 'z']) {\n            const settings = rawAxisSettings[axis] || {};\n            scaledAxisSettings[axis] = {\n              rotation: settings.rotation || 0,\n              spacing: (settings.spacing || _this.hatchOptions.baseSpacing) * spacingScale\n            };\n          }\n\n          let hatches = generatePerspectiveHatches(region, camera, {\n            baseSpacing: _this.hatchOptions.baseSpacing * spacingScale,\n            minSpacing: _this.hatchOptions.minSpacing * spacingScale,\n            maxSpacing: _this.hatchOptions.maxSpacing * spacingScale,\n            depthFactor: _this.hatchOptions.depthFactor,\n            insetPixels: _this.hatchOptions.insetPixels,\n            screenWidth: _svgWidth,\n            screenHeight: _svgHeight,\n            axisSettings: scaledAxisSettings,\n            brightness: brightness,\n            invertBrightness: shadingOpts.invert || false\n          });\n\n\n\n          // Check time budget after hatch generation\n          if (performance.now() - regionStartTime > regionTimeBudget) {\n            console.warn(`Region ${idx} hatch generation exceeded time budget, skipping`);\n            continue; // Skip this region entirely\n          }\n\n          // Clip against front regions (with time budget check)\n          // Skip clipping holes against their parent region (otherwise hole hatches get removed)\n          for (let frontIdx = 0; frontIdx < idx; frontIdx++) {\n            const frontRegion = regions[frontIdx];\n\n            // Don't clip a hole against its parent - the hole IS inside the parent\n            if (region.isHole && region.parentRegionId === frontRegion.regionId) {\n              continue;\n            }\n\n            hatches = hatches.flatMap(hatch =>\n              clipLineOutsidePolygon(hatch, allRegionBounds[frontIdx])\n            );\n\n            // Check time budget during clipping\n            if (performance.now() - regionStartTime > regionTimeBudget) {\n              console.warn(`Region ${idx} clipping exceeded time budget, aborting`);\n              hatches = []; // Clear hatches and bail\n              break;\n            }\n          }\n\n\n          // Clip against holes that are children of this region\n          // (holes whose parentRegionId matches this region's regionId)\n          for (const holeRegion of holeRegions) {\n            if (holeRegion.parentRegionId !== region.regionId) continue;\n            if (hatches.length === 0) break;\n            hatches = hatches.flatMap(hatch =>\n              clipLineOutsidePolygon(hatch, holeRegion.boundary)\n            );\n          }\n\n\n\n          // Draw hatches (boustrophedon: flip alternating lines to minimize pen travel)\n          const hatchTheme = _this.themes[_this.theme] || _this.themes.dark;\n          const hatchStroke = _this.hatchOptions.stroke || hatchTheme.hatchStroke;\n\n          if (_this.hatchOptions.connectHatches && hatches.length > 0) {\n            // Connect all hatches into one continuous polyline\n            const path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n            let d = \"\";\n            hatches.forEach((hatch, hatchIdx) => {\n              const start = hatchIdx % 2 === 0 ? hatch.start : hatch.end;\n              const end = hatchIdx % 2 === 0 ? hatch.end : hatch.start;\n              if (hatchIdx === 0) {\n                d += `M${lop(start.x)},${lop(-start.y)}`;\n              } else {\n                d += `L${lop(start.x)},${lop(-start.y)}`;  // Connect to next hatch start\n              }\n              d += `L${lop(end.x)},${lop(-end.y)}`;\n            });\n            path.setAttribute(\"d\", d);\n            path.setAttribute(\"fill\", \"none\");\n            path.setAttribute(\"stroke\", hatchStroke);\n            path.setAttribute(\"stroke-width\", _this.hatchOptions.strokeWidth);\n            _shading.appendChild(path);\n          } else {\n            // Individual hatch lines\n            hatches.forEach((hatch, hatchIdx) => {\n              const path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n              // Flip start/end on odd indices for zigzag pen path\n              const start = hatchIdx % 2 === 0 ? hatch.start : hatch.end;\n              const end = hatchIdx % 2 === 0 ? hatch.end : hatch.start;\n              const d = `M${lop(start.x)},${lop(-start.y)}L${lop(end.x)},${lop(-end.y)}`;\n              path.setAttribute(\"d\", d);\n              path.setAttribute(\"fill\", \"none\");\n              path.setAttribute(\"stroke\", hatchStroke);\n              path.setAttribute(\"stroke-width\", _this.hatchOptions.strokeWidth);\n              _shading.appendChild(path);\n            });\n          }\n\n          // Check if we should yield to the browser\n          const elapsed = performance.now() - frameStartTime;\n          if (elapsed > frameBudgetMs && idx < regions.length - 1) {\n            // Report progress\n            if (progressCallback) {\n              progressCallback((idx + 1) / regions.length);\n            }\n            // Yield to browser via requestAnimationFrame\n            await new Promise(resolve => requestAnimationFrame(resolve));\n            frameStartTime = performance.now();\n          }\n        }\n\n        // Final progress callback\n        if (progressCallback) {\n          progressCallback(1);\n        }\n\n      }\n    }\n\n    // Hidden Line Edges (render last so they appear on top)\n    // This is OUTSIDE the silhouettes/hatches block so edges can render independently\n    if (_this.showEdges) {\n      // Collect all meshes from scene (excluding those marked for SVG exclusion)\n      const meshes = [];\n      scene.traverse((obj) => {\n        if (!obj.isMesh || !obj.geometry) return;\n\n        // Check parent hierarchy for exclusion flag\n        let excluded = false;\n        let parent = obj;\n        while (parent) {\n          if (parent.userData && parent.userData.excludeFromSVG) {\n            excluded = true;\n            break;\n          }\n          parent = parent.parent;\n        }\n\n        if (!excluded) {\n          meshes.push(obj);\n        }\n      });\n\n      if (meshes.length > 0) {\n        const result = computeHiddenLinesMultiple(meshes, camera, scene, {\n          smoothThreshold: _this.hiddenLineOptions.smoothThreshold,\n          width: _svgWidth,\n          height: _svgHeight\n        });\n        const edges = result.edges || [];\n\n        const edgeTheme = _this.themes[_this.theme] || _this.themes.dark;\n        const edgeStroke = _this.edgeOptions.stroke || edgeTheme.edgeStroke;\n\n        edges.forEach(edge => {\n          const line = document.createElementNS(\"http://www.w3.org/2000/svg\", \"line\");\n          line.setAttribute(\"x1\", lop(edge.a.x));\n          line.setAttribute(\"y1\", lop(edge.a.y));\n          line.setAttribute(\"x2\", lop(edge.b.x));\n          line.setAttribute(\"y2\", lop(edge.b.y));\n          line.setAttribute(\"stroke\", edgeStroke);\n          line.setAttribute(\"stroke-width\", _this.edgeOptions.strokeWidth);\n          _edges.appendChild(line);\n        });\n      }\n    }\n  };\n\n  /**\n   * Legacy render method - renders wireframe preview during camera movement\n   * For final output, use clear() + renderGPULayers()\n   * @param {Object} scene - Three.js scene\n   * @param {Object} camera - Three.js camera\n   */\n  this.render = function (scene, camera) {\n    if (camera instanceof Camera === false) {\n      console.error(\"PlotterRenderer.render: camera is not an instance of Camera.\");\n      return;\n    }\n\n    // For now, render is a no-op. Use renderGPULayers() for output.\n    // This maintains API compatibility with Three.js SVGRenderer\n  };\n\n};\n\nexport { SVGObject, PlotterRenderer };\n"],"names":["extractNormalRegions","renderer","scene","camera","options","resolution","normalBuckets","minArea","simplifyTolerance","insetPixels","size","Vector2","width","height","insetAmount","normalPixels","renderNormals","depthPixels","renderDepth","regionMap","normalLookup","quantizeNormals","labels","regionCount","labelToNormalId","connectedComponents","regions","regionId","boundary","traceBoundary","simplified","rdpSimplify","area","polygonArea","normalId","normal","Vector3","depth","sampleRegionDepth","scaledInset","screenBoundary","p","insetBoundaryScreen","insetPolygon","detectHoles","target","WebGLRenderTarget","NearestFilter","normalMaterial","MeshNormalMaterial","originalMaterials","hiddenObjects","obj","shouldExclude","parent","originalBackground","pixels","depthMaterial","MeshDepthMaterial","RGBADepthPacking","targetLabel","sum","count","y","x","idx","r","g","b","a","buckets","nextId","normalToId","i","nx","ny","nz","tolerance","qr","qg","qb","key","nextLabel","find","union","px","py","region","neighbors","minLabel","n","labelRemap","finalLabel","root","startX","startY","outer","dx","dy","dir","maxIter","iter","found","checkDir","points","epsilon","maxDist","maxIdx","first","last","dist","perpendicularDistance","left","right","point","lineStart","lineEnd","lenSq","t","projX","projY","j","polygon","amount","result","sign","prev","curr","next","dx1","dy1","dx2","dy2","len1","len2","nx1","ny1","nx2","ny2","inx1","iny1","inx2","iny2","bx","by","blen","dot","scale","getBoundingBox","minX","maxX","minY","maxY","pt","bboxContains","inner","pointInPolygon","inside","xi","yi","xj","yj","bboxes","bbox","other","otherBbox","computeHatchDirection","screenWidth","screenHeight","halfW","halfH","worldUp","worldForward","faceAxis","origin","farPoint","originScreen","farScreen","screenOrigin","direction","vpProjected","vanishingPoint","generatePerspectiveHatches","baseSpacing","minSpacing","maxSpacing","depthFactor","axisSettings","brightness","invertBrightness","hatchBoundary","clipBoundary","worldNormal","qx","qy","qz","ax","ay","az","total","wx","wy","wz","xSettings","ySettings","zSettings","spacingOverride","rotationDeg","finalDirection","rad","cos","sin","perpDir","spacing","brightnessMultiplier","centerX","centerY","center","diag","hatches","vpDist","numLines","angleStep","centerAngle","angle","clipped","clipLineToPolygon","offset","lineCenter","line","intersections","p1","p2","intersection","lineIntersection","midX","midY","clipLineOutsidePolygon","startInside","endInside","lineIntersectionFull","filtered","midT","x1","y1","x2","y2","x3","y3","x4","y4","denom","u","EPSILON","Point","BoundingBox","BoundingCircle","Segment","segA","segB","GeomUtil","seg","SegmentCollection","pts","rot","ptA","segs","ptB","local","bb","bc","Segments","segments","arr","sA","sB","s","d","aA","aB","deg","oldY","oldX","rA","rB","angle1","angle2","numSegs","perc","deltaX","deltaY","targetPt","sourcePt","delta","numFit","remain","travel","bbs","ab","p3","fn","ignoreTouching","s1_x","s1_y","s2_x","s2_y","atX","atY","intPt","ca","boundingBox","polySegs","startPt","aTouching","bTouching","aWithin","bWithin","v1","v2","v3","d1","d2","d3","has_neg","has_pos","out","polySegsA","polySegsB","ptC","iterations","divide","spts","Analyzer","splitTeeIntersections","splitCrossIntersections","cxs","originalPts","token","allPts","crossPts","da","db","newSegs","k","ta","tb","res","nekot","str","byNumConnections","oppIdx","endTokens","ang","searchMultiplier","cenTokens","pointGroups","minDx","minDy","ptArray","hDx","hDy","rayPts","rayPt","nearPts","nPt","nPtA","tokenA","ok","nPtB","tokenB","npA","npB","polyPts","cen","cenToken","Optimize","segCols","noSplit","trimSmall","smallDist","optimizePathOrder","allsegs","sc","noSplitColinear","sb","sn","aa","ba","heading","same","isRev","extractEdges","mesh","cameraPosition","geometry","position","index","edgeMap","SNAP","getEdgeKey","va","vb","bz","keyA","keyB","getVertex","getFaceNormal","v0","edge1","edge2","numFaces","f","i0","i1","i2","faceMid","viewDir","edges","existing","filterBackfacing","edge","edgeMidpoint","facing1","facing2","classifyEdges","smoothThreshold","profiles","smoothFiltered","projectEdges","halfWidth","halfHeight","projectPoint","p3d","projected","SpatialHash","cellSize","cx","cy","cells","steps","_a","findIntersection","e1","e2","t1","t2","eps","splitAtIntersections","splits","pointOnEdgeInterior","potentialStragglers","_b","tAonJ","_c","tBonJ","_d","tAonI","_e","tBonI","_f","edgeSplits","isStraggler","prevPoint","prevPoint3d","split","point3d","testOcclusionFaceID","meshes","isProfile","e","visibleEdges","renderTarget","RGBAFormat","UnsignedByteType","faceIdMaterial","ShaderMaterial","DoubleSide","faceIdMeshes","globalFaceOffset","geom","newPositions","faceColors","globalFaceId","newGeom","BufferGeometry","BufferAttribute","faceIdMesh","Mesh","tempScene","Scene","faceIdData","sx","sy","sampledFaceId","parentMeshOffset","parentFaceId","parentFaceId2","m","pointInTriangle2D","c","hasNeg","hasPos","edgeLiesAlongFaceEdge","edgeA","edgeB","faceEdgeA","faceEdgeB","projectAndCheck","findAdjacentFaces","projectedFaces","results","face","faceEdges","fe","barycentricDepth","depthA","depthB","depthC","dot00","dot01","dot02","dot11","dot12","v","filterSmoothSplitEdges","coplanarThreshold","distanceThreshold","filteredEdges","removedCount","adjacentFaces","shouldRemove","f1","f2","fn1","fn2","similarity","distDiff","faces","af","allCoplanar","minSimilarity","sim","testOcclusionMath","cameraPos","viewMatrix","testOcclusionMathJS","debugHitCount","debugOccludedCount","mid2d","mid3d","edgeDepth","occluded","testOcclusion","raycaster","Raycaster","toMidpoint","expectedDist","relEps","intersects","hit","optimizeEdges","unique","hashPoint","hashEdge","h1","h2","cleanupOrphanedEdges","maxExtension","vertexKey","vertices","endpoint","orphans","vertex","orphanPoint","otherPoint","len","cross","extensionsCount","processed","orphan","bestMatch","bestIntersection","bestDist","candidate","ix","iy","intersectDist","crosses1","segmentCrossesEdges","crosses2","totalLength","avgEdgeLength","snapThreshold","finalVertices","finalOrphans","snapCount","snapped","nearestOrphan","nearestDist","remainingOrphans","removeIsolatedEdges","vertexConnections","connectionsA","connectionsB","removed","excludeEdge1","excludeEdge2","d1x","d1y","d2x","d2y","computeHiddenLines","gridSize","occlusionEpsilon","skipOcclusion","edges3d","frontEdges","allEdges","edges2d","hash","processedEdges","splitEdges","cellKey","cellEdges","profileEdges","otherEdges","visibleOtherEdges","optimizedEdges","finalEdges","computeHiddenLinesMultiple","internalScale","allEdges3d","visibleHatch","threshold","hatch2d","constant","p0","a2d","b2d","c2d","classifySilhouettes","smoothFilteredEdges","cleanedEdges","optimizedFinal","totalLen","avgLen","perpX","perpY","leftHit","rayHitsAnyFace","rightHit","silCount","ox","oy","rayIntersectsTriangle","rdx","rdy","raySegmentIntersect","sdx","sdy","lop","SVGObject","node","Object3D","PlotterRenderer","_this","_svg","_silhouettes","_edges","_shading","_svgWidth","_svgHeight","_svgWidthHalf","_svgHeightHalf","_clearColor","Color","color","glRenderer","removeChildNodes","path","currentTheme","fillColor","allRegionBounds","spacingScale","minZ","maxZ","corners","corner","worldCorners","screenMinX","screenMaxX","screenMinY","screenMaxY","screenX","screenY","screenSize","canvasSize","holeRegions","lightDir","shadingOpts","frameBudgetMs","progressCallback","frameStartTime","regionStartTime","regionTimeBudget","scaledAxisSettings","rawAxisSettings","axis","settings","frontIdx","frontRegion","hatch","holeRegion","hatchTheme","hatchStroke","hatchIdx","start","end","resolve","excluded","edgeTheme","edgeStroke","Camera"],"mappings":"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"}