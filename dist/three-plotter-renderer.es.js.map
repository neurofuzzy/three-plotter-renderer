{"version":3,"file":"three-plotter-renderer.es.js","sources":["../src/gpu-silhouette.js","../src/perspective-hatch.js","../src/geom/geom.js","../src/analyzer.js","../src/optimize.js","../src/hidden-line.js","../src/plotter-renderer.js"],"sourcesContent":["/**\n * GPU Normal-Region Polygon Extraction\n * \n * Renders quantized normals to texture, uses connected component labeling\n * to find contiguous regions with same normal, then traces boundaries.\n * \n * This approach is:\n * - Fast (GPU parallel rendering)\n * - 3D-aware (normals from actual geometry)\n * - Produces clean polygons grouped by normal direction\n */\n\nimport {\n    WebGLRenderTarget,\n    MeshNormalMaterial,\n    MeshDepthMaterial,\n    ShaderMaterial,\n    RGBADepthPacking,\n    NearestFilter,\n    Vector2,\n    Vector3\n} from 'three';\n\n/**\n * @typedef {Object} NormalRegion\n * @property {Vector2[]} boundary - Closed boundary polygon points\n * @property {Vector3} normal - The normal direction for this region\n * @property {number} area - Region area in pixels\n * @property {number} regionId - Unique ID for this region\n */\n\n/**\n * Extract polygons grouped by normal direction\n * @param {WebGLRenderer} renderer\n * @param {Scene} scene\n * @param {Camera} camera\n * @param {Object} options\n * @returns {NormalRegion[]}\n */\nexport function extractNormalRegions(renderer, scene, camera, options = {}) {\n    const {\n        resolution = 2.0,        // Render at 2x for smooth boundaries\n        normalBuckets = 12,      // Quantize normals into N directions\n        minArea = 100,           // Minimum region area in pixels (at output scale)\n        simplifyTolerance = 2.0,\n        insetPixels = 0          // Inset boundaries by this many pixels (GPU erosion)\n    } = options;\n\n    const size = renderer.getSize(new Vector2());\n    const width = Math.floor(size.x * resolution);\n    const height = Math.floor(size.y * resolution);\n\n    // Scale inset by resolution\n    const insetAmount = Math.round(insetPixels * resolution);\n\n\n\n    // Step 1: Render normals and depth to textures\n    const normalPixels = renderNormals(renderer, scene, camera, width, height);\n    const depthPixels = renderDepth(renderer, scene, camera, width, height);\n\n    // Step 2: Quantize normals to region IDs\n    const { regionMap, normalLookup } = quantizeNormals(normalPixels, width, height, normalBuckets);\n\n    // Step 3: Connected component labeling on ORIGINAL (non-eroded) regions\n    // This gives us the true silhouette boundaries\n    const { labels, regionCount } = connectedComponents(regionMap, width, height);\n\n    // Step 3.5: Apply erosion for insetting (only affects hatch clipping, not boundaries)\n    let erodedRegionMap = regionMap;\n    if (insetAmount > 0) {\n        erodedRegionMap = erodeRegionMap(regionMap, width, height, insetAmount);\n    }\n\n    // Step 4: Trace boundaries for each region (using ORIGINAL labels, not eroded)\n    const regions = [];\n    for (let regionId = 1; regionId <= regionCount; regionId++) {\n        const boundary = traceBoundary(labels, width, height, regionId);\n        if (boundary.length < 3) continue;\n\n        // Simplify boundary\n        const simplified = rdpSimplify(boundary, simplifyTolerance);\n        const area = Math.abs(polygonArea(simplified));\n\n        if (area < minArea) continue;\n\n\n        // Find the normal for this region (sample from center)\n        const normal = findRegionNormal(labels, regionMap, normalLookup, width, height, regionId);\n\n        // Sample depth at region center\n        const depth = sampleRegionDepth(labels, depthPixels, width, height, regionId);\n\n        regions.push({\n            boundary: simplified.map(p => new Vector2(\n                (p.x / resolution) - size.x / 2,\n                (p.y / resolution) - size.y / 2  // Y already flipped during readback\n            )),\n            normal,\n            depth,  // 0-1 normalized depth\n            area: area / (resolution * resolution),\n            regionId\n        });\n    }\n\n\n    return regions;\n}\n\n/**\n * Render normals to pixel buffer\n */\nfunction renderNormals(renderer, scene, camera, width, height) {\n    const target = new WebGLRenderTarget(width, height, {\n        minFilter: NearestFilter,\n        magFilter: NearestFilter\n    });\n\n    // Use MeshNormalMaterial for normal extraction\n    // Note: This outputs VIEW SPACE normals, not world space\n    const normalMaterial = new MeshNormalMaterial({ flatShading: true });\n\n    const originalMaterials = new Map();\n    const hiddenObjects = [];\n\n    scene.traverse(obj => {\n        // Only render Mesh objects, hide helpers/lines\n        if (obj.isMesh) {\n            originalMaterials.set(obj, obj.material);\n            obj.material = normalMaterial;\n        } else if (obj.isLineSegments || obj.isLine || obj.isPoints) {\n            // Hide grid helpers, line helpers, etc.\n            if (obj.visible) {\n                hiddenObjects.push(obj);\n                obj.visible = false;\n            }\n        }\n    });\n\n    renderer.setRenderTarget(target);\n    renderer.render(scene, camera);\n\n    scene.traverse(obj => {\n        if (obj.isMesh && originalMaterials.has(obj)) {\n            obj.material = originalMaterials.get(obj);\n        }\n    });\n\n    // Restore hidden objects (grid helpers, lines, etc.)\n    for (const obj of hiddenObjects) {\n        obj.visible = true;\n    }\n\n    renderer.setRenderTarget(null);\n\n    const pixels = new Uint8Array(width * height * 4);\n    renderer.readRenderTargetPixels(target, 0, 0, width, height, pixels);\n\n    target.dispose();\n    normalMaterial.dispose();\n\n    return pixels;\n}\n\n/**\n * Render depth to pixel buffer\n */\nfunction renderDepth(renderer, scene, camera, width, height) {\n    const target = new WebGLRenderTarget(width, height, {\n        minFilter: NearestFilter,\n        magFilter: NearestFilter\n    });\n\n    const depthMaterial = new MeshDepthMaterial({ depthPacking: RGBADepthPacking });\n\n    const originalMaterials = new Map();\n    const hiddenObjects = [];\n\n    scene.traverse(obj => {\n        if (obj.isMesh) {\n            originalMaterials.set(obj, obj.material);\n            obj.material = depthMaterial;\n        } else if (obj.isLineSegments || obj.isLine || obj.isPoints) {\n            if (obj.visible) {\n                hiddenObjects.push(obj);\n                obj.visible = false;\n            }\n        }\n    });\n\n    renderer.setRenderTarget(target);\n    renderer.render(scene, camera);\n\n    scene.traverse(obj => {\n        if (obj.isMesh && originalMaterials.has(obj)) {\n            obj.material = originalMaterials.get(obj);\n        }\n    });\n\n    for (const obj of hiddenObjects) {\n        obj.visible = true;\n    }\n\n    renderer.setRenderTarget(null);\n\n    const pixels = new Uint8Array(width * height * 4);\n    renderer.readRenderTargetPixels(target, 0, 0, width, height, pixels);\n\n    target.dispose();\n    depthMaterial.dispose();\n\n    return pixels;\n}\n\n/**\n * Sample average depth for a region\n */\nfunction sampleRegionDepth(labels, depthPixels, width, height, targetLabel) {\n    let sum = 0, count = 0;\n\n    for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n            if (labels[y * width + x] === targetLabel) {\n                const idx = (y * width + x) * 4;\n                // Unpack RGBA depth\n                const r = depthPixels[idx] / 255;\n                const g = depthPixels[idx + 1] / 255;\n                const b = depthPixels[idx + 2] / 255;\n                const a = depthPixels[idx + 3] / 255;\n                const depth = r + g / 256 + b / 65536 + a / 16777216;\n                sum += depth;\n                count++;\n            }\n        }\n    }\n\n    return count > 0 ? sum / count : 0.5;\n}\n\n/**\n * Morphological erosion on region map\n * Only erodes pixels at the OUTER boundary (next to background 0)\n * Does NOT erode at boundaries between different regions (holes)\n */\nfunction erodeRegionMap(regionMap, width, height, iterations) {\n    let current = regionMap;\n\n    for (let iter = 0; iter < iterations; iter++) {\n        const next = new Uint16Array(current);  // Start with copy\n\n        for (let y = 1; y < height - 1; y++) {\n            for (let x = 1; x < width - 1; x++) {\n                const i = y * width + x;\n                const region = current[i];\n\n                if (region === 0) continue;\n\n                // Check 4-connected neighbors\n                // Only erode if ANY neighbor is background (0)\n                // Don't erode if neighbors are just different regions\n                const left = current[i - 1];\n                const right = current[i + 1];\n                const up = current[i - width];\n                const down = current[i + width];\n\n                if (left === 0 || right === 0 || up === 0 || down === 0) {\n                    next[i] = 0;  // Erode this pixel (it touches background)\n                }\n                // else: keep the pixel even if it touches other regions\n            }\n        }\n\n        current = next;\n    }\n\n    return current;\n}\n\n/**\n * Quantize normals into buckets and create region map\n * Returns regionMap (pixel -> regionId) and normalLookup (regionId -> Vector3)\n */\nfunction quantizeNormals(pixels, width, height, buckets) {\n    const regionMap = new Uint16Array(width * height);\n    const normalLookup = {}; // regionId -> Vector3 normal\n    let nextId = 1;\n    const normalToId = {}; // quantized normal string -> regionId\n\n    for (let i = 0; i < width * height; i++) {\n        const idx = i * 4;\n        const r = pixels[idx];\n        const g = pixels[idx + 1];\n        const b = pixels[idx + 2];\n\n        // Background check (black = no geometry)\n        if (r < 5 && g < 5 && b < 5) {\n            regionMap[i] = 0; // Background\n            continue;\n        }\n\n        // Decode normal from RGB (MeshNormalMaterial encodes: (n+1)/2 * 255)\n        const nx = (r / 255) * 2 - 1;\n        const ny = (g / 255) * 2 - 1;\n        const nz = (b / 255) * 2 - 1;\n\n        // Round RGB to nearest 4 for tolerance at grazing angles\n        // This groups very similar normals together to avoid sub-pixel noise\n        const tolerance = 4;\n        const qr = Math.round(r / tolerance) * tolerance;\n        const qg = Math.round(g / tolerance) * tolerance;\n        const qb = Math.round(b / tolerance) * tolerance;\n        const key = `${qr}|${qg}|${qb}`;\n\n        if (!normalToId[key]) {\n            normalToId[key] = nextId;\n            normalLookup[nextId] = new Vector3(nx, ny, nz).normalize();\n            nextId++;\n        }\n\n        regionMap[i] = normalToId[key];\n    }\n\n    return { regionMap, normalLookup };\n}\n\n/**\n * Connected component labeling using union-find\n */\nfunction connectedComponents(regionMap, width, height) {\n    const labels = new Uint32Array(width * height);\n    const parent = [];\n    let nextLabel = 1;\n\n    function find(x) {\n        if (parent[x] !== x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    function union(x, y) {\n        const px = find(x);\n        const py = find(y);\n        if (px !== py) {\n            parent[py] = px;\n        }\n    }\n\n    // First pass: assign labels\n    for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n            const i = y * width + x;\n            const region = regionMap[i];\n\n            if (region === 0) continue; // Background\n\n            const neighbors = [];\n\n            // Check left neighbor\n            if (x > 0 && regionMap[i - 1] === region && labels[i - 1] > 0) {\n                neighbors.push(labels[i - 1]);\n            }\n            // Check top neighbor\n            if (y > 0 && regionMap[i - width] === region && labels[i - width] > 0) {\n                neighbors.push(labels[i - width]);\n            }\n\n            if (neighbors.length === 0) {\n                // New label\n                labels[i] = nextLabel;\n                parent[nextLabel] = nextLabel;\n                nextLabel++;\n            } else {\n                // Use minimum neighbor label\n                const minLabel = Math.min(...neighbors);\n                labels[i] = minLabel;\n                // Union all neighbors\n                for (const n of neighbors) {\n                    union(minLabel, n);\n                }\n            }\n        }\n    }\n\n    // Second pass: flatten labels\n    const labelRemap = {};\n    let finalLabel = 0;\n\n    for (let i = 0; i < width * height; i++) {\n        if (labels[i] === 0) continue;\n        const root = find(labels[i]);\n        if (labelRemap[root] === undefined) {\n            finalLabel++;\n            labelRemap[root] = finalLabel;\n        }\n        labels[i] = labelRemap[root];\n    }\n\n    return { labels, regionCount: finalLabel };\n}\n\n/**\n * Trace boundary of a labeled region using Moore neighborhood\n */\nfunction traceBoundary(labels, width, height, targetLabel) {\n    const boundary = [];\n\n    // Find starting point (leftmost pixel on top row of region)\n    let startX = -1, startY = -1;\n    outer: for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n            if (labels[y * width + x] === targetLabel) {\n                // Check if it's on boundary (has non-region neighbor)\n                const hasEdge =\n                    x === 0 || labels[y * width + x - 1] !== targetLabel ||\n                    y === 0 || labels[(y - 1) * width + x] !== targetLabel;\n                if (hasEdge) {\n                    startX = x;\n                    startY = y;\n                    break outer;\n                }\n            }\n        }\n    }\n\n    if (startX === -1) return boundary;\n\n    // Moore neighborhood: 8 directions clockwise from right\n    const dx = [1, 1, 0, -1, -1, -1, 0, 1];\n    const dy = [0, 1, 1, 1, 0, -1, -1, -1];\n\n    let x = startX, y = startY;\n    let dir = 7; // Start looking up-right\n    const maxIter = width * height * 2;\n    let iter = 0;\n\n    do {\n        boundary.push({ x, y });\n\n        // Find next boundary pixel\n        let found = false;\n        for (let i = 0; i < 8; i++) {\n            const checkDir = (dir + 6 + i) % 8; // Start from dir-2 (backtrack)\n            const nx = x + dx[checkDir];\n            const ny = y + dy[checkDir];\n\n            if (nx >= 0 && nx < width && ny >= 0 && ny < height) {\n                if (labels[ny * width + nx] === targetLabel) {\n                    x = nx;\n                    y = ny;\n                    dir = checkDir;\n                    found = true;\n                    break;\n                }\n            }\n        }\n\n        if (!found) break;\n        iter++;\n    } while ((x !== startX || y !== startY) && iter < maxIter);\n\n    return boundary;\n}\n\n/**\n * Find representative normal for a region\n */\nfunction findRegionNormal(labels, regionMap, normalLookup, width, height, targetLabel) {\n    // Find center of region and sample normal\n    let sumX = 0, sumY = 0, count = 0;\n    for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n            if (labels[y * width + x] === targetLabel) {\n                sumX += x;\n                sumY += y;\n                count++;\n            }\n        }\n    }\n\n    if (count === 0) return new Vector3(0, 0, 1);\n\n    const cx = Math.round(sumX / count);\n    const cy = Math.round(sumY / count);\n    const i = cy * width + cx;\n    const normalId = regionMap[i];\n\n    return normalLookup[normalId] || new Vector3(0, 0, 1);\n}\n\n/**\n * Ramer-Douglas-Peucker simplification\n */\nfunction rdpSimplify(points, epsilon) {\n    if (points.length < 3) return points;\n\n    let maxDist = 0, maxIdx = 0;\n    const first = points[0];\n    const last = points[points.length - 1];\n\n    for (let i = 1; i < points.length - 1; i++) {\n        const dist = perpendicularDistance(points[i], first, last);\n        if (dist > maxDist) {\n            maxDist = dist;\n            maxIdx = i;\n        }\n    }\n\n    if (maxDist > epsilon) {\n        const left = rdpSimplify(points.slice(0, maxIdx + 1), epsilon);\n        const right = rdpSimplify(points.slice(maxIdx), epsilon);\n        return left.slice(0, -1).concat(right);\n    } else {\n        return [first, last];\n    }\n}\n\nfunction perpendicularDistance(point, lineStart, lineEnd) {\n    const dx = lineEnd.x - lineStart.x;\n    const dy = lineEnd.y - lineStart.y;\n    const lenSq = dx * dx + dy * dy;\n    if (lenSq < 1e-10) {\n        return Math.sqrt((point.x - lineStart.x) ** 2 + (point.y - lineStart.y) ** 2);\n    }\n    // Clamp t to [0,1] to get distance to segment, not infinite line\n    let t = ((point.x - lineStart.x) * dx + (point.y - lineStart.y) * dy) / lenSq;\n    t = Math.max(0, Math.min(1, t));\n    const projX = lineStart.x + t * dx;\n    const projY = lineStart.y + t * dy;\n    return Math.sqrt((point.x - projX) ** 2 + (point.y - projY) ** 2);\n}\n\nfunction polygonArea(points) {\n    let area = 0;\n    for (let i = 0; i < points.length; i++) {\n        const j = (i + 1) % points.length;\n        area += points[i].x * points[j].y;\n        area -= points[j].x * points[i].y;\n    }\n    return area / 2;\n}\n\n/**\n * Debug visualization: show normal regions colored by their normal direction\n */\nexport function debugNormalRegions(renderer, scene, camera) {\n    const size = renderer.getSize(new Vector2());\n    const width = Math.floor(size.x);\n    const height = Math.floor(size.y);\n\n    const normalPixels = renderNormals(renderer, scene, camera, width, height);\n    const { regionMap, normalLookup } = quantizeNormals(normalPixels, width, height, 12);\n    const { labels, regionCount } = connectedComponents(regionMap, width, height);\n\n\n\n    // Create visualization\n    const canvas = document.createElement('canvas');\n    canvas.width = width;\n    canvas.height = height;\n    const ctx = canvas.getContext('2d');\n    const imageData = ctx.createImageData(width, height);\n\n    // Generate colors for each region\n    const regionColors = {};\n    for (let i = 1; i <= regionCount; i++) {\n        const hue = (i * 137.508) % 360; // Golden angle for good distribution\n        regionColors[i] = hslToRgb(hue / 360, 0.7, 0.5);\n    }\n\n    for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n            const srcIdx = (height - 1 - y) * width + x;\n            const dstIdx = (y * width + x) * 4;\n            const label = labels[srcIdx];\n\n            if (label === 0) {\n                imageData.data[dstIdx] = 30;\n                imageData.data[dstIdx + 1] = 30;\n                imageData.data[dstIdx + 2] = 30;\n            } else {\n                const [r, g, b] = regionColors[label] || [128, 128, 128];\n                imageData.data[dstIdx] = r;\n                imageData.data[dstIdx + 1] = g;\n                imageData.data[dstIdx + 2] = b;\n            }\n            imageData.data[dstIdx + 3] = 255;\n        }\n    }\n    ctx.putImageData(imageData, 0, 0);\n\n    // Show modal\n    const modal = document.createElement('div');\n    modal.style.cssText = 'position:fixed;top:0;left:0;width:100vw;height:100vh;background:rgba(0,0,0,0.8);display:flex;align-items:center;justify-content:center;z-index:10000;cursor:pointer;';\n    modal.onclick = () => modal.remove();\n    canvas.style.cssText = 'max-width:90vw;max-height:90vh;border:2px solid lime;';\n    const info = document.createElement('div');\n    info.style.cssText = 'position:absolute;top:20px;left:20px;color:lime;font-family:monospace;';\n    info.textContent = `${regionCount} regions, ${Object.keys(normalLookup).length} normal buckets (click to close)`;\n    modal.appendChild(canvas);\n    modal.appendChild(info);\n    document.body.appendChild(modal);\n}\n\nfunction hslToRgb(h, s, l) {\n    let r, g, b;\n    if (s === 0) {\n        r = g = b = l;\n    } else {\n        const hue2rgb = (p, q, t) => {\n            if (t < 0) t += 1;\n            if (t > 1) t -= 1;\n            if (t < 1 / 6) return p + (q - p) * 6 * t;\n            if (t < 1 / 2) return q;\n            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n            return p;\n        };\n        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n        const p = 2 * l - q;\n        r = hue2rgb(p, q, h + 1 / 3);\n        g = hue2rgb(p, q, h);\n        b = hue2rgb(p, q, h - 1 / 3);\n    }\n    return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];\n}\n","/**\n * Perspective Hatching\n * \n * Generates architect-style perspective hatches that converge toward\n * vanishing points based on face orientation.\n */\n\nimport { Vector2, Vector3 } from 'three';\n\n/**\n * @typedef {Object} HatchLine\n * @property {Vector2} start\n * @property {Vector2} end\n */\n\n/**\n * Compute the 2D hatch direction for a face based on its normal\n * Projects the face's primary axis to screen space\n * @param {Vector3} normal - Face normal in world space\n * @param {Camera} camera - Three.js camera\n * @param {number} screenWidth\n * @param {number} screenHeight\n * @returns {{direction: Vector2, vanishingPoint: Vector2|null}}\n */\nexport function computeHatchDirection(normal, camera, screenWidth, screenHeight) {\n    const halfW = screenWidth / 2;\n    const halfH = screenHeight / 2;\n\n    // Find a primary axis direction in the face plane\n    // For most faces, use the horizontal (XZ) direction projected onto the face\n    const worldUp = new Vector3(0, 1, 0);\n    const worldForward = new Vector3(0, 0, 1);\n\n    // Get a vector in the face plane\n    let faceAxis;\n\n    // For horizontal faces (floor/ceiling), use world Z direction\n    if (Math.abs(normal.y) > 0.9) {\n        faceAxis = worldForward.clone();\n    } else {\n        // For vertical/angled faces, use horizontal direction in face plane\n        // This is the cross product of normal with world up, gives horizontal direction in face\n        faceAxis = new Vector3().crossVectors(worldUp, normal).normalize();\n\n        // If face is vertical and facing up/down, cross product might be zero\n        if (faceAxis.lengthSq() < 0.01) {\n            faceAxis = worldForward.clone();\n        }\n    }\n\n    // Project two points along this axis to screen to get 2D direction\n    const origin = new Vector3(0, 0, 0);\n    const farPoint = faceAxis.clone().multiplyScalar(100);\n\n    const originScreen = origin.clone().project(camera);\n    const farScreen = farPoint.clone().project(camera);\n\n    // Convert to screen pixels\n    const screenOrigin = new Vector2(\n        originScreen.x * halfW,\n        -originScreen.y * halfH\n    );\n    const screenFar = new Vector2(\n        farScreen.x * halfW,\n        -farScreen.y * halfH\n    );\n\n    // 2D direction on screen\n    const direction = screenFar.clone().sub(screenOrigin).normalize();\n\n    // Compute vanishing point by projecting point at infinity along this direction\n    // VP is where parallel 3D lines converge in 2D\n    const veryFarPoint = faceAxis.clone().multiplyScalar(100000);\n    const vpProjected = veryFarPoint.clone().project(camera);\n\n    // Check if VP is visible/finite\n    let vanishingPoint = null;\n    if (Math.abs(vpProjected.x) < 100 && Math.abs(vpProjected.y) < 100 && vpProjected.z < 1) {\n        vanishingPoint = new Vector2(\n            vpProjected.x * halfW,\n            -vpProjected.y * halfH\n        );\n    }\n\n    return { direction, vanishingPoint };\n}\n\n/**\n * Generate perspective hatch lines for a region\n * @param {Object} region - Region from extractNormalRegions\n * @param {Camera} camera\n * @param {Object} options\n * @returns {HatchLine[]}\n */\nexport function generatePerspectiveHatches(region, camera, options = {}) {\n    const {\n        baseSpacing = 8,      // Base spacing in screen pixels\n        minSpacing = 3,       // Minimum spacing\n        maxSpacing = 20,      // Maximum spacing\n        depthFactor = 0.5,    // How much depth affects density\n        screenWidth = 1200,\n        screenHeight = 800,\n        axisSettings = {}     // { x: { rotation: 0, spacing: 10 }, y: ... }\n    } = options;\n\n    const { boundary, normal, depth = 0.5 } = region;\n    if (boundary.length < 3) return [];\n\n    // Determine dominant axis\n    const ax = Math.abs(normal.x);\n    const ay = Math.abs(normal.y);\n    const az = Math.abs(normal.z);\n\n    let axis = 'y'; // default up\n    if (ax >= ay && ax >= az) axis = 'x';\n    else if (az >= ay && az >= ax) axis = 'z';\n\n    // Get settings for this axis\n    const settings = axisSettings[axis] || {};\n    const rotationDeg = settings.rotation || 0;\n    const spacingOverride = settings.spacing;\n\n    console.log(`[Hatch] normal=(${normal.x.toFixed(2)}, ${normal.y.toFixed(2)}, ${normal.z.toFixed(2)}) => axis=${axis}, rotation=${rotationDeg}, spacing=${spacingOverride}`);\n\n    // Get hatch direction from normal\n    const { direction, vanishingPoint } = computeHatchDirection(\n        normal, camera, screenWidth, screenHeight\n    );\n\n    // Apply rotation if needed\n    let finalDirection = direction;\n    if (rotationDeg !== 0) {\n        const rad = rotationDeg * (Math.PI / 180);\n        const cos = Math.cos(rad);\n        const sin = Math.sin(rad);\n        finalDirection = new Vector2(\n            direction.x * cos - direction.y * sin,\n            direction.x * sin + direction.y * cos\n        );\n    }\n\n    // Perpendicular direction for spacing\n    const perpDir = new Vector2(-finalDirection.y, finalDirection.x);\n\n    // Calculate spacing based on depth (closer = denser)\n    // Use override if available, otherwise baseSpacing\n    const effectiveBase = spacingOverride !== undefined ? spacingOverride : baseSpacing;\n    const spacing = Math.max(minSpacing, Math.min(maxSpacing,\n        effectiveBase + (depth * depthFactor * (maxSpacing - minSpacing))\n    ));\n\n    // Get bounding box of region\n    let minX = Infinity, maxX = -Infinity;\n    let minY = Infinity, maxY = -Infinity;\n    for (const pt of boundary) {\n        minX = Math.min(minX, pt.x);\n        maxX = Math.max(maxX, pt.x);\n        minY = Math.min(minY, pt.y);\n        maxY = Math.max(maxY, pt.y);\n    }\n\n    const centerX = (minX + maxX) / 2;\n    const centerY = (minY + maxY) / 2;\n    const center = new Vector2(centerX, centerY);\n\n    // Size of region along perpendicular direction\n    const diag = Math.sqrt((maxX - minX) ** 2 + (maxY - minY) ** 2);\n\n    const hatches = [];\n\n    // If rotated, we can't easily use the VP logic unless we rotate the VP too, \n    // but typically architectural hatching with rotation implies a pattern override, \n    // so we'll often fall back to parallel for rotated patterns unless it's 0/90.\n    // For now, if rotation is significant, force parallel to avoid weird VP artifacts.\n    // OR: Rotate the vector from VP to center? \n    // Let's stick to parallel for significantly rotated hatches to keep it clean for now,\n    // as \"perspective rotated hatching\" is geometrically ambiguous.\n    const usePerspective = vanishingPoint && Math.abs(rotationDeg) < 5 && vanishingPoint.distanceTo(center) < diag * 5;\n\n    if (usePerspective) {\n        // Perspective lines converging to visible VP\n        const vpDist = vanishingPoint.distanceTo(center);\n\n        // Generate lines radiating from VP\n        const numLines = Math.ceil(diag / spacing) * 2;\n        const angularSpan = Math.atan2(diag, vpDist);\n        const angleStep = angularSpan * 2 / numLines;\n\n        // Angle from VP to center\n        const centerAngle = Math.atan2(\n            centerY - vanishingPoint.y,\n            centerX - vanishingPoint.x\n        );\n\n        for (let i = -numLines; i <= numLines; i++) {\n            const angle = centerAngle + i * angleStep;\n            const dir = new Vector2(Math.cos(angle), Math.sin(angle));\n\n            // Line from VP extending far past region\n            const lineStart = vanishingPoint.clone();\n            const lineEnd = vanishingPoint.clone().add(dir.clone().multiplyScalar(vpDist * 10));\n\n            const clipped = clipLineToPolygon({ start: lineStart, end: lineEnd }, boundary);\n            hatches.push(...clipped);\n        }\n    } else {\n        // Parallel lines (VP at infinity or very far)\n        const numLines = Math.ceil(diag / spacing) + 2;\n\n        for (let i = -numLines; i <= numLines; i++) {\n            // Offset along perpendicular direction\n            const offset = perpDir.clone().multiplyScalar(i * spacing);\n            const lineCenter = center.clone().add(offset);\n\n            // Line extending in hatch direction\n            const lineStart = lineCenter.clone().add(finalDirection.clone().multiplyScalar(-diag));\n            const lineEnd = lineCenter.clone().add(finalDirection.clone().multiplyScalar(diag));\n\n            const clipped = clipLineToPolygon({ start: lineStart, end: lineEnd }, boundary);\n            hatches.push(...clipped);\n        }\n    }\n\n    return hatches;\n}\n\n/**\n * Clip a line to a polygon\n */\nexport function clipLineToPolygon(line, polygon) {\n    const intersections = [];\n    const n = polygon.length;\n\n    for (let i = 0; i < n; i++) {\n        const p1 = polygon[i];\n        const p2 = polygon[(i + 1) % n];\n\n        const intersection = lineIntersection(\n            line.start.x, line.start.y, line.end.x, line.end.y,\n            p1.x, p1.y, p2.x, p2.y\n        );\n\n        if (intersection) {\n            intersections.push({\n                point: new Vector2(intersection.x, intersection.y),\n                t: intersection.t\n            });\n        }\n    }\n\n    if (intersections.length < 2) return [];\n\n    // Sort by parameter along line\n    intersections.sort((a, b) => a.t - b.t);\n\n    // Create segments between consecutive pairs, checking midpoint is inside\n    const result = [];\n    for (let i = 0; i < intersections.length - 1; i++) {\n        const midX = (intersections[i].point.x + intersections[i + 1].point.x) / 2;\n        const midY = (intersections[i].point.y + intersections[i + 1].point.y) / 2;\n\n        if (pointInPolygon(midX, midY, polygon)) {\n            result.push({\n                start: intersections[i].point,\n                end: intersections[i + 1].point\n            });\n        }\n    }\n\n    return result;\n}\n\n/**\n * Clip a line to OUTSIDE a polygon (inverse of clipLineToPolygon)\n * Returns segments that are OUTSIDE the polygon\n */\nexport function clipLineOutsidePolygon(line, polygon) {\n    const intersections = [];\n    const n = polygon.length;\n\n    // Add start and end points\n    const startInside = pointInPolygon(line.start.x, line.start.y, polygon);\n    const endInside = pointInPolygon(line.end.x, line.end.y, polygon);\n\n    intersections.push({ point: line.start.clone(), t: 0, inside: startInside });\n\n    // Find all intersections with polygon edges\n    for (let i = 0; i < n; i++) {\n        const p1 = polygon[i];\n        const p2 = polygon[(i + 1) % n];\n\n        const intersection = lineIntersectionFull(\n            line.start.x, line.start.y, line.end.x, line.end.y,\n            p1.x, p1.y, p2.x, p2.y\n        );\n\n        if (intersection && intersection.t > 0 && intersection.t < 1) {\n            intersections.push({\n                point: new Vector2(intersection.x, intersection.y),\n                t: intersection.t,\n                inside: null // will be determined by neighbors\n            });\n        }\n    }\n\n    intersections.push({ point: line.end.clone(), t: 1, inside: endInside });\n\n    // Sort by parameter\n    intersections.sort((a, b) => a.t - b.t);\n\n    // Remove duplicates (points too close together)\n    const filtered = [intersections[0]];\n    for (let i = 1; i < intersections.length; i++) {\n        if (intersections[i].t - filtered[filtered.length - 1].t > 0.0001) {\n            filtered.push(intersections[i]);\n        }\n    }\n\n    if (filtered.length < 2) return [line]; // No intersections, check if line is outside\n\n    // Build segments that are OUTSIDE\n    const result = [];\n    for (let i = 0; i < filtered.length - 1; i++) {\n        const midT = (filtered[i].t + filtered[i + 1].t) / 2;\n        const midX = line.start.x + midT * (line.end.x - line.start.x);\n        const midY = line.start.y + midT * (line.end.y - line.start.y);\n\n        // If midpoint is OUTSIDE polygon, include this segment\n        if (!pointInPolygon(midX, midY, polygon)) {\n            result.push({\n                start: filtered[i].point.clone(),\n                end: filtered[i + 1].point.clone()\n            });\n        }\n    }\n\n    return result;\n}\n\n// Full line intersection (both segments)\nfunction lineIntersectionFull(x1, y1, x2, y2, x3, y3, x4, y4) {\n    const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n    if (Math.abs(denom) < 1e-10) return null;\n\n    const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;\n    const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;\n\n    if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {\n        return {\n            x: x1 + t * (x2 - x1),\n            y: y1 + t * (y2 - y1),\n            t\n        };\n    }\n    return null;\n}\n\nfunction lineIntersection(x1, y1, x2, y2, x3, y3, x4, y4) {\n    const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n    if (Math.abs(denom) < 1e-10) return null;\n\n    const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;\n    const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;\n\n    if (u >= 0 && u <= 1) {\n        return {\n            x: x1 + t * (x2 - x1),\n            y: y1 + t * (y2 - y1),\n            t\n        };\n    }\n    return null;\n}\n\nfunction pointInPolygon(x, y, polygon) {\n    let inside = false;\n    const n = polygon.length;\n\n    for (let i = 0, j = n - 1; i < n; j = i++) {\n        const xi = polygon[i].x, yi = polygon[i].y;\n        const xj = polygon[j].x, yj = polygon[j].y;\n\n        if (((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) {\n            inside = !inside;\n        }\n    }\n\n    return inside;\n}\n","const EPSILON = 0.001;\n\nexport class Point {\n  /**\n   * @param {number} x\n   * @param {number} y\n   */\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n  /**\n   * @param {Point} pt\n   */\n  static clone(pt) {\n    return new Point(pt.x, pt.y);\n  }\n}\n\nexport class BoundingBox {\n  /**\n   * @param {number} minX\n   * @param {number} minY\n   * @param {number} maxX\n   * @param {number} maxY\n   */\n  constructor(minX, minY, maxX, maxY) {\n    this.minX = minX;\n    this.minY = minY;\n    this.maxX = maxX;\n    this.maxY = maxY;\n  }\n  width() {\n    return Math.abs(this.maxX - this.minX);\n  }\n  height() {\n    return Math.abs(this.maxY - this.minY);\n  }\n}\n\nexport class BoundingCircle {\n  /**\n   *\n   * @param {number} r radius\n   */\n  constructor(r = 0) {\n    this.r = r;\n  }\n}\n\nexport class Segment {\n  /**\n   *\n   * @param {Point} a start point\n   * @param {Point} b end point\n   */\n  constructor(a, b) {\n    this.a = a;\n    this.b = b;\n    this.tags = {};\n  }\n\n  /**\n   *\n   * @param {Segment} segA\n   * @param {Segment} segB\n   */\n  static isEqual(segA, segB) {\n    return (\n      (GeomUtil.pointsEqual(segA.a, segB.a) && GeomUtil.pointsEqual(segA.b, segB.b)) ||\n      (GeomUtil.pointsEqual(segA.b, segB.a) && GeomUtil.pointsEqual(segA.a, segB.b))\n    );\n  }\n\n  /**\n   * @param {Segment} seg\n   */\n  static clone(seg) {\n    return new Segment(new Point(seg.a.x, seg.a.y), new Point(seg.b.x, seg.b.y));\n  }\n}\n\nexport class SegmentCollection {\n  constructor() {\n    this.pivot = { x: 0, y: 0 };\n    this.rotation = 0;\n    this.isOpen = true;\n    this.isGroup = false;\n    this.isStrong = false;\n    /**\n     *\n     * @param {Point[]} pts\n     */\n    this._makeAbsolute = (pts) => {\n      let rot = (this.rotation * Math.PI) / 180;\n      pts.forEach((pt, idx) => {\n        const ptA = { x: pt.x, y: pt.y };\n        GeomUtil.rotatePoint(ptA, rot);\n        ptA.x += this.pivot.x;\n        ptA.y += this.pivot.y;\n        pts[idx] = ptA;\n      });\n    };\n    /**\n     *\n     * @param {Segment[]} segs\n     */\n    this._makeSegsAbsolute = (segs) => {\n      let rot = (this.rotation * Math.PI) / 180;\n      segs.forEach((seg) => {\n        const ptA = { x: seg.a.x, y: seg.a.y };\n        const ptB = { x: seg.b.x, y: seg.b.y };\n        GeomUtil.rotatePoint(ptA, rot);\n        GeomUtil.rotatePoint(ptB, rot);\n        GeomUtil.addToPoint(ptA, this.pivot);\n        GeomUtil.addToPoint(ptB, this.pivot);\n        seg.a = ptA;\n        seg.b = ptB;\n      });\n    };\n  }\n\n  /**\n   * @param {boolean} local\n   * @returns {Point[]}\n   */\n  toPoints(local = false) {\n    throw \"not implemented\";\n  }\n\n  /**\n   *\n   * @param {boolean} local\n   * @returns {Segment[]};\n   */\n  toSegments(local = false) {\n    throw \"not implemented\";\n  }\n\n  /**\n   *\n   * @param {boolean} local\n   * @returns {BoundingBox}\n   */\n  getBoundingBox(local = false) {\n    const bb = new BoundingBox(1000000, 1000000, -1000000, -1000000);\n    const pts = this.toPoints(local);\n    pts.forEach((pt) => {\n      bb.minX = Math.min(bb.minX, pt.x);\n      bb.minY = Math.min(bb.minY, pt.y);\n      bb.maxX = Math.max(bb.maxX, pt.x);\n      bb.maxY = Math.max(bb.maxY, pt.y);\n    });\n\n    return bb;\n  }\n\n  /**\n   * @returns {BoundingCircle}\n   */\n  getBoundingCircle() {\n    const bc = new BoundingCircle();\n    const pts = this.toPoints(true);\n    pts.forEach((pt) => {\n      bc.r = Math.max(bc.r, Math.sqrt(pt.x * pt.x + pt.y * pt.y));\n    });\n    return bc;\n  }\n}\n\nexport class Segments extends SegmentCollection {\n  /**\n   *\n   * @param {Segment[]} segments\n   */\n  constructor(segments) {\n    super();\n    /** @type {Segment[]} */\n    this._segments = segments;\n  }\n\n  /**\n   * @param {Segment[]} segs\n   */\n  add(...segs) {\n    this._segments = this._segments.concat(segs);\n  }\n\n  /**\n   * @param {boolean} local\n   * @returns {Point[]}\n   */\n  toPoints(local = false) {\n    return this.toSegments(local).reduce((arr, seg) => (seg ? arr.concat([seg.a, seg.b]) : arr), []);\n  }\n  /**\n   *\n   * @param {boolean} local\n   * @returns {Segment[]};\n   */\n  toSegments(local = false) {\n    let segs = this._segments.reduce((arr, seg) => (seg ? arr.concat(Segment.clone(seg)) : arr), []);\n    if (!local) {\n      this._makeSegsAbsolute(segs);\n    }\n    return segs;\n  }\n\n  bake() {\n    // noOp\n  }\n\n  result() {\n    return Segments.clone(this);\n  }\n\n  /**\n   *\n   * @param {Segments} segs\n   */\n  static clone(segs) {\n    let sA = segs._segments;\n    let sB = [];\n    let i = sA.length;\n    while (i--) {\n      sB.unshift(Segment.clone(sA[i]));\n    }\n    let s = new Segments(sB);\n    s.pivot.x = segs.pivot.x;\n    s.pivot.y = segs.pivot.y;\n    s.rotation = segs.rotation;\n    return s;\n  }\n}\n\nexport class GeomUtil {\n  /**\n   *\n   * @param {number} a\n   * @param {number} b\n   * @param {number} d\n   * @returns {number}\n   */\n  static lerp(a, b, d) {\n    return (1 - d) * a + d * b;\n  }\n\n  /**\n   *\n   * @param {Point} ptA\n   * @param {Point} ptB\n   */\n  static angleBetween(ptA, ptB) {\n    return Math.atan2(ptB.y - ptA.y, ptB.x - ptA.x);\n  }\n\n  /**\n   *\n   * @param {Segment} segA\n   * @param {Segment} segB\n   */\n  static sameAngle(segA, segB) {\n    let aA = GeomUtil.angleBetween(segA.a, segA.b);\n    let aB = GeomUtil.angleBetween(segB.a, segB.b);\n\n    return Math.abs(aA - aB) < EPSILON;\n  }\n\n  /**\n   *\n   * @param {Segment} segA\n   * @param {Segment} segB\n   */\n  static sameAngleRev(segA, segB) {\n    let aA = GeomUtil.angleBetween(segA.a, segA.b);\n    let aB = GeomUtil.angleBetween(segB.b, segB.a);\n\n    return Math.abs(aA - aB) < EPSILON;\n  }\n\n  /**\n   *\n   * @param {Point} ptA\n   * @param {Point} ptB\n   * @param {number} d\n   * @returns {Point}\n   */\n  static lerpPoints(ptA, ptB, d) {\n    return {\n      x: GeomUtil.lerp(ptA.x, ptB.x, d),\n      y: GeomUtil.lerp(ptA.y, ptB.y, d),\n    };\n  }\n\n  /**\n   *\n   * @param {Point} pt the point to rotate in place\n   * @param {number} deg angle in degrees\n   */\n  static rotatePointDeg(pt, deg) {\n    GeomUtil.rotatePoint(pt, (deg * Math.PI) / 180);\n  }\n\n  /**\n   *\n   * @param {Point} pt\n   * @param {*} rad\n   */\n  static rotatePoint(pt, rad) {\n    const cos = Math.cos(rad);\n    const sin = Math.sin(rad);\n\n    const oldY = pt.y;\n    const oldX = pt.x;\n\n    pt.y = cos * oldY - sin * oldX;\n    pt.x = sin * oldY + cos * oldX;\n  }\n\n  /**\n   *\n   * @param {number} rad\n   * @param  {...Point} points\n   */\n  static rotatePoints(rad, ...points) {\n    points.forEach((pt) => {\n      GeomUtil.rotatePoint(pt, rad);\n    });\n  }\n\n  /**\n   *\n   * @param {number} deg\n   * @param  {...Point} points\n   */\n  static rotatePointsDeg(deg, ...points) {\n    let rad = (deg * Math.PI) / 180;\n    points.forEach((pt) => {\n      GeomUtil.rotatePoint(pt, rad);\n    });\n  }\n\n  // Based on http://stackoverflow.com/a/12037737\n\n  static outerTangents(ptA, rA, ptB, rB) {\n    var dx = ptB.x - ptA.x;\n    var dy = ptB.y - ptA.y;\n    var dist = Math.sqrt(dx * dx + dy * dy);\n\n    if (dist <= Math.abs(rB - rA)) return []; // no valid tangents\n\n    // Rotation from x-axis\n    var angle1 = Math.atan2(dy, dx);\n    var angle2 = Math.acos((rA - rB) / dist);\n\n    return [\n      new Segment(\n        {\n          x: ptA.x + rA * Math.cos(angle1 + angle2),\n          y: ptA.y + rA * Math.sin(angle1 + angle2),\n        },\n        {\n          x: ptB.x + rB * Math.cos(angle1 + angle2),\n          y: ptB.y + rB * Math.sin(angle1 + angle2),\n        }\n      ),\n      new Segment(\n        {\n          x: ptA.x + rA * Math.cos(angle1 - angle2),\n          y: ptA.y + rA * Math.sin(angle1 - angle2),\n        },\n        {\n          x: ptB.x + rB * Math.cos(angle1 - angle2),\n          y: ptB.y + rB * Math.sin(angle1 - angle2),\n        }\n      ),\n    ];\n  }\n\n  /**\n   *\n   * @param {Point} pt\n   */\n  static cartesian2Polar(pt) {\n    const d = Math.sqrt(pt.x * pt.x + pt.y * pt.y);\n    const r = Math.atan2(pt.y, pt.x);\n    pt.x = d;\n    pt.y = r;\n  }\n\n  /**\n   *\n   * @param {Point} ptA\n   * @param {Point} ptB\n   * @param {number} [scale]\n   */\n  static pointsEqual(ptA, ptB, scale = 1) {\n    return (\n      Math.round(ptA.x * 10000 / scale) == Math.round(ptB.x * 10000 / scale) && Math.round(ptA.y * 10000 / scale) == Math.round(ptB.y * 10000 / scale)\n    );\n  }\n\n  /**\n   *\n   * @param {Point} ptA\n   * @param {Point} ptB\n   * @returns {number}\n   */\n  static distanceBetween(ptA, ptB) {\n    const dx = ptB.x - ptA.x;\n    const dy = ptB.y - ptA.y;\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n  /**\n   *\n   * @param {Point} ptA\n   * @param {Point} ptB\n   * @returns {number}\n   */\n  static distanceBetweenSquared(ptA, ptB) {\n    const dx = ptB.x - ptA.x;\n    const dy = ptB.y - ptA.y;\n    return dx * dx + dy * dy;\n  }\n\n  /**\n   *\n   * @param {Point} ptA\n   * @param {Point} ptB\n   * @param {number} numSegs\n   * @returns {Point[]}\n   */\n  static interpolatePoints(ptA, ptB, numSegs) {\n    let pts = [{ x: ptA.x, y: ptA.y }];\n    let perc = 1 / numSegs;\n    let deltaX = (ptB.x - ptA.x) * perc;\n    let deltaY = (ptB.y - ptA.y) * perc;\n    for (var i = 1; i < numSegs; i++) {\n      pts.push(new Point(ptA.x + deltaX * i, ptA.y + deltaY * i));\n    }\n    pts.push({ x: ptB.x, y: ptB.y });\n    return pts;\n  }\n\n  /**\n   *\n   * @param  {...Point} pts\n   */\n  static averagePoints(...pts) {\n    let a = new Point(0, 0);\n    pts.forEach((pt) => {\n      a.x += pt.x;\n      a.y += pt.y;\n    });\n    a.x /= pts.length;\n    a.y /= pts.length;\n    return a;\n  }\n\n  /**\n   *\n   * @param {Point} targetPt the point that will be added to\n   * @param {Point} sourcePt the point to add to the target\n   */\n  static addToPoint(targetPt, sourcePt) {\n    targetPt.x += sourcePt.x;\n    targetPt.y += sourcePt.y;\n  }\n\n  /**\n   *\n   * @param {Point} targetPt the point that will be subtracted from\n   * @param {Point} sourcePt the point tosubtract from the target\n   */\n  static subFromPoint(targetPt, sourcePt) {\n    targetPt.x -= sourcePt.x;\n    targetPt.y -= sourcePt.y;\n  }\n\n  /**\n   *\n   * @param {Point} ptA\n   * @param {Point} ptB\n   * @param {number} delta\n   * @returns {Point[]}\n   */\n  static subdivideByDistance(ptA, ptB, delta) {\n    if (delta === 0) {\n      return [ptA, ptB];\n    }\n    let pts = [{ x: ptA.x, y: ptA.y }];\n    let dist = GeomUtil.distanceBetween(ptA, ptB);\n    let perc = delta / dist;\n    let numFit = Math.floor(1 / perc);\n    let remain = dist % delta;\n    delta += remain / numFit;\n    perc = delta / dist;\n    let travel = perc;\n    let i = 1;\n    let deltaX = (ptB.x - ptA.x) * perc;\n    let deltaY = (ptB.y - ptA.y) * perc;\n    while (travel < 1) {\n      pts.push(new Point(ptA.x + deltaX * i, ptA.y + deltaY * i));\n      travel += perc;\n      i++;\n    }\n    pts.push({ x: ptB.x, y: ptB.y });\n    return pts;\n  }\n\n  /**\n   *\n   * @param {Segment} segA\n   * @param {Segment} segB\n   * @param {number} [scale]\n   */\n  static segmentsConnected(segA, segB, scale = 1) {\n    return GeomUtil.pointsEqual(segA.b, segB.a, scale) || GeomUtil.pointsEqual(segA.a, segB.b, scale);\n  }\n\n  /**\n   *\n   * @param {Segment[]} segs\n   * @returns {Point[]}\n   */\n  static segmentsToPoints(segs) {\n    let pts = segs.reduce((arr, seg) => {\n      return arr.concat(seg.a, seg.b);\n    }, []);\n    let i = pts.length;\n    while (i--) {\n      let pt = pts[i];\n      if (i > 0 && GeomUtil.pointsEqual(pt, pts[i - 1])) {\n        pts.splice(i, 1);\n      }\n    }\n    return pts;\n  }\n\n  /**\n   *\n   * @param {Point[]} pts\n   * @returns {number}\n   */\n  static polygonArea(pts) {\n    let area = 0;\n    let j = pts.length - 1;\n    for (var i = 0; i < pts.length; i++) {\n      area += pts[i].x * pts[j].y;\n      area -= pts[j].x * pts[i].y;\n      j = i;\n    }\n    return area / 2;\n  }\n\n  /**\n   *\n   * @param {Point[]} pts\n   * @returns {BoundingBox}\n   */\n  static pointsBoundingBox(pts) {\n    const b = new BoundingBox(1000000, 1000000, -1000000, -1000000);\n\n    pts.forEach((pt) => {\n      b.minX = Math.min(b.minX, pt.x);\n      b.minY = Math.min(b.minY, pt.y);\n      b.maxX = Math.max(b.maxX, pt.x);\n      b.maxY = Math.max(b.maxY, pt.y);\n    });\n\n    return b;\n  }\n\n  /**\n   *\n   * @param {BoundingBox[]} bbs\n   * @returns {BoundingBox}\n   */\n  static boundingBoxesBoundingBox(bbs) {\n    const b = new BoundingBox(1000000, 1000000, -1000000, -1000000);\n\n    bbs.forEach((bb) => {\n      b.minX = Math.min(b.minX, bb.minX);\n      b.minY = Math.min(b.minY, bb.minY);\n      b.maxX = Math.max(b.maxX, bb.maxX);\n      b.maxY = Math.max(b.maxY, bb.maxY);\n    });\n\n    return b;\n  }\n\n  /**\n   *\n   * @param {Segment[]} segs\n   * @returns {BoundingBox}\n   */\n  static segmentsBoundingBox(segs) {\n    const pts = [];\n    segs.forEach((seg) => {\n      pts.push(seg.a);\n      pts.push(seg.b);\n    });\n    return GeomUtil.pointsBoundingBox(pts);\n  }\n\n  /**\n   *\n   * @param {BoundingBox} ab\n   * @param {BoundingBox} bb\n   */\n  static boundingBoxesIntersect(ab, bb) {\n    return ab.maxX >= bb.minX && ab.maxY >= bb.minY && ab.minX <= bb.maxX && ab.minY <= bb.maxY;\n  }\n\n  /**\n   *\n   * @param {Point[]} pts\n   * @returns {boolean}\n   */\n  static polygonIsClockwise(pts) {\n    return GeomUtil.polygonArea(pts) > 0;\n  }\n\n  /**\n   *\n   * @param {Point} p1\n   * @param {Point} p2\n   * @param {Point} p3\n   */\n  static ccw(p1, p2, p3) {\n    return (p3.y - p1.y) * (p2.x - p1.x) > (p2.y - p1.y) * (p3.x - p1.x);\n  }\n\n  /**\n   *\n   * @param {Segment} segA\n   * @param {Segment} segB\n   * @returns {boolean}\n   */\n  static segmentsIntersect(segA, segB) {\n    const fn = GeomUtil.ccw;\n    return (\n      fn(segA.a, segB.a, segB.b) != fn(segA.b, segB.a, segB.b) &&\n      fn(segA.a, segA.b, segB.a) != fn(segA.a, segA.b, segB.b)\n    );\n  }\n\n  /**\n   *\n   * @param {Segment} segA\n   * @param {Segment} segB\n   * @returns {Point}\n   */\n  static segmentSegmentIntersect(segA, segB, ignoreTouching = false) {\n    const x1 = segA.a.x;\n    const y1 = segA.a.y;\n    const x2 = segA.b.x;\n    const y2 = segA.b.y;\n    const x3 = segB.a.x;\n    const y3 = segB.a.y;\n    const x4 = segB.b.x;\n    const y4 = segB.b.y;\n\n    const s1_x = x2 - x1;\n    const s1_y = y2 - y1;\n    const s2_x = x4 - x3;\n    const s2_y = y4 - y3;\n\n    const s = (-s1_y * (x1 - x3) + s1_x * (y1 - y3)) / (-s2_x * s1_y + s1_x * s2_y);\n    const t = (s2_x * (y1 - y3) - s2_y * (x1 - x3)) / (-s2_x * s1_y + s1_x * s2_y);\n\n    if (s >= 0 && s <= 1 && t >= 0 && t <= 1) {\n      const atX = x1 + t * s1_x;\n      const atY = y1 + t * s1_y;\n      let intPt = { x: atX, y: atY };\n      if (ignoreTouching) {\n        if (GeomUtil.pointsEqual(intPt, segB.a) || GeomUtil.pointsEqual(intPt, segB.b)) {\n          return;\n        }\n        if (GeomUtil.pointsEqual(intPt, segA.a) || GeomUtil.pointsEqual(intPt, segA.b)) {\n          return;\n        }\n      }\n      return intPt;\n    }\n\n    return null;\n  }\n\n  /**\n   *\n   * @param {Segment} segA\n   * @param {Segment[]} segs\n   * @returns {Point[]}\n   */\n  static segmentSegmentsIntersections(segA, segs, ignoreTouching = false) {\n    let pts = [];\n    segs.forEach((seg) => {\n      if (seg == segA) {\n        return;\n      }\n      let intPt = GeomUtil.segmentSegmentIntersect(segA, seg, ignoreTouching);\n      if (intPt) {\n        pts.push(intPt);\n      }\n    });\n    return pts;\n  }\n\n  /**\n   *\n   * @param {Point} ptA\n   * @param {Point} ptB\n   */\n  static dot(ptA, ptB) {\n    return ptA.x * ptB.x + ptA.y * ptB.y;\n  }\n\n  /**\n   *\n   * @param {Point} ptA\n   * @param {Point} ptB\n   */\n  static cross(ptA, ptB) {\n    return ptA.x * ptB.y - ptA.y * ptB.x;\n  }\n\n  /**\n   * \n   * @param {Point} pt \n   * @param {Point} ptA \n   * @param {Point} ptB \n   */\n  static lineSide (pt, ptA, ptB) {\n    return Math.round(((ptB.x - ptA.x) * (pt.y - ptA.y) - (ptB.y - ptA.y) * (pt.x - ptA.x)) * 100) / 100;\n  }\n\n  /**\n   *\n   * @param {Point} ptA\n   * @param {Point} ptB\n   */\n  static sub(ptA, ptB) {\n    return new Point(ptA.x - ptB.x, ptA.y - ptB.y);\n  }\n\n  /**\n   *\n   * @param {Point} ptA\n   * @param {Point} ptB\n   */\n  static add(ptA, ptB) {\n    return new Point(ptA.x + ptB.x, ptA.y + ptB.y);\n  }\n\n  /**\n   *\n   * @param {Point} pt\n   * @param {Segment} seg\n   * @returns {Point}\n   */\n  static closestPtPointSegment(pt, seg) {\n    var ab = GeomUtil.sub(seg.b, seg.a);\n    var ca = GeomUtil.sub(pt, seg.a);\n    var t = GeomUtil.dot(ca, ab);\n\n    if (t < 0) {\n      pt = seg.a;\n    } else {\n      var denom = GeomUtil.dot(ab, ab);\n      if (t >= denom) {\n        pt = seg.b;\n      } else {\n        t /= denom;\n        // reuse ca\n        ca.x = seg.a.x + t * ab.x;\n        ca.y = seg.a.y + t * ab.y;\n        pt = ca;\n      }\n    }\n\n    return Point.clone(pt);\n  }\n\n  /**\n   *\n   * @param {Point} pt\n   * @param {Segment} seg\n   */\n  static distancePointSegment(pt, seg) {\n    return GeomUtil.distanceBetween(pt, GeomUtil.closestPtPointSegment(pt, seg));\n  }\n\n  /**\n   *\n   * @param {*} pt\n   * @param {*} boundingBox\n   * @returns {boolean}\n   */\n  static pointWithinBoundingBox(pt, boundingBox) {\n    return pt.x >= boundingBox.minX && pt.y >= boundingBox.minY && pt.x <= boundingBox.maxX && pt.y <= boundingBox.maxY;\n  }\n\n  /**\n   *\n   * @param {Point} pt\n   * @param {Segment[]} polySegs\n   * @returns {boolean}\n   */\n  static pointWithinPolygon(pt, polySegs, ignoreTouching) {\n    const b = GeomUtil.segmentsBoundingBox(polySegs);\n    // early out\n    if (!this.pointWithinBoundingBox(pt, b)) {\n      return false;\n    }\n\n    let startPt = new Point(100000, 100000);\n    let seg = new Segment(startPt, pt);\n\n    let pts = GeomUtil.segmentSegmentsIntersections(seg, polySegs);\n\n    if (!(pts.length % 2 == 0)) {\n      if (ignoreTouching && GeomUtil.pointsEqual(pt, pts[0])) {\n        return false;\n      }\n    }\n    return !(pts.length % 2 == 0);\n  }\n\n  /**\n   *\n   * @param {Segment} seg\n   * @param {Segment[]} polySegs\n   * @returns {boolean}\n   */\n  static segmentWithinPolygon(seg, polySegs) {\n    let aTouching = this.pointWithinPolygon(seg.a, polySegs, false);\n    let bTouching = this.pointWithinPolygon(seg.b, polySegs, false);\n    let aWithin = this.pointWithinPolygon(seg.a, polySegs, true);\n    let bWithin = this.pointWithinPolygon(seg.b, polySegs, true);\n    return (aWithin && bWithin) || (aWithin && bTouching) || (bWithin && aTouching);\n  }\n\n  static sign(p1, p2, p3) {\n    return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);\n  }\n\n  /**\n   *\n   * @param {Point} pt\n   * @param {Point} v1\n   * @param {Point} v2\n   * @param {Point} v3\n   * @returns {boolean}\n   */\n  static pointWithinTriangle(pt, v1, v2, v3, ignoreTouching) {\n    const d1 = GeomUtil.sign(pt, v1, v2);\n    const d2 = GeomUtil.sign(pt, v2, v3);\n    const d3 = GeomUtil.sign(pt, v3, v1);\n\n    const has_neg = d1 < 0 || d2 < 0 || d3 < 0;\n    const has_pos = d1 > 0 || d2 > 0 || d3 > 0;\n\n    if (!(has_neg && has_pos) && ignoreTouching) {\n      let seg = { a: v1, b: v2, tags: null };\n      if (GeomUtil.distancePointSegment(pt, seg) < 1) return false;\n      seg.a = v2;\n      seg.b = v3;\n      if (GeomUtil.distancePointSegment(pt, seg) < 1) return false;\n      seg.a = v3;\n      seg.b = v1;\n      if (GeomUtil.distancePointSegment(pt, seg) < 1) return false;\n    }\n\n    return !(has_neg && has_pos);\n  }\n\n  /**\n   *\n   * @param {Segment} seg\n   * @param {Point} v1\n   * @param {Point} v2\n   * @param {Point} v3\n   * @returns {boolean}\n   */\n  static segmentWithinTriangle(seg, v1, v2, v3) {\n    let aTouching = this.pointWithinTriangle(seg.a, v1, v2, v3, false);\n    let bTouching = this.pointWithinTriangle(seg.b, v1, v2, v3, false);\n    let aWithin = this.pointWithinTriangle(seg.a, v1, v2, v3, true);\n    let bWithin = this.pointWithinTriangle(seg.b, v1, v2, v3, true);\n    let pt = GeomUtil.averagePoints(seg.a, seg.b);\n    return (aWithin && bWithin) || (aWithin && bTouching) || (bWithin && aTouching) || (aTouching && bTouching);\n  }\n\n  /**\n   *\n   * @param {Point[]} pts\n   * @returns {Segment[]}\n   */\n  static pointsToClosedPolySegments(...pts) {\n    let out = [];\n    for (let i = 0; i < pts.length; i++) {\n      out.push(new Segment(pts[i], i < pts.length - 1 ? pts[i + 1] : pts[0]));\n    }\n    return out;\n  }\n\n  /**\n   *\n   * @param {Segment[]} polySegsA\n   * @param {Segment[]} polySegsB\n   * @returns {boolean}\n   */\n  static polygonWithinPolygon(polySegsA, polySegsB) {\n    const ab = GeomUtil.segmentsBoundingBox(polySegsA);\n    const bb = GeomUtil.segmentsBoundingBox(polySegsB);\n\n    // early out\n    if (!GeomUtil.boundingBoxesIntersect(ab, bb)) {\n      return false;\n    }\n\n    const startPt = new Point(bb.minX - 100, bb.minY - 100);\n\n    for (let i = 0; i < polySegsA.length; i++) {\n      let seg = polySegsA[i];\n      let pts = GeomUtil.segmentSegmentsIntersections(seg, polySegsB);\n\n      if (pts.length % 2 == 0) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   *\n   * @param {Point} ptA\n   * @param {Point} ptB\n   * @param {Point} ptC\n   * @param {number} iterations\n   */\n  static splinePoints(ptA, ptB, ptC, iterations = 0) {\n    let divide = (pts) => {\n      let out = [pts[0]];\n      for (let i = 0; i < pts.length - 1; i++) {\n        let pt = new Point(0, 0);\n        if (i + 1 < pts.length * 0.4) {\n          pt.x = (pts[i].x * 40 + pts[i + 1].x * 60) * 0.01;\n          pt.y = (pts[i].y * 40 + pts[i + 1].y * 60) * 0.01;\n        } else if (i + 1 > pts.length * 0.6) {\n          pt.x = (pts[i].x * 60 + pts[i + 1].x * 40) * 0.01;\n          pt.y = (pts[i].y * 60 + pts[i + 1].y * 40) * 0.01;\n        } else {\n          pt.x = (pts[i].x + pts[i + 1].x) * 0.5;\n          pt.y = (pts[i].y + pts[i + 1].y) * 0.5;\n        }\n        out.push(pt);\n      }\n      out.push(pts[pts.length - 1]);\n      return out;\n    };\n\n    let spts = [ptA, ptB, ptC];\n\n    for (let i = 0; i < iterations; i++) {\n      spts = divide(spts);\n    }\n\n    return spts;\n  }\n}","import { Segment, Point, GeomUtil } from \"./geom/geom.js\";\nimport { PolygonShape } from \"./geom/shapes.js\";\n\nexport class Analyzer {\n\n  /**\n   * @property {Segment[]} segs\n   * @property {boolean} splitTeeIntersections\n   * @returns {{ originalPts: Object.<string, Point>, pts: string[], cxs: Object.<string,string[]> }}\n   */\n  static getSegsAndConnections(segs, splitTeeIntersections = false, splitCrossIntersections = false) {\n\n    /** @type {Object.<string,string[]>} */\n    let cxs = {};\n    /** @type {string[]} */\n    let pts = [];\n    /** @type {Object.<string, Point>} */\n    let originalPts = {};\n\n    let token = pt => {\n      let t = `${Math.round(pt.x * 1)}|${Math.round(pt.y * 1)}`;\n      originalPts[t] = pt;\n      return t;\n    }\n\n    if (splitTeeIntersections) {\n\n      // step 0, split segments that cross a point (T intersections);\n\n      let allPts = segs.reduce((arr, seg) => arr.concat(seg.a, seg.b), []);\n      let j = allPts.length;\n\n      while (j--) {\n        let ptA = allPts[j];\n        let i = j;\n        while (i--) {\n          let ptB = allPts[i];\n          if (GeomUtil.pointsEqual(ptA, ptB)) {\n            allPts.splice(j, 1);\n            break;\n          }\n        }\n      }\n\n      let i = segs.length;\n\n      while (i--) {\n\n        let seg = segs[i];\n\n        let crossPts = [];\n\n        allPts.forEach(pt => {\n          if (GeomUtil.distancePointSegment(pt, seg) < 0.1) {\n            if (!GeomUtil.pointsEqual(pt, seg.a) && !GeomUtil.pointsEqual(pt, seg.b)) {\n              crossPts.push(pt);\n            }\n          }\n        });\n\n        if (crossPts.length) {\n\n          crossPts.sort((ptA, ptB) => {\n            const da = GeomUtil.distanceBetweenSquared(ptA, seg.a);\n            const db = GeomUtil.distanceBetweenSquared(ptB, seg.a);\n            if (da < db) {\n              return -1;\n            } else if (da > db) {\n              return 1;\n            }\n            return 0;\n          });\n\n          const newSegs = [];\n\n          let ptA = seg.a;\n          for (let k = 0; k < crossPts.length; k++) {\n            let ptB = crossPts[k];\n            newSegs.push(new Segment(ptA, ptB));\n            ptA = ptB;\n          }\n          newSegs.push(new Segment(ptA, seg.b));\n\n          segs.splice(i, 1, ...newSegs);\n\n        }\n\n      }\n\n    }\n\n    if (splitCrossIntersections) {\n\n      let j = segs.length;\n      while (j--) {\n        let i = j;\n        let found = false\n        while (i--) {\n          let segA = segs[j];\n          let segB = segs[i];\n          let intPt = GeomUtil.segmentSegmentIntersect(segA, segB, true);\n          if (intPt) {\n            found = true;\n            segs.splice(j, 1, new Segment(Point.clone(segA.a), Point.clone(intPt)), new Segment(Point.clone(intPt), Point.clone(segA.b)));\n            segs.splice(i, 1, new Segment(Point.clone(segB.a), Point.clone(intPt)), new Segment(Point.clone(intPt), Point.clone(segB.b)));\n          }\n        }\n        if (found) {\n          j = segs.length;\n        }\n      }\n\n    }\n\n    // step 1, collect endpoints\n    // step 2, filter out dupes\n    // step 3, collect connected endpoints for each endpoint\n\n    segs.forEach(seg => {\n      let ta = token(seg.a);\n      let tb = token(seg.b);\n      if (!cxs[ta]) cxs[ta] = [];\n      if (!cxs[tb]) cxs[tb] = [];\n      if (cxs[ta].indexOf(tb) === -1) {\n        cxs[ta].push(tb);\n      }\n      if (cxs[tb].indexOf(ta) === -1) {\n        cxs[tb].push(ta);\n      }\n      if (pts.indexOf(ta) === -1) {\n        pts.push(ta);\n      }\n      if (pts.indexOf(tb) === -1) {\n        pts.push(tb);\n      }\n    });\n\n    return {\n      originalPts,\n      pts,\n      cxs\n    };\n\n  }\n\n  /**\n   * @property {Segment[]} segs\n   * @property {boolean} splitTeeIntersections\n   * @returns {Segment[]}\n   */\n  static pathOrder(segs, splitTeeIntersections = false, splitCrossIntersections = false) {\n\n    let res = [];\n    let { originalPts, pts, cxs } = Analyzer.getSegsAndConnections(segs, splitTeeIntersections, splitCrossIntersections);\n\n    let nekot = str => {\n      return originalPts[str];\n    };\n\n    let byNumConnections = (ta, tb) => {\n      if (cxs[ta].length > cxs[tb].length) {\n        return 1;\n      } else if (cxs[ta].length < cxs[tb].length) {\n        return -1;\n      }\n      return 0;\n    }\n\n    // step 1, sort by number of connections, desc\n    // step 2, choose first endpoint\n    // step 3, pick the connected one with the lowest index that isn't in the stack, remove from connections list, push onto stack\n    // step 4, resort by number of connections, desc\n    // step 5, repeat step 6 until no more connections\n\n    pts.sort(byNumConnections);\n\n    while (pts.length) {\n\n      pts.sort(byNumConnections);\n      let ptA = pts.shift();\n\n      while (ptA) {\n\n        if (cxs[ptA].length) {\n\n          cxs[ptA].sort(byNumConnections);\n          let ptB = cxs[ptA].shift();\n\n          let oppIdx = cxs[ptB].indexOf(ptA);\n          if (oppIdx !== -1) cxs[ptB].splice(oppIdx, 1);\n\n          res.push(new Segment(nekot(ptA), nekot(ptB)));\n\n          if (cxs[ptA].length) {\n            pts.unshift(ptA);\n          }\n\n          ptA = ptB;\n\n        } else {\n\n          ptA = null;\n\n        }\n\n      }\n\n    }\n\n    return res;\n\n  }\n\n  /**\n   * @property {Segment[]} segs\n   * @property {number} offset\n   * @returns {Point[]}\n   */\n  static getEndingSegmentPoints(segs, offset = 0) {\n\n    segs = segs.concat();\n    segs = Analyzer.pathOrder(segs, true, true);\n\n    let { originalPts, pts, cxs } = Analyzer.getSegsAndConnections(segs, true);\n\n    let nekot = str => {\n      return originalPts[str];\n    };\n\n    // return all points with one connection\n\n    const endTokens = pts.filter(ta => cxs[ta].length === 1);\n\n    const out = [];\n    endTokens.forEach(tb => {\n      const ptB = Point.clone(nekot(tb));\n      if (offset === 0) {\n        out.push(ptB);\n        return;\n      }\n      const ptA = nekot(cxs[tb]);\n      const ang = GeomUtil.angleBetween(ptA, ptB);\n      const pt = new Point(0, offset);\n      GeomUtil.rotatePoint(pt, Math.PI * 0.5 - ang);\n      GeomUtil.addToPoint(ptB, pt);\n      out.push(ptB);\n    });\n\n    return out;\n\n  }\n\n  /**\n   * @property {Segment[]} segs\n   * @property {number} searchMultiplier multiple of typical segmentation distance to search for flood-fill points\n   * @returns {Point[][]}\n   */\n  static getFills(segs, searchMultiplier = 5) {\n\n    segs = segs.concat();\n\n    let { originalPts, pts, cxs } = Analyzer.getSegsAndConnections(segs, true, true);\n\n    let token = pt => {\n      let t = `${Math.round(pt.x * 1)}|${Math.round(pt.y * 1)}`;\n      originalPts[t] = pt;\n      return t;\n    }\n\n    let cenTokens = [];\n    let pointGroups = [];\n\n    // 1. iterate through all points\n    // 2. for each point pick a each connection\n    // 3. for each pair, proceed to find a winding polygon\n\n    let minX = 100000;\n    let minY = 100000;\n    let maxX = -100000;\n    let maxY = -100000;\n    let minDx = 100000;\n    let minDy = 100000;\n\n    let ptArray = [];\n\n    // get extents\n\n    for (let token in originalPts) {\n      let pt = originalPts[token];\n      ptArray.push(pt);\n      minX = Math.min(minX, pt.x);\n      minY = Math.min(minY, pt.y);\n      maxX = Math.max(maxX, pt.x);\n      maxY = Math.max(maxY, pt.y);\n    }\n\n    // get minimum spacing\n\n    ptArray.sort((a, b) => {\n      if (a.x < b.x) {\n        return -1;\n      } else if (a.x > b.x) {\n        return 1;\n      }\n      return 0;\n    });\n\n    ptArray.forEach((ptA, idx) => {\n      if (idx > 0) {\n        let ptB = ptArray[idx - 1];\n        let dx = Math.round(Math.abs(ptA.x - ptB.x));\n        if (dx > 1) {\n          minDx = Math.min(minDx, dx);\n        }\n      }\n    });\n\n    ptArray.sort((a, b) => {\n      if (a.y < b.y) {\n        return -1;\n      } else if (a.y > b.y) {\n        return 1;\n      }\n      return 0;\n    });\n\n    ptArray.forEach((ptA, idx) => {\n      if (idx > 0) {\n        let ptB = ptArray[idx - 1];\n        let dy = Math.round(Math.abs(ptA.y - ptB.y));\n        if (dy > 1) {\n          minDy = Math.min(minDy, dy);\n        }\n      }\n    });\n\n    let hDx = minDx * 0.5;\n    let hDy = minDy * 0.5;\n\n    let rayPts = [];\n\n    for (let j = minY; j < maxY; j += minDy) {\n      for (let i = minX; i < maxX; i += minDx) {\n        rayPts.push(new Point(i + hDx, j + hDy));\n      }\n    }\n\n    rayPts.forEach(rayPt => {\n      let nearPts = [];\n      ptArray.forEach(pt => {\n        let dist = GeomUtil.distanceBetween(pt, rayPt);\n        if (dist < Math.max(minDx, minDy) * searchMultiplier) {\n          let ang = GeomUtil.angleBetween(pt, rayPt);\n          nearPts.push({\n            pt,\n            dist,\n            ang\n          });\n        }\n      });\n      if (nearPts.length < 4) {\n        return;\n      }\n      let i = nearPts.length;\n      while (i--) {\n        let nPt = nearPts[i].pt;\n        let seg = new Segment(rayPt, nPt);\n        let hits = GeomUtil.segmentSegmentsIntersections(seg, segs, true);\n        if (hits.length > 0) {\n          nearPts.splice(i, 1);\n        }\n      }\n      nearPts.sort((a, b) => {\n        if (a.ang < b.ang) {\n          return -1;\n        } else if (a.ang > b.ang) {\n          return 1;\n        }\n        return 0;\n      });\n      i = nearPts.length;\n      while (i--) {\n        let nPtA = nearPts[i].pt;\n        let tokenA = token(nPtA);\n        let j = nearPts.length;\n        let ok = false;\n        while (j--) {\n          if (i === j) {\n            continue;\n          }\n          let nPtB = nearPts[j].pt;\n          let tokenB = token(nPtB);\n          if (cxs[tokenA].indexOf(tokenB) === -1) {\n            ok = true;\n            break;\n          }\n        }\n        if (!ok) {\n          nearPts.splice(i, 1);\n        }\n      }\n      let ok = true;\n      nearPts.forEach((npA, idx) => {\n        let npB = nearPts[(idx + 1) % nearPts.length];\n        let tokenA = token(npA.pt);\n        let tokenB = token(npB.pt);\n        if (cxs[tokenA].indexOf(tokenB) === -1) {\n          ok = false;\n        }\n      });\n      if (ok) {\n        let polyPts = nearPts.map(nPt => nPt.pt);\n        let cen = GeomUtil.averagePoints(...polyPts);\n        let cenToken = token(cen);\n        if (cenTokens.indexOf(cenToken) === -1) {\n          cenTokens.push(cenToken);\n          pointGroups.push(polyPts);\n        }\n      }\n    });\n\n    return pointGroups;\n\n  }\n\n}\n\n","import { Segment, Segments, SegmentCollection, Point, GeomUtil } from \"./geom/geom.js\";\nimport { Analyzer } from \"./analyzer.js\";\n\nexport class Optimize {\n  /**\n   *\n   * @param {SegmentCollection[]} segCols\n   * @param {boolean} [noSplit]\n   * @param {boolean} [trimSmall]\n   * @param {number} [smallDist]\n   * @param {boolean} [optimizePathOrder]\n   * @param {boolean} [splitTeeIntersections]\n   * @returns {Segments}\n   */\n  static segmentCollections(segCols, noSplit = false, trimSmall = true, smallDist = 1, optimizePathOrder = false, splitTeeIntersections = false, splitCrossIntersections = false) {\n    let allsegs = segCols.reduce((arr, sc) => arr.concat(sc.toSegments()), []);\n    return Optimize.segments(allsegs, noSplit, trimSmall, smallDist, optimizePathOrder, splitTeeIntersections, splitCrossIntersections);\n  }\n  /**\n   *\n   * @param {SegmentCollection[]} segCols\n   * @param {boolean} [splitTeeIntersections]\n   * @returns {Segments}\n   */\n  static segmentCollectionsPathOrder(segCols, splitTeeIntersections = false, splitCrossIntersections = false) {\n    let allsegs = segCols.reduce((arr, sc) => arr.concat(sc.toSegments()), []);\n    return new Segments(Analyzer.pathOrder(allsegs, splitTeeIntersections, splitCrossIntersections));\n  }\n  /**\n   *\n   * @param {Segment[]} segs\n   * @param {boolean} [noSplitColinear]\n   * @param {boolean} [trimSmall]\n   * @param {number} [smallDist]\n   * @param {boolean} [optimizePathOrder]\n   * @param {boolean} [splitTeeIntersections]\n   * @returns {Segments}\n   */\n  static segments(segs, noSplitColinear = false, trimSmall = true, smallDist = 1, optimizePathOrder = false, splitTeeIntersections = false, splitCrossIntersections = false) {\n\n    segs = Optimize._segments(segs, noSplitColinear, trimSmall, smallDist);\n\n    if (optimizePathOrder) {\n      segs = Analyzer.pathOrder(segs, splitTeeIntersections, splitCrossIntersections);\n    }\n\n    return new Segments(segs);\n  }\n\n  /**\n   * JS fallback for segment optimization  \n   * @private\n   */\n  static _segments(segs, noSplitColinear, trimSmall, smallDist) {\n    const sb = segs;\n    segs = [];\n\n    // Dedupe\n    while (sb.length) {\n      let s = sb.shift();\n      let n = segs.length\n      let found = false;\n      while (n--) {\n        const sn = segs[n];\n        if (Segment.isEqual(s, sn)) {\n          found = true;\n          break;\n        }\n      }\n      if (!found) {\n        segs.push(s);\n      }\n    }\n\n    // Merge colinear\n    if (!noSplitColinear) {\n\n      for (let n = 0; n < 3; n++) {\n        let i = segs.length;\n        let overlaps = 0;\n\n        while (i--) {\n          let segA = segs[i];\n          let aa, ab, ba, bb, heading;\n          for (let j = i - 1; j >= 0; j--) {\n            let segB = segs[j];\n            let same = false;\n            let isRev = false;\n            if (GeomUtil.sameAngle(segA, segB)) {\n              same = true;\n              aa = Point.clone(segA.a);\n              ab = Point.clone(segA.b);\n              ba = Point.clone(segB.a);\n              bb = Point.clone(segB.b);\n            } else if (GeomUtil.sameAngleRev(segA, segB)) {\n              same = isRev = true;\n              aa = Point.clone(segA.b);\n              ab = Point.clone(segA.a);\n              ba = Point.clone(segB.a);\n              bb = Point.clone(segB.b);\n            }\n            if (same) {\n              heading = GeomUtil.angleBetween(aa, ab);\n              GeomUtil.rotatePoints(heading, aa, ab, ba, bb);\n              if (Math.abs(aa.y - ba.y) < 0.1 && ab.x >= ba.x - 0.0001 && aa.x <= bb.x + 0.0001) {\n                overlaps++;\n                if (aa.x < ba.x) {\n                  if (!isRev) {\n                    segB.a = segA.a;\n                  } else {\n                    segB.a = segA.b;\n                  }\n                }\n                if (ab.x > bb.x) {\n                  if (!isRev) {\n                    segB.b = segA.b;\n                  } else {\n                    segB.b = segA.a;\n                  }\n                }\n                segs.splice(i, 1);\n                break;\n              }\n            }\n          }\n        }\n      }\n\n    }\n\n    // Trim small\n    let i = segs.length;\n    while (i--) {\n      let seg = segs[i];\n      if (!seg) {\n        segs.splice(i, 1);\n        continue;\n      }\n      if (trimSmall && GeomUtil.distanceBetween(seg.a, seg.b) < smallDist) {\n        segs.splice(i, 1);\n        continue;\n      }\n    }\n\n    console.log(`[JS] Optimize: ${sb.length + segs.length} -> ${segs.length} segments`);\n    return segs;\n  }\n\n}\n","// @ts-check\n/**\n * Edge-Based Hidden Line Renderer\n * \n * A faster alternative to clipper-based boolean operations.\n * Uses per-edge occlusion testing.\n */\n\nimport { Optimize } from './optimize.js';\n\nimport {\n    Vector3,\n    Vector2,\n    Raycaster,\n    Camera,\n    Scene,\n    Mesh,\n    WebGLRenderTarget,\n    NearestFilter,\n    RGBAFormat,\n    UnsignedByteType,\n    MeshDepthMaterial,\n    RGBADepthPacking,\n    ShaderMaterial,\n    BufferAttribute,\n    BufferGeometry,\n    DoubleSide\n} from \"three\";\n\n/**\n * @typedef {Object} Edge3D\n * @property {Vector3} a - Start point (world space)\n * @property {Vector3} b - End point (world space)\n * @property {Vector3} normal1 - First face normal\n * @property {Vector3} [normal2] - Second face normal (if shared edge)\n * @property {number} faceIdx1 - First face index\n * @property {number} [faceIdx2] - Second face index\n * @property {Mesh} mesh - Parent mesh\n * @property {boolean} [isHatch] - Is this a hatch line?\n */\n\n/**\n * @typedef {Object} Edge2D\n * @property {Vector2} a - Start point (screen space)\n * @property {Vector2} b - End point (screen space)\n * @property {Vector3} a3d - Start point (world space)\n * @property {Vector3} b3d - End point (world space)\n * @property {Vector3} midpoint3d - Midpoint in world space\n * @property {boolean} isProfile - Is this a silhouette edge?\n * @property {boolean} visible - Is this edge visible?\n * @property {number} faceIdx - Parent face index\n * @property {number} [faceIdx2] - Second face index (if shared edge)\n * @property {Mesh} mesh - Parent mesh\n * @property {boolean} [isHatch] - Is this a hatch line?\n * @property {boolean} [isSilhouette] - Is this a silhouette edge (borders void)?\n * @property {Vector3} [normal1] - First face normal (propagated)\n * @property {Vector3} [normal2] - Second face normal (propagated)\n * @property {number} [adjacentFaceCount] - Number of adjacent faces (debug/filtering)\n * @property {number} [faceSimilarity] - Similarity of adjacent face normals (debug/filtering)\n * @property {boolean} [isTJunctionStraggler] - Is this edge a result of a T-junction split?\n */\n\n/**\n * @typedef {Object} Point2D\n * @property {number} x\n * @property {number} y\n */\n\n/**\n * @typedef {Object} ProjectedFace\n * @property {Vector2} a2d - Screen space vertex A\n * @property {Vector2} b2d - Screen space vertex B\n * @property {Vector2} c2d - Screen space vertex C\n * @property {number} depthA - Depth at vertex A\n * @property {number} depthB - Depth at vertex B\n * @property {number} depthC - Depth at vertex C\n * @property {Mesh} mesh - Source mesh\n * @property {number} faceIdx - Original face index\n * @property {Vector3} normal - Face normal (world space)\n * @property {number} constant - Plane constant d\n */\n\n/**\n * Extract edges from a mesh with face normal information\n * Only extracts edges from front-facing faces (skips back-facing)\n * @param {Mesh} mesh \n * @param {Vector3} cameraPosition - Camera position for face culling\n * @returns {Edge3D[]}\n */\nexport function extractEdges(mesh, cameraPosition) {\n    const geometry = mesh.geometry;\n    const position = geometry.attributes.position;\n    const index = geometry.index;\n\n    if (!position) return [];\n\n    /** @type {Map<string, Edge3D>} */\n    const edgeMap = new Map();\n\n    // Snap tolerance for position-based edge matching\n    const SNAP = 1000; // Precision: 3 decimal places\n\n    // Position-based edge key (not index-based, handles duplicate vertices)\n    /**\n     * \n     * @param {Vector3} va \n     * @param {Vector3} vb \n     * @returns \n     */\n    const getEdgeKey = (va, vb) => {\n        const ax = Math.round(va.x * SNAP);\n        const ay = Math.round(va.y * SNAP);\n        const az = Math.round(va.z * SNAP);\n        const bx = Math.round(vb.x * SNAP);\n        const by = Math.round(vb.y * SNAP);\n        const bz = Math.round(vb.z * SNAP);\n\n        const keyA = `${ax},${ay},${az}`;\n        const keyB = `${bx},${by},${bz}`;\n\n        // Consistent ordering for undirected edges\n        return keyA < keyB ? `${keyA}|${keyB}` : `${keyB}|${keyA}`;\n    };\n\n    /**\n     * \n     * @param {number} idx \n     * @returns \n     */\n    const getVertex = (idx) => {\n        const v = new Vector3(\n            position.getX(idx),\n            position.getY(idx),\n            position.getZ(idx)\n        );\n        return v.applyMatrix4(mesh.matrixWorld);\n    };\n\n    /**\n     * \n     * @param {Vector3} v0 \n     * @param {Vector3} v1 \n     * @param {Vector3} v2 \n     * @returns \n     */\n    const getFaceNormal = (v0, v1, v2) => {\n        const edge1 = new Vector3().subVectors(v1, v0);\n        const edge2 = new Vector3().subVectors(v2, v0);\n        return new Vector3().crossVectors(edge1, edge2).normalize();\n    };\n\n    const numFaces = index ? index.count / 3 : position.count / 3;\n\n    for (let f = 0; f < numFaces; f++) {\n        let i0, i1, i2;\n\n        if (index) {\n            i0 = index.getX(f * 3);\n            i1 = index.getX(f * 3 + 1);\n            i2 = index.getX(f * 3 + 2);\n        } else {\n            i0 = f * 3;\n            i1 = f * 3 + 1;\n            i2 = f * 3 + 2;\n        }\n\n        const v0 = getVertex(i0);\n        const v1 = getVertex(i1);\n        const v2 = getVertex(i2);\n        const normal = getFaceNormal(v0, v1, v2);\n\n        // Skip back-facing faces - only extract edges from front-facing faces\n        const faceMid = new Vector3().addVectors(v0, v1).add(v2).divideScalar(3);\n        const viewDir = new Vector3().subVectors(cameraPosition, faceMid);\n        if (normal.dot(viewDir) <= 0) {\n            continue; // Skip back-facing face\n        }\n\n        // Process three edges of the triangle\n        const edges = [\n            [v0, v1],\n            [v1, v2],\n            [v2, v0]\n        ];\n\n        for (const [va, vb] of edges) {\n            const key = getEdgeKey(va, vb);\n\n            if (edgeMap.has(key)) {\n                // Edge already exists - add second face normal\n                const existing = edgeMap.get(key);\n                if (existing && !existing.normal2) {\n                    existing.normal2 = normal.clone();\n                    existing.faceIdx2 = f;\n                }\n            } else {\n                edgeMap.set(key, {\n                    a: va.clone(),\n                    b: vb.clone(),\n                    normal1: normal.clone(),\n                    faceIdx1: f,\n                    mesh\n                });\n            }\n        }\n    }\n\n    return Array.from(edgeMap.values());\n}\n\n/**\n * Filter edges: remove those where both faces are back-facing\n * @param {Edge3D[]} edges \n * @param {Vector3} cameraPosition \n * @returns {Edge3D[]}\n */\nexport function filterBackfacing(edges, cameraPosition) {\n    return edges.filter(edge => {\n        const edgeMidpoint = new Vector3().addVectors(edge.a, edge.b).multiplyScalar(0.5);\n        const viewDir = new Vector3().subVectors(cameraPosition, edgeMidpoint).normalize();\n\n        const facing1 = edge.normal1.dot(viewDir) > 0;\n\n        // Boundary edges (only one face) are always kept - they're silhouettes\n        if (!edge.normal2) {\n            return true;\n        }\n\n        const facing2 = edge.normal2.dot(viewDir) > 0;\n\n        // Keep edge if at least one face is front-facing\n        return facing1 || facing2;\n    });\n}\n\n/**\n * Detect profile (silhouette) edges and mark smooth edges for removal\n * @param {Edge3D[]} edges \n * @param {Vector3} cameraPosition \n * @param {number} smoothThreshold - Dot product threshold for similar normals (default 0.99)\n * @returns {{profiles: Edge3D[], smoothFiltered: Edge3D[]}}\n */\nexport function classifyEdges(edges, cameraPosition, smoothThreshold = 0.99) {\n    const profiles = [];\n    const smoothFiltered = [];\n\n    // Debug counters\n    let boundaryCount = 0;\n    let profileCount = 0;\n    let smoothCount = 0;\n    let discardedCount = 0;\n\n    for (const edge of edges) {\n        const edgeMidpoint = new Vector3().addVectors(edge.a, edge.b).multiplyScalar(0.5);\n        const viewDir = new Vector3().subVectors(cameraPosition, edgeMidpoint).normalize();\n\n        const facing1 = edge.normal1.dot(viewDir) > 0;\n        const facing2 = edge.normal2 ? edge.normal2.dot(viewDir) > 0 : true; // Boundary edges count as profile\n\n        // Profile edge: one face front, one face back (or boundary)\n        if (facing1 !== facing2 || !edge.normal2) {\n            profiles.push(edge);\n            continue;\n        }\n\n        // Check if normals are similar (smooth shading edge)\n        if (edge.normal2) {\n            const similarity = edge.normal1.dot(edge.normal2);\n            // Keep edge only if normals are different enough (crease/hard edge)\n            // Filter out smooth edges where normals are nearly parallel\n            if (similarity < smoothThreshold) {\n                smoothFiltered.push(edge);\n            }\n            // Edges with similar normals (similarity >= threshold) are discarded as smooth surface edges\n        }\n    }\n\n    console.log(`classifyEdges: ${profiles.length} profiles, ${smoothFiltered.length} smooth/crease edges`);\n\n    return { profiles, smoothFiltered };\n}\n\n/**\n * Project 3D edges to screen space\n * @param {Edge3D[]} edges \n * @param {Camera} camera \n * @param {number} width \n * @param {number} height \n * @param {number} scale - Internal scale factor for precision (default 1)\n * @returns {Edge2D[]}\n */\nexport function projectEdges(edges, camera, width, height, scale = 1) {\n    const halfWidth = width / 2;\n    const halfHeight = height / 2;\n\n    /**\n     * \n     * @param {Vector3} p3d \n     * @returns \n     */\n    const projectPoint = (p3d) => {\n        const projected = p3d.clone().project(camera);\n        return new Vector2(\n            projected.x * halfWidth * scale,\n            -projected.y * halfHeight * scale\n        );\n    };\n\n    return edges.map(edge => ({\n        a: projectPoint(edge.a),\n        b: projectPoint(edge.b),\n        a3d: edge.a.clone(),\n        b3d: edge.b.clone(),\n        midpoint3d: new Vector3().addVectors(edge.a, edge.b).multiplyScalar(0.5),\n        isProfile: false, // Will be set by classifyEdges\n        visible: true,\n        faceIdx: edge.faceIdx1,\n        faceIdx2: edge.faceIdx2,\n        mesh: edge.mesh,\n        isHatch: edge.isHatch,\n        normal1: edge.normal1,  // Propagate normals for straggler detection\n        normal2: edge.normal2\n    }));\n}\n\n/**\n * Spatial hash for efficient edge queries\n */\nexport class SpatialHash {\n    /**\n     * @param {number} cellSize \n     */\n    constructor(cellSize) {\n        this.cellSize = cellSize;\n        /** @type {Map<string, Edge2D[]>} */\n        this.cells = new Map();\n    }\n\n    /**\n     * Get cell key for a point\n     * @param {number} x \n     * @param {number} y \n     * @returns {string}\n     */\n    getCellKey(x, y) {\n        const cx = Math.floor(x / this.cellSize);\n        const cy = Math.floor(y / this.cellSize);\n        return `${cx},${cy}`;\n    }\n\n    /**\n     * Get all cells an edge crosses\n     * @param {Edge2D} edge \n     * @returns {string[]}\n     */\n    getCellsCrossed(edge) {\n        const cells = new Set();\n\n        // Use line rasterization to find all cells\n        const dx = Math.abs(edge.b.x - edge.a.x);\n        const dy = Math.abs(edge.b.y - edge.a.y);\n        const steps = Math.max(dx, dy) / this.cellSize + 1;\n\n        for (let i = 0; i <= steps; i++) {\n            const t = i / steps;\n            const x = edge.a.x + t * (edge.b.x - edge.a.x);\n            const y = edge.a.y + t * (edge.b.y - edge.a.y);\n            cells.add(this.getCellKey(x, y));\n        }\n\n        return Array.from(cells);\n    }\n\n    /**\n     * Insert an edge into the spatial hash\n     * @param {Edge2D} edge \n     */\n    insert(edge) {\n        const cells = this.getCellsCrossed(edge);\n        for (const key of cells) {\n            if (!this.cells.has(key)) {\n                this.cells.set(key, []);\n            }\n            this.cells.get(key)?.push(edge);\n        }\n    }\n\n    /**\n     * Get all edges in a cell\n     * @param {string} key \n     * @returns {Edge2D[]}\n     */\n    query(key) {\n        return this.cells.get(key) || [];\n    }\n\n    /**\n     * Get all cell keys\n     * @returns {string[]}\n     */\n    getAllCells() {\n        return Array.from(this.cells.keys());\n    }\n\n    clear() {\n        this.cells.clear();\n    }\n}\n\n/**\n * Find intersection point of two 2D line segments\n * @param {Edge2D} e1 \n * @param {Edge2D} e2 \n * @returns {{t1: number, t2: number, point: Vector2} | null}\n */\nexport function findIntersection(e1, e2) {\n    const x1 = e1.a.x, y1 = e1.a.y;\n    const x2 = e1.b.x, y2 = e1.b.y;\n    const x3 = e2.a.x, y3 = e2.a.y;\n    const x4 = e2.b.x, y4 = e2.b.y;\n\n    const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n    if (Math.abs(denom) < 1e-10) return null; // Parallel\n\n    const t1 = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;\n    const t2 = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;\n\n    const eps = 0.001;\n    // Check if intersection is within both segments (excluding endpoints)\n    if (t1 > eps && t1 < 1 - eps && t2 > eps && t2 < 1 - eps) {\n        return {\n            t1,\n            t2,\n            point: new Vector2(\n                x1 + t1 * (x2 - x1),\n                y1 + t1 * (y2 - y1)\n            )\n        };\n    }\n\n    return null;\n}\n\n/**\n * Split edges at intersection points within a cell\n * @param {Edge2D[]} edges \n * @returns {Edge2D[]}\n */\nexport function splitAtIntersections(edges) {\n    /** @type {Map<Edge2D, {t: number, point: Vector2}[]>} */\n    const splits = new Map();\n\n    const eps = 0.01;\n\n    // Helper: check if point p lies on edge interior (not endpoints)\n    // Returns t parameter (0,1) if on edge, null otherwise\n    /**\n     * \n     * @param {Vector2} p \n     * @param {Edge2D} edge \n     * @returns \n     */\n    const pointOnEdgeInterior = (p, edge) => {\n        const dx = edge.b.x - edge.a.x;\n        const dy = edge.b.y - edge.a.y;\n        const lenSq = dx * dx + dy * dy;\n        if (lenSq < 1e-10) return null; // Degenerate edge\n\n        // Project p onto edge line\n        const t = ((p.x - edge.a.x) * dx + (p.y - edge.a.y) * dy) / lenSq;\n\n        // Check if t is in interior (not at endpoints)\n        if (t <= eps || t >= 1 - eps) return null;\n\n        // Check distance from point to projected point on line\n        const projX = edge.a.x + t * dx;\n        const projY = edge.a.y + t * dy;\n        const distSq = (p.x - projX) * (p.x - projX) + (p.y - projY) * (p.y - projY);\n\n        // Tolerance for \"on the edge\"\n        if (distSq < 1.0) { // 1 pixel tolerance\n            return t;\n        }\n        return null;\n    };\n\n    // Track edges that might be stragglers (their endpoint caused a T-junction)\n    const potentialStragglers = new Set();\n\n    // Find all intersections (crossing + T-junctions)\n    for (let i = 0; i < edges.length; i++) {\n        for (let j = i + 1; j < edges.length; j++) {\n            // Check for crossing intersection\n            const intersection = findIntersection(edges[i], edges[j]);\n            if (intersection) {\n                // Record split points for both edges\n                if (!splits.has(edges[i])) splits.set(edges[i], []);\n                if (!splits.has(edges[j])) splits.set(edges[j], []);\n\n                splits.get(edges[i])?.push({ t: intersection.t1, point: intersection.point });\n                splits.get(edges[j])?.push({ t: intersection.t2, point: intersection.point });\n            } else {\n                // Check for T-junctions: endpoint of one edge on interior of other\n                // Mark BOTH edges as potential stragglers\n\n                // Edge i's endpoints on edge j\n                const tAonJ = pointOnEdgeInterior(edges[i].a, edges[j]);\n                if (tAonJ !== null) {\n                    if (!splits.has(edges[j])) splits.set(edges[j], []);\n                    splits.get(edges[j])?.push({ t: tAonJ, point: edges[i].a.clone() });\n                    potentialStragglers.add(edges[i]);\n                    potentialStragglers.add(edges[j]);  // Mark BOTH\n                }\n\n                const tBonJ = pointOnEdgeInterior(edges[i].b, edges[j]);\n                if (tBonJ !== null) {\n                    if (!splits.has(edges[j])) splits.set(edges[j], []);\n                    splits.get(edges[j])?.push({ t: tBonJ, point: edges[i].b.clone() });\n                    potentialStragglers.add(edges[i]);\n                    potentialStragglers.add(edges[j]);  // Mark BOTH\n                }\n\n                // Edge j's endpoints on edge i\n                const tAonI = pointOnEdgeInterior(edges[j].a, edges[i]);\n                if (tAonI !== null) {\n                    if (!splits.has(edges[i])) splits.set(edges[i], []);\n                    splits.get(edges[i])?.push({ t: tAonI, point: edges[j].a.clone() });\n                    potentialStragglers.add(edges[i]);  // Mark BOTH\n                    potentialStragglers.add(edges[j]);\n                }\n\n                const tBonI = pointOnEdgeInterior(edges[j].b, edges[i]);\n                if (tBonI !== null) {\n                    if (!splits.has(edges[i])) splits.set(edges[i], []);\n                    splits.get(edges[i])?.push({ t: tBonI, point: edges[j].b.clone() });\n                    potentialStragglers.add(edges[i]);  // Mark BOTH\n                    potentialStragglers.add(edges[j]);\n                }\n            }\n        }\n    }\n\n    console.log(`T-junction detection: ${potentialStragglers.size} potential straggler edges`);\n\n    // Split edges at recorded points\n    const result = [];\n\n    for (const edge of edges) {\n        const edgeSplits = splits.get(edge);\n        const isStraggler = potentialStragglers.has(edge);\n\n        if (!edgeSplits || edgeSplits.length === 0) {\n            // Mark the edge as potential straggler if it was identified\n            edge.isTJunctionStraggler = isStraggler;\n            result.push(edge);\n            continue;\n        }\n\n        // Sort splits by t value\n        edgeSplits.sort((a, b) => a.t - b.t);\n\n        // Create sub-edges\n        let prevT = 0;\n        let prevPoint = edge.a;\n        let prevPoint3d = edge.a3d;\n\n        for (const split of edgeSplits) {\n            const point3d = new Vector3().lerpVectors(edge.a3d, edge.b3d, split.t);\n\n            result.push({\n                a: prevPoint.clone(),\n                b: split.point.clone(),\n                a3d: prevPoint3d.clone(),\n                b3d: point3d.clone(),\n                midpoint3d: new Vector3().addVectors(prevPoint3d, point3d).multiplyScalar(0.5),\n                isProfile: edge.isProfile,\n                visible: edge.visible,\n                faceIdx: edge.faceIdx,\n                mesh: edge.mesh,\n                isHatch: edge.isHatch,\n                normal1: edge.normal1,  // Propagate normal for smooth filter\n                isTJunctionStraggler: isStraggler\n            });\n\n            prevT = split.t;\n            prevPoint = split.point;\n            prevPoint3d = point3d;\n        }\n\n        // Final segment\n        result.push({\n            a: prevPoint.clone(),\n            b: edge.b.clone(),\n            a3d: prevPoint3d.clone(),\n            b3d: edge.b3d.clone(),\n            midpoint3d: new Vector3().addVectors(prevPoint3d, edge.b3d).multiplyScalar(0.5),\n            isProfile: edge.isProfile,\n            visible: edge.visible,\n            faceIdx: edge.faceIdx,\n            mesh: edge.mesh,\n            isHatch: edge.isHatch,\n            normal1: edge.normal1,  // Propagate normal for smooth filter\n            isTJunctionStraggler: isStraggler\n        });\n    }\n\n    return result;\n}\n\n/**\n * Test edge visibility using GPU depth buffer (fast O(1) per edge)\n * Uses a render target with depth material to read depth as RGBA\n * @param {Edge2D[]} edges \n * @param {Scene} scene \n * @param {Camera} camera \n * @param {number} epsilon - Depth tolerance (normalized 0-1)\n * @param {number} width - Viewport width\n * @param {number} height - Viewport height\n * @param {any} renderer - THREE.WebGLRenderer instance\n * @returns {Edge2D[]}\n */\nexport function testOcclusionDepthBuffer(edges, scene, camera, epsilon, width, height, renderer) {\n    const visibleEdges = [];\n\n    if (!renderer) {\n        console.warn('No renderer provided, skipping occlusion test');\n        return edges;\n    }\n\n    // Create render target for depth\n    const renderTarget = new WebGLRenderTarget(width, height, {\n        minFilter: NearestFilter,\n        magFilter: NearestFilter,\n        format: RGBAFormat,\n        type: UnsignedByteType\n    });\n\n    // Create depth material that encodes depth as color\n    const depthMaterial = new MeshDepthMaterial({\n        depthPacking: RGBADepthPacking\n    });\n\n    // Store original material overrides\n    const originalOverrideMaterial = scene.overrideMaterial;\n\n    // Render scene with depth material\n    scene.overrideMaterial = depthMaterial;\n    renderer.setRenderTarget(renderTarget);\n    renderer.render(scene, camera);\n\n    // Read the render target as RGBA\n    const depthData = new Uint8Array(width * height * 4);\n    renderer.readRenderTargetPixels(renderTarget, 0, 0, width, height, depthData);\n\n    // Restore scene\n    scene.overrideMaterial = originalOverrideMaterial;\n    renderer.setRenderTarget(null);\n\n    // Check if we got valid data\n    let hasData = false;\n    for (let i = 0; i < Math.min(4000, depthData.length); i += 4) {\n        if (depthData[i] !== 0 || depthData[i + 1] !== 0 || depthData[i + 2] !== 0) {\n            hasData = true;\n            break;\n        }\n    }\n\n    // Debug: sample center of depth buffer\n    const centerIdx = Math.floor(height / 2) * width * 4 + Math.floor(width / 2) * 4;\n    console.log(`Depth buffer center pixel (RGBA): ${depthData[centerIdx]}, ${depthData[centerIdx + 1]}, ${depthData[centerIdx + 2]}, ${depthData[centerIdx + 3]}`);\n\n    if (!hasData) {\n        console.warn('Could not read depth buffer, falling back to all-visible');\n        renderTarget.dispose();\n        depthMaterial.dispose();\n        return edges;\n    }\n\n    // Decode depth from RGBA using three.js formula\n    // See: https://github.com/mrdoob/three.js/blob/master/src/renderers/shaders/ShaderChunk/packing.glsl.js\n    // UnpackDownscale = 255/256\n    // UnpackFactors4 = (UnpackDownscale/1, UnpackDownscale/256, UnpackDownscale/65536, 1/16777216)\n    const UnpackDownscale = 255.0 / 256.0;\n    const PackFactors = [1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0];\n    const UnpackFactors4 = [\n        UnpackDownscale / PackFactors[0],  // 0.99609375\n        UnpackDownscale / PackFactors[1],  // 0.00389099...\n        UnpackDownscale / PackFactors[2],  // 0.0000152...\n        1.0 / PackFactors[3]               // 0.0000000059...\n    ];\n\n    /**\n     * \n     * @param {number} r \n     * @param {number} g \n     * @param {number} b \n     * @param {number} a \n     * @returns \n     */\n    const unpackDepth = (r, g, b, a) => {\n        // Normalize from 0-255 to 0-1\n        const rn = r / 255.0;\n        const gn = g / 255.0;\n        const bn = b / 255.0;\n        const an = a / 255.0;\n        // dot product with UnpackFactors4\n        return rn * UnpackFactors4[0] + gn * UnpackFactors4[1] + bn * UnpackFactors4[2] + an * UnpackFactors4[3];\n    };\n\n    // @ts-ignore\n    const near = camera.near;\n    // @ts-ignore  \n    const far = camera.far;\n\n    // Debug: log first few depth comparisons\n    let debugCount = 0;\n\n    for (const edge of edges) {\n        // Get screen-space coordinates of edge midpoint\n        const midX = (edge.a.x + edge.b.x) / 2;\n        const midY = (edge.a.y + edge.b.y) / 2;\n\n        const sx = Math.round(midX + width / 2);\n        const sy = Math.round(height / 2 + midY); // projectEdges already negates Y\n\n        // Check bounds\n        if (sx < 0 || sx >= width || sy < 0 || sy >= height) {\n            edge.visible = true;\n            visibleEdges.push(edge);\n            continue;\n        }\n\n        // Sample depth buffer (note: readRenderTargetPixels returns bottom-up)\n        const depthIdx = ((height - 1 - sy) * width + sx) * 4;\n        const sampledDepth = unpackDepth(\n            depthData[depthIdx],\n            depthData[depthIdx + 1],\n            depthData[depthIdx + 2],\n            depthData[depthIdx + 3]\n        );\n\n        // Compute expected depth using view-space Z (linear depth)\n        // MeshDepthMaterial stores: (viewZ - near) / (far - near) where viewZ is distance along camera's look direction\n        // For perspective cameras, we need to transform the midpoint to view space\n        const midpoint3d = edge.midpoint3d;\n\n        // Transform to view space (camera-relative coordinates)\n        const viewMatrix = camera.matrixWorldInverse;\n        const viewPos = midpoint3d.clone().applyMatrix4(viewMatrix);\n\n        // viewPos.z is negative in front of camera, so we negate it\n        const viewZ = -viewPos.z;\n\n        // Convert to 0-1 range matching MeshDepthMaterial\n        const expectedDepth = (viewZ - near) / (far - near);\n\n        // Debug logging\n        if (debugCount < 10) {\n            console.log(`Edge ${debugCount}: sample=${sampledDepth.toFixed(4)}, expected=${expectedDepth.toFixed(4)}, diff=${(sampledDepth - expectedDepth).toFixed(6)}`);\n            debugCount++;\n        }\n\n        // Compare: edge is visible if sampled depth >= expected depth (within tolerance)\n        // sampledDepth is depth of closest surface at this pixel\n        // expectedDepth is depth of the edge\n        // Edge is visible if it's at or in front of (closer than) the sampled surface\n        const isVisible = Math.abs(sampledDepth - expectedDepth) < epsilon || sampledDepth >= expectedDepth - epsilon;\n\n        if (isVisible) {\n            edge.visible = true;\n            visibleEdges.push(edge);\n        }\n    }\n\n    // Cleanup\n    renderTarget.dispose();\n    depthMaterial.dispose();\n\n    return visibleEdges;\n}\n\n/**\n * Test edge visibility using face ID buffer (correct occlusion)\n * Renders each face with a unique color = face index\n * Samples at edge midpoint to check if parent face is visible\n * @param {Edge2D[]} edges \n * @param {Mesh[]} meshes - All meshes in scene\n * @param {Camera} camera \n * @param {number} width - Viewport width\n * @param {number} height - Viewport height\n * @param {any} renderer - THREE.WebGLRenderer instance\n * @param {boolean} isProfile - If true, these are profile edges (always visible)\n * @returns {Edge2D[]}\n */\nexport function testOcclusionFaceID(edges, meshes, camera, width, height, renderer, isProfile = false) {\n    // Profile edges are ALWAYS visible (silhouette edges)\n    if (isProfile) {\n        edges.forEach(e => e.visible = true);\n        return edges;\n    }\n\n    const visibleEdges = [];\n\n    if (!renderer) {\n        console.warn('No renderer provided, skipping occlusion test');\n        return edges;\n    }\n\n    // Create render target for face IDs\n    const renderTarget = new WebGLRenderTarget(width, height, {\n        minFilter: NearestFilter,\n        magFilter: NearestFilter,\n        format: RGBAFormat,\n        type: UnsignedByteType\n    });\n\n    // Create face ID shader material\n    const faceIdMaterial = new ShaderMaterial({\n        vertexShader: `\n            attribute vec3 faceColor;\n            varying vec3 vFaceColor;\n            void main() {\n                vFaceColor = faceColor;\n                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n            }\n        `,\n        fragmentShader: `\n            varying vec3 vFaceColor;\n            void main() {\n                gl_FragColor = vec4(vFaceColor, 1.0);\n            }\n        `,\n        side: DoubleSide\n    });\n\n    // Build meshes with face ID colors\n    const faceIdMeshes = [];\n    let globalFaceOffset = 0;\n\n    for (const mesh of meshes) {\n        // @ts-ignore - Attach offset for later lookup\n        mesh.__globalFaceOffset = globalFaceOffset;\n        const geom = mesh.geometry;\n        const position = geom.attributes.position;\n        const index = geom.index;\n\n        const numFaces = index ? index.count / 3 : position.count / 3;\n\n        // Create new geometry with face colors - APPLY WORLD TRANSFORM\n        const newPositions = [];\n        const faceColors = [];\n\n        for (let f = 0; f < numFaces; f++) {\n            let i0, i1, i2;\n            if (index) {\n                i0 = index.getX(f * 3);\n                i1 = index.getX(f * 3 + 1);\n                i2 = index.getX(f * 3 + 2);\n            } else {\n                i0 = f * 3;\n                i1 = f * 3 + 1;\n                i2 = f * 3 + 2;\n            }\n\n            // Get vertices and APPLY WORLD TRANSFORM\n            const v0 = new Vector3(position.getX(i0), position.getY(i0), position.getZ(i0));\n            const v1 = new Vector3(position.getX(i1), position.getY(i1), position.getZ(i1));\n            const v2 = new Vector3(position.getX(i2), position.getY(i2), position.getZ(i2));\n\n            v0.applyMatrix4(mesh.matrixWorld);\n            v1.applyMatrix4(mesh.matrixWorld);\n            v2.applyMatrix4(mesh.matrixWorld);\n\n            // Add world-space positions\n            newPositions.push(v0.x, v0.y, v0.z, v1.x, v1.y, v1.z, v2.x, v2.y, v2.z);\n\n            // Encode face ID as RGB (globalFaceOffset + f + 1, reserve 0 for background)\n            const globalFaceId = globalFaceOffset + f + 1;\n            const r = (globalFaceId & 0xFF) / 255;\n            const g = ((globalFaceId >> 8) & 0xFF) / 255;\n            const b = ((globalFaceId >> 16) & 0xFF) / 255;\n\n            // Same color for all 3 vertices of this face\n            faceColors.push(r, g, b, r, g, b, r, g, b);\n        }\n\n        // Create geometry with world-space positions\n        const newGeom = new BufferGeometry();\n        newGeom.setAttribute('position', new BufferAttribute(new Float32Array(newPositions), 3));\n        newGeom.setAttribute('faceColor', new BufferAttribute(new Float32Array(faceColors), 3));\n\n        // Create mesh - no need for matrix since positions are already in world space\n        const faceIdMesh = new Mesh(newGeom, faceIdMaterial);\n        faceIdMeshes.push(faceIdMesh);\n\n        globalFaceOffset += numFaces;\n    }\n\n    // Create temporary scene with ALL face ID meshes\n    const tempScene = new Scene();\n    for (const faceIdMesh of faceIdMeshes) {\n        tempScene.add(faceIdMesh);\n    }\n\n    // Render ALL meshes TOGETHER in one pass\n    renderer.setRenderTarget(renderTarget);\n    renderer.setClearColor(0x000000, 1);\n    renderer.clear();\n    renderer.render(tempScene, camera);\n\n    // Read the render target\n    const faceIdData = new Uint8Array(width * height * 4);\n    renderer.readRenderTargetPixels(renderTarget, 0, 0, width, height, faceIdData);\n\n    // Restore renderer\n    renderer.setRenderTarget(null);\n\n    // Process edges\n    for (const edge of edges) {\n        const midX = (edge.a.x + edge.b.x) / 2;\n        const midY = (edge.a.y + edge.b.y) / 2;\n\n        const sx = Math.round(midX + width / 2);\n        const sy = Math.round(height / 2 + midY);\n\n        if (sx < 0 || sx >= width || sy < 0 || sy >= height) {\n            edge.visible = true;\n            visibleEdges.push(edge);\n            continue;\n        }\n\n        const idx = ((height - 1 - sy) * width + sx) * 4;\n        const r = faceIdData[idx];\n        const g = faceIdData[idx + 1];\n        const b = faceIdData[idx + 2];\n\n        const sampledFaceId = r + (g << 8) + (b << 16);\n\n        // If 0 (background), edge is visible\n        if (sampledFaceId === 0) {\n            edge.visible = true;\n            visibleEdges.push(edge);\n            continue;\n        }\n\n        // Edge parent face ID is faceIdx + 1 (we offset by 1 to reserve 0 for background)\n        // Add the mesh's global offset to its local face index.\n        // @ts-ignore - __globalFaceOffset is attached during mesh processing\n        const parentMeshOffset = edge.mesh.__globalFaceOffset || 0;\n        const parentFaceId = parentMeshOffset + edge.faceIdx + 1;\n\n        // Edge is visible if sampled face matches parent face\n        if (sampledFaceId === parentFaceId) {\n            edge.visible = true;\n            visibleEdges.push(edge);\n        } else {\n            // Also check the second face if it's a shared edge\n            if (edge.faceIdx2 !== undefined) {\n                const parentFaceId2 = parentMeshOffset + edge.faceIdx2 + 1;\n                if (sampledFaceId === parentFaceId2) {\n                    edge.visible = true;\n                    visibleEdges.push(edge);\n                    continue;\n                }\n            }\n            edge.visible = false;\n        }\n    }\n\n    // Cleanup\n    renderTarget.dispose();\n    faceIdMaterial.dispose();\n    for (const m of faceIdMeshes) {\n        m.geometry.dispose();\n    }\n\n    return visibleEdges;\n}\n\n/**\n * Pure mathematical point-in-triangle test (2D)\n * @param {Vector2} p - Point to test\n * @param {Vector2} a - Triangle vertex A\n * @param {Vector2} b - Triangle vertex B\n * @param {Vector2} c - Triangle vertex C\n * @returns {boolean}\n */\nfunction pointInTriangle2D(p, a, b, c) {\n    /**\n     * \n     * @param {Vector2} p1 \n     * @param {Vector2} p2 \n     * @param {Vector2} p3 \n     * @returns \n     */\n    const sign = (p1, p2, p3) =>\n        (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);\n\n    const d1 = sign(p, a, b);\n    const d2 = sign(p, b, c);\n    const d3 = sign(p, c, a);\n\n    const hasNeg = (d1 < 0) || (d2 < 0) || (d3 < 0);\n    const hasPos = (d1 > 0) || (d2 > 0) || (d3 > 0);\n\n    return !(hasNeg && hasPos);\n}\n\n/**\n * Check if edge lies along a face edge (collinear and within)\n * @param {Vector2} edgeA - Edge start point\n * @param {Vector2} edgeB - Edge end point\n * @param {Vector2} faceEdgeA - Face edge start point\n * @param {Vector2} faceEdgeB - Face edge end point\n * @param {number} tolerance - Distance tolerance in pixels\n * @returns {boolean}\n */\nfunction edgeLiesAlongFaceEdge(edgeA, edgeB, faceEdgeA, faceEdgeB, tolerance = 2.0) {\n    // Get face edge direction and length\n    const dx = faceEdgeB.x - faceEdgeA.x;\n    const dy = faceEdgeB.y - faceEdgeA.y;\n    const lenSq = dx * dx + dy * dy;\n    if (lenSq < 1e-10) return false;  // Degenerate face edge\n\n    // Project edge endpoints onto face edge line\n    /** @param {{x:number, y:number}} p - Point with x,y */\n    const projectAndCheck = (p) => {\n        // Project p onto line defined by faceEdgeA->faceEdgeB\n        const t = ((p.x - faceEdgeA.x) * dx + (p.y - faceEdgeA.y) * dy) / lenSq;\n\n        // Projected point\n        const projX = faceEdgeA.x + t * dx;\n        const projY = faceEdgeA.y + t * dy;\n\n        // Distance from p to projected point\n        const distSq = (p.x - projX) * (p.x - projX) + (p.y - projY) * (p.y - projY);\n\n        // Check if close to line and within segment (with small margin)\n        return distSq < tolerance * tolerance && t >= -0.01 && t <= 1.01;\n    };\n\n    // Both edge endpoints must lie along the face edge\n    return projectAndCheck(edgeA) && projectAndCheck(edgeB);\n}\n\n/**\n * Find all faces adjacent to an edge geometrically\n * @param {Edge2D} edge - Edge with a, b (2D points)\n * @param {ProjectedFace[]} projectedFaces - Array of projected faces\n * @returns {{ face: ProjectedFace, matchedEdge: string, matchType: string}[]} - Array of matching faces with match type\n */\nexport function findAdjacentFaces(edge, projectedFaces) {\n    const results = [];\n\n    for (const face of projectedFaces) {\n        // Get the three edges of the face\n        const faceEdges = [\n            { a: face.a2d, b: face.b2d, name: 'AB' },\n            { a: face.b2d, b: face.c2d, name: 'BC' },\n            { a: face.c2d, b: face.a2d, name: 'CA' }\n        ];\n\n        for (const fe of faceEdges) {\n            if (edgeLiesAlongFaceEdge(edge.a, edge.b, fe.a, fe.b)) {\n                results.push({\n                    face,\n                    matchedEdge: fe.name,\n                    matchType: 'collinear'\n                });\n                break;  // Found a match for this face, move to next\n            }\n        }\n    }\n\n    return results;\n}\n\n/**\n * Compute depth at point inside triangle using barycentric interpolation\n * @param {Vector2} p - Point to compute depth at\n * @param {Vector2} a - Triangle vertex A (2D)\n * @param {Vector2} b - Triangle vertex B (2D)\n * @param {Vector2} c - Triangle vertex C (2D)\n * @param {number} depthA - Depth at vertex A\n * @param {number} depthB - Depth at vertex B\n * @param {number} depthC - Depth at vertex C\n * @returns {number} - Interpolated depth at p\n */\nfunction barycentricDepth(p, a, b, c, depthA, depthB, depthC) {\n    // Compute barycentric coordinates\n    const v0 = { x: c.x - a.x, y: c.y - a.y };\n    const v1 = { x: b.x - a.x, y: b.y - a.y };\n    const v2 = { x: p.x - a.x, y: p.y - a.y };\n\n    const dot00 = v0.x * v0.x + v0.y * v0.y;\n    const dot01 = v0.x * v1.x + v0.y * v1.y;\n    const dot02 = v0.x * v2.x + v0.y * v2.y;\n    const dot11 = v1.x * v1.x + v1.y * v1.y;\n    const dot12 = v1.x * v2.x + v1.y * v2.y;\n\n    const denom = dot00 * dot11 - dot01 * dot01;\n    if (Math.abs(denom) < 1e-10) return Infinity;\n\n    const u = (dot11 * dot02 - dot01 * dot12) / denom;\n    const v = (dot00 * dot12 - dot01 * dot02) / denom;\n    const w = 1 - u - v;\n\n    return w * depthA + v * depthB + u * depthC;\n}\n\n/**\n * Post-split smooth filter: removes T-junction straggler edges that lie on a coplanar face\n * This catches \"straggler\" edges from T-junctions that extend into smooth surfaces\n * @param {Edge2D[]} edges - Split edges to filter\n * @param {ProjectedFace[]} projectedFaces - Projected faces with normals\n * @param {number} coplanarThreshold - Normal dot product threshold (default 0.99)\n * @param {number} distanceThreshold - Plane distance threshold (default 0.5)\n * @returns {Edge2D[]}\n */\nexport function filterSmoothSplitEdges(edges, projectedFaces, coplanarThreshold = 0.99, distanceThreshold = 0.5) {\n    const filteredEdges = [];\n    let removedCount = 0;\n\n    for (const edge of edges) {\n        // Find all adjacent faces geometrically\n        const adjacentFaces = findAdjacentFaces(edge, projectedFaces);\n\n        // Store adjacent face count for debugging\n        edge.adjacentFaceCount = adjacentFaces.length;\n\n        let shouldRemove = false;\n\n        // Only remove if we have exactly 2 faces with matching normals AND matching plane constants\n        if (adjacentFaces.length === 2) {\n            const f1 = adjacentFaces[0].face;\n            const f2 = adjacentFaces[1].face;\n            const fn1 = f1.normal;\n            const fn2 = f2.normal;\n\n            if (fn1 && fn2) {\n                const dot = fn1.dot(fn2);\n                const similarity = Math.abs(dot);\n                edge.faceSimilarity = similarity;\n\n                // Check distance between planes (must be very close to be truly coplanar)\n                // If normals are parallel (dot > 0), d1 ~ d2 => diff ~ 0\n                // If normals are anti-parallel (dot < 0), d1 ~ -d2 => sum ~ 0\n                let distDiff;\n                if (dot > 0) {\n                    distDiff = Math.abs(f1.constant - f2.constant);\n                } else {\n                    distDiff = Math.abs(f1.constant + f2.constant);\n                }\n\n                if (similarity >= coplanarThreshold && distDiff < distanceThreshold) {\n                    // Edge lies between exactly 2 coplanar faces - remove it\n                    shouldRemove = true;\n                    removedCount++;\n                }\n            }\n        } else if (adjacentFaces.length > 2) {\n            // 3+ faces: check if ALL normals match AND ALL planes match\n            const faces = adjacentFaces.map(af => af.face).filter(f => f.normal);\n            if (faces.length >= 2) {\n                let allCoplanar = true;\n                let minSimilarity = 1;\n\n                for (let i = 1; i < faces.length; i++) {\n                    const dot = faces[0].normal.dot(faces[i].normal);\n                    const sim = Math.abs(dot);\n\n                    let distDiff;\n                    if (dot > 0) {\n                        distDiff = Math.abs(faces[0].constant - faces[i].constant);\n                    } else {\n                        distDiff = Math.abs(faces[0].constant + faces[i].constant);\n                    }\n\n                    minSimilarity = Math.min(minSimilarity, sim);\n\n                    if (sim < coplanarThreshold || distDiff >= distanceThreshold) {\n                        allCoplanar = false;\n                        break;\n                    }\n                }\n                edge.faceSimilarity = minSimilarity;\n\n                if (allCoplanar) {\n                    shouldRemove = true;\n                    removedCount++;\n                }\n            }\n        }\n\n        if (!shouldRemove) {\n            filteredEdges.push(edge);\n        }\n    }\n\n    console.log(`Geometric straggler filter: removed ${removedCount} coplanar edges`);\n    return filteredEdges;\n}\n/**\n * Test edge visibility using pure math (point-in-triangle + depth)\n * No GPU, no raycasting - fully mathematical\n * @param {Edge2D[]} edges \n * @param {ProjectedFace[]} projectedFaces - Array of {a2d, b2d, c2d, depthA, depthB, depthC, mesh, faceIdx}\n * @param {Camera} camera\n * @returns {Edge2D[]}\n */\nexport function testOcclusionMath(edges, projectedFaces, camera) {\n    const cameraPos = camera.position;\n    const viewMatrix = camera.matrixWorldInverse;\n\n    // JS fallback\n    return testOcclusionMathJS(edges, projectedFaces, cameraPos, viewMatrix);\n}\n\n/**\n * JS fallback for occlusion testing\n * @param {Edge2D[]} edges \n * @param {ProjectedFace[]} projectedFaces \n * @param {Vector3} cameraPos \n * @param {import('three').Matrix4} [viewMatrix] - Optional view matrix for proper depth calculation\n * @returns {Edge2D[]}\n */\nfunction testOcclusionMathJS(edges, projectedFaces, cameraPos, viewMatrix) {\n    const visibleEdges = [];\n    let debugHitCount = 0;\n    let debugOccludedCount = 0;\n\n    for (const edge of edges) {\n        // Get midpoint in 2D and 3D\n        const mid2d = new Vector2(\n            (edge.a.x + edge.b.x) / 2,\n            (edge.a.y + edge.b.y) / 2\n        );\n\n        // Compute edge midpoint depth using view-space Z-coordinate\n        // This correctly handles perspective distortion (not Euclidean distance)\n        const mid3d = edge.midpoint3d;\n        let edgeDepth;\n        if (viewMatrix) {\n            // Use view-space Z for proper perspective handling\n            edgeDepth = -mid3d.clone().applyMatrix4(viewMatrix).z;\n        } else {\n            // Fallback to Euclidean distance if no view matrix\n            edgeDepth = cameraPos.distanceTo(mid3d);\n        }\n\n        let occluded = false;\n\n        // Check against ALL faces\n        for (const face of projectedFaces) {\n            // Skip if this is the edge's parent face\n            if (face.mesh === edge.mesh &&\n                (face.faceIdx === edge.faceIdx || face.faceIdx === edge.faceIdx2)) {\n                continue;\n            }\n\n            // Point-in-triangle test in 2D\n            if (!pointInTriangle2D(mid2d, face.a2d, face.b2d, face.c2d)) {\n                continue;\n            }\n\n            // Compute depth of the face at this 2D point\n            const faceDepthAtPoint = barycentricDepth(\n                mid2d, face.a2d, face.b2d, face.c2d,\n                face.depthA, face.depthB, face.depthC\n            );\n\n            // If face is closer  edge is occluded\n            if (faceDepthAtPoint < edgeDepth - 0.001) {\n                occluded = true;\n                debugOccludedCount++;\n                break;\n            }\n            debugHitCount++;\n        }\n\n        if (!occluded) {\n            edge.visible = true;\n            visibleEdges.push(edge);\n        } else {\n            edge.visible = false;\n        }\n    }\n\n    console.log(`[JS] Occlusion debug: ${debugHitCount} point-in-triangle hits, ${debugOccludedCount} occluded`);\n    return visibleEdges;\n}\n\n/**\n * Test edge visibility using raycasting (slow fallback)\n * @param {Edge2D[]} edges \n * @param {Scene} scene \n * @param {Camera} camera \n * @param {number} epsilon - Distance tolerance (as fraction of distance)\n * @returns {Edge2D[]}\n */\nexport function testOcclusion(edges, scene, camera, epsilon = 0.05) {\n    const raycaster = new Raycaster();\n    const visibleEdges = [];\n\n    // Collect all meshes in the scene for intersection testing\n    /** @type {any[]} */\n    const meshes = [];\n    scene.traverse((obj) => {\n        // @ts-ignore - isMesh exists on Mesh objects\n        if (obj.isMesh) {\n            meshes.push(obj);\n        }\n    });\n\n    for (const edge of edges) {\n        // Get direction from camera to midpoint\n        const toMidpoint = new Vector3().subVectors(edge.midpoint3d, camera.position);\n        const direction = toMidpoint.clone().normalize();\n        const expectedDist = toMidpoint.length();\n\n        // Use relative epsilon based on distance\n        const relEps = expectedDist * epsilon;\n\n        // Raycast from camera towards the edge midpoint\n        raycaster.set(camera.position.clone(), direction);\n\n        const intersects = raycaster.intersectObjects(meshes, true);\n\n        if (intersects.length === 0) {\n            // No hit - edge is visible\n            edge.visible = true;\n            visibleEdges.push(edge);\n        } else {\n            // Check if any hit is significantly in front of the edge\n            let occluded = false;\n\n            for (const hit of intersects) {\n                // Skip hits at or beyond the edge's depth\n                if (hit.distance >= expectedDist - relEps) {\n                    continue;\n                }\n\n                // For same-mesh hits, check if it's the edge's own face\n                if (hit.object === edge.mesh) {\n                    // Skip if this is the same face the edge belongs to\n                    if (hit.faceIndex === edge.faceIdx) {\n                        continue;\n                    }\n                }\n\n                // Something is in front of the edge - it's occluded\n                occluded = true;\n                break;\n            }\n\n            if (!occluded) {\n                edge.visible = true;\n                visibleEdges.push(edge);\n            } else {\n                edge.visible = false;\n            }\n        }\n    }\n\n    return visibleEdges;\n}\n\n/**\n * Remove duplicate segments and merge colinear ones\n * @param {Edge2D[]} edges \n * @param {number} tolerance \n * @returns {Edge2D[]}\n */\nexport function optimizeEdges(edges, tolerance = 0.5) {\n    // Deduplicate using hash\n    /** @type {Map<string, Edge2D>} */\n    const unique = new Map();\n\n    /** @param {Point2D} p */\n    const hashPoint = (p) => `${Math.round(p.x / tolerance)},${Math.round(p.y / tolerance)}`;\n    /** @param {Edge2D} e */\n    const hashEdge = (e) => {\n        const h1 = hashPoint(e.a);\n        const h2 = hashPoint(e.b);\n        return h1 < h2 ? `${h1}-${h2}` : `${h2}-${h1}`;\n    };\n\n    for (const edge of edges) {\n        const key = hashEdge(edge);\n        if (!unique.has(key)) {\n            unique.set(key, edge);\n        }\n    }\n\n    // TODO: Merge colinear segments\n\n    return Array.from(unique.values());\n}\n\n/**\n * Cleanup orphaned edges by extending to find intersections\n * An orphaned endpoint is a vertex with only 1 connected edge\n * Strategy: extend orphan edges and find line-line intersections\n * @param {Edge2D[]} edges - Edges to clean up\n * @param {number} tolerance - Distance tolerance for vertex matching\n * @param {number} maxExtension - Maximum distance to extend an edge\n * @returns {Edge2D[]}\n */\nexport function cleanupOrphanedEdges(edges, tolerance = 1.0, maxExtension = 50) {\n    // Build vertex -> edge connectivity map\n\n    const vertexKey = (/** @type {Point2D} */ p) => `${Math.round(p.x / tolerance)},${Math.round(p.y / tolerance)}`;\n\n    // Map of vertex hash -> { edges: [{edge, endpoint: 'a'|'b'}], point: Point2D }\n    const vertices = new Map();\n\n    for (const edge of edges) {\n        for (const endpoint of /** @type {const} */ (['a', 'b'])) {\n            /** @type {Point2D} */\n            const p = endpoint === 'a' ? edge.a : edge.b;\n            const key = vertexKey(p);\n            if (!vertices.has(key)) {\n                vertices.set(key, { edges: [], point: { x: p.x, y: p.y } });\n            }\n            vertices.get(key).edges.push({ edge, endpoint });\n        }\n    }\n\n    // Find orphaned endpoints (vertices with only 1 edge)\n    const orphans = [];\n    for (const [key, vertex] of vertices) {\n        if (vertex.edges.length === 1) {\n            const { edge, endpoint } = vertex.edges[0];\n            const orphanPoint = vertex.point;\n            const otherPoint = endpoint === 'a' ? edge.b : edge.a;\n\n            // Compute direction (from fixed end toward orphan end)\n            const dx = orphanPoint.x - otherPoint.x;\n            const dy = orphanPoint.y - otherPoint.y;\n            const len = Math.sqrt(dx * dx + dy * dy);\n            if (len < 0.001) continue;\n\n            orphans.push({\n                key,\n                edge,\n                endpoint,\n                point: orphanPoint,\n                otherPoint,\n                dirX: dx / len,\n                dirY: dy / len,\n                len\n            });\n        }\n    }\n\n    console.log(`Edge cleanup: found ${orphans.length} orphaned endpoints`);\n    if (orphans.length === 0) return edges;\n\n    // Line-line intersection helper\n    // Returns t values for intersection point on both lines, or null if parallel\n    /**\n     * \n     * @param {Point2D} p1 \n     * @param {Point2D} d1 \n     * @param {Point2D} p2 \n     * @param {Point2D} d2 \n     * @returns {{t1: number, t2: number}|null}\n     */\n    const lineIntersection = (p1, d1, p2, d2) => {\n        const cross = d1.x * d2.y - d1.y * d2.x;\n        if (Math.abs(cross) < 0.0001) return null; // Parallel\n\n        const dx = p2.x - p1.x;\n        const dy = p2.y - p1.y;\n\n        const t1 = (dx * d2.y - dy * d2.x) / cross;\n        const t2 = (dx * d1.y - dy * d1.x) / cross;\n\n        return { t1, t2 };\n    };\n\n    let extensionsCount = 0;\n    const processed = new Set();\n\n    for (let i = 0; i < orphans.length; i++) {\n        const orphan = orphans[i];\n        if (processed.has(orphan.key)) continue;\n\n        let bestMatch = null;\n        /** @type {Point2D | null} */\n        let bestIntersection = null;\n        let bestDist = Infinity;\n\n        for (let j = 0; j < orphans.length; j++) {\n            if (i === j) continue;\n            const candidate = orphans[j];\n            if (processed.has(candidate.key)) continue;\n\n            // Check if candidate's orphan point is reasonably close\n            const dist = Math.sqrt(\n                (candidate.point.x - orphan.point.x) ** 2 +\n                (candidate.point.y - orphan.point.y) ** 2\n            );\n            if (dist > maxExtension * 2) continue;\n\n            // Extend both lines and find intersection\n            // orphan: starts at orphan.point, direction orphan.dirX/dirY\n            // candidate: starts at candidate.point, direction candidate.dirX/dirY\n            const result = lineIntersection(\n                { x: orphan.point.x, y: orphan.point.y },\n                { x: orphan.dirX, y: orphan.dirY },\n                { x: candidate.point.x, y: candidate.point.y },\n                { x: candidate.dirX, y: candidate.dirY }\n            );\n\n            if (!result) continue; // Parallel lines\n\n            // t1 > 0 means intersection is in forward direction from orphan\n            // t2 > 0 means intersection is in forward direction from candidate\n            // Both must be positive (extending, not backtracking)\n            if (result.t1 < -0.1 || result.t2 < -0.1) continue;\n            if (result.t1 > maxExtension || result.t2 > maxExtension) continue;\n\n            // Compute intersection point\n            const ix = orphan.point.x + result.t1 * orphan.dirX;\n            const iy = orphan.point.y + result.t1 * orphan.dirY;\n\n            // Prefer closer intersections\n            const intersectDist = result.t1 + result.t2;\n            if (intersectDist < bestDist) {\n                bestDist = intersectDist;\n                bestMatch = candidate;\n                bestIntersection = { x: ix, y: iy };\n            }\n        }\n\n        if (bestMatch && bestIntersection) {\n            // Check if extension would cross any other edges\n            // Check segment from orphan.point to intersection\n            const crosses1 = segmentCrossesEdges(\n                orphan.point,\n                bestIntersection,\n                edges,\n                orphan.edge,\n                bestMatch.edge\n            );\n            // Check segment from bestMatch.point to intersection\n            const crosses2 = segmentCrossesEdges(\n                bestMatch.point,\n                bestIntersection,\n                edges,\n                orphan.edge,\n                bestMatch.edge\n            );\n\n            if (crosses1 || crosses2) {\n                // Skip this extension - it would cross existing edges\n                continue;\n            }\n\n            // Extend both edges to meet at intersection point\n            if (orphan.endpoint === 'a') {\n                orphan.edge.a.x = bestIntersection.x;\n                orphan.edge.a.y = bestIntersection.y;\n            } else {\n                orphan.edge.b.x = bestIntersection.x;\n                orphan.edge.b.y = bestIntersection.y;\n            }\n\n            if (bestMatch.endpoint === 'a') {\n                bestMatch.edge.a.x = bestIntersection.x;\n                bestMatch.edge.a.y = bestIntersection.y;\n            } else {\n                bestMatch.edge.b.x = bestIntersection.x;\n                bestMatch.edge.b.y = bestIntersection.y;\n            }\n\n            processed.add(orphan.key);\n            processed.add(bestMatch.key);\n            extensionsCount++;\n        }\n    }\n\n    console.log(`Edge cleanup: extended ${extensionsCount} pairs of edges to intersections`);\n\n    // Calculate average edge length for threshold\n    let totalLength = 0;\n    for (const edge of edges) {\n        const dx = edge.b.x - edge.a.x;\n        const dy = edge.b.y - edge.a.y;\n        totalLength += Math.sqrt(dx * dx + dy * dy);\n    }\n    const avgEdgeLength = totalLength / edges.length;\n    const snapThreshold = avgEdgeLength / 8;\n\n    console.log(`Edge cleanup: average edge length = ${avgEdgeLength.toFixed(2)}, snap threshold = ${snapThreshold.toFixed(2)}`);\n\n    // Rebuild orphan list after extensions\n    const finalVertices = new Map();\n    for (const edge of edges) {\n        for (const endpoint of /** @type {const} */ (['a', 'b'])) {\n            /** @type {Point2D} */\n            const p = endpoint === 'a' ? edge.a : edge.b;\n            const key = vertexKey(p);\n            if (!finalVertices.has(key)) {\n                finalVertices.set(key, { edges: [], point: p });\n            }\n            finalVertices.get(key).edges.push({ edge, endpoint });\n        }\n    }\n\n    // Find remaining orphans\n    const finalOrphans = [];\n    for (const [key, vertex] of finalVertices) {\n        if (vertex.edges.length === 1) {\n            finalOrphans.push({ key, ...vertex.edges[0], point: vertex.point });\n        }\n    }\n\n    console.log(`Edge cleanup: ${finalOrphans.length} orphaned endpoints before snap pass`);\n\n    // Snap nearby orphans together\n    let snapCount = 0;\n    const snapped = new Set();\n\n    for (let i = 0; i < finalOrphans.length; i++) {\n        const orphan = finalOrphans[i];\n        if (snapped.has(orphan.key)) continue;\n\n        let nearestOrphan = null;\n        let nearestDist = Infinity;\n\n        for (let j = 0; j < finalOrphans.length; j++) {\n            if (i === j) continue;\n            const candidate = finalOrphans[j];\n            if (snapped.has(candidate.key)) continue;\n\n            const dist = Math.sqrt(\n                (candidate.point.x - orphan.point.x) ** 2 +\n                (candidate.point.y - orphan.point.y) ** 2\n            );\n\n            if (dist < nearestDist) {\n                nearestDist = dist;\n                nearestOrphan = candidate;\n            }\n        }\n\n        if (nearestOrphan && nearestDist < snapThreshold) {\n            // Snap both to the midpoint\n            const midX = (orphan.point.x + nearestOrphan.point.x) / 2;\n            const midY = (orphan.point.y + nearestOrphan.point.y) / 2;\n\n            if (orphan.endpoint === 'a') {\n                orphan.edge.a.x = midX;\n                orphan.edge.a.y = midY;\n            } else {\n                orphan.edge.b.x = midX;\n                orphan.edge.b.y = midY;\n            }\n\n            if (nearestOrphan.endpoint === 'a') {\n                nearestOrphan.edge.a.x = midX;\n                nearestOrphan.edge.a.y = midY;\n            } else {\n                nearestOrphan.edge.b.x = midX;\n                nearestOrphan.edge.b.y = midY;\n            }\n\n            snapped.add(orphan.key);\n            snapped.add(nearestOrphan.key);\n            snapCount++;\n        }\n    }\n\n    console.log(`Edge cleanup: snapped ${snapCount} pairs of nearby orphans`);\n\n    // Final count\n    const remainingOrphans = finalOrphans.length - (snapCount * 2);\n    console.log(`Edge cleanup: ${remainingOrphans} orphaned endpoints remaining`);\n\n    return edges;\n}\n\n/**\n * Remove isolated edges where BOTH endpoints are orphaned (no connections to other edges)\n * These are floating edge fragments that don't connect to anything\n * @param {Edge2D[]} edges - Edges to filter\n * @param {number} tolerance - Distance tolerance for vertex matching\n * @returns {Edge2D[]} Filtered edges\n */\nexport function removeIsolatedEdges(edges, tolerance = 1.0) {\n\n    const vertexKey = (/** @type {Vector2} */ p) => `${Math.round(p.x / tolerance)},${Math.round(p.y / tolerance)}`;\n\n    // Count connections per vertex\n    const vertexConnections = new Map();\n\n    for (const edge of edges) {\n        const keyA = vertexKey(edge.a);\n        const keyB = vertexKey(edge.b);\n\n        vertexConnections.set(keyA, (vertexConnections.get(keyA) || 0) + 1);\n        vertexConnections.set(keyB, (vertexConnections.get(keyB) || 0) + 1);\n    }\n\n    // Filter out edges where both endpoints have only 1 connection (orphaned at both ends)\n    const filtered = edges.filter(edge => {\n        const keyA = vertexKey(edge.a);\n        const keyB = vertexKey(edge.b);\n        const connectionsA = vertexConnections.get(keyA) || 0;\n        const connectionsB = vertexConnections.get(keyB) || 0;\n\n        // Keep edge if at least one endpoint has 2+ connections\n        return connectionsA >= 2 || connectionsB >= 2;\n    });\n\n    const removed = edges.length - filtered.length;\n    if (removed > 0) {\n        console.log(`Edge cleanup: removed ${removed} isolated edges (orphaned at both ends)`);\n    }\n\n    return filtered;\n}\n\n/**\n * Check if a segment from p1 to p2 crosses any existing edge\n * @param {Point2D} p1 - Start point\n * @param {Point2D} p2 - End point\n * @param {Edge2D[]} edges - Existing edges to check against\n * @param {Edge2D} excludeEdge1 - Edge to exclude from check\n * @param {Edge2D} excludeEdge2 - Edge to exclude from check\n * @returns {boolean} True if segment crosses an edge\n */\nfunction segmentCrossesEdges(p1, p2, edges, excludeEdge1, excludeEdge2) {\n    const eps = 0.001;\n\n    for (const edge of edges) {\n        if (edge === excludeEdge1 || edge === excludeEdge2) continue;\n\n        // Check if segment p1->p2 intersects edge.a->edge.b\n        const d1x = p2.x - p1.x;\n        const d1y = p2.y - p1.y;\n        const d2x = edge.b.x - edge.a.x;\n        const d2y = edge.b.y - edge.a.y;\n\n        const cross = d1x * d2y - d1y * d2x;\n        if (Math.abs(cross) < eps) continue; // Parallel\n\n        const dx = edge.a.x - p1.x;\n        const dy = edge.a.y - p1.y;\n\n        const t1 = (dx * d2y - dy * d2x) / cross;\n        const t2 = (dx * d1y - dy * d1x) / cross;\n\n        // Check if intersection is within both segments (with small margin)\n        if (t1 > eps && t1 < 1 - eps && t2 > eps && t2 < 1 - eps) {\n            return true; // Crosses an edge\n        }\n    }\n\n    return false;\n}\n\n/**\n * Main hidden line removal function\n * @param {Mesh} mesh \n * @param {Camera} camera \n * @param {Scene} scene \n * @param {Object} options\n * @param {number} [options.smoothThreshold] - Threshold for smooth edge removal (default 0.99)\n * @param {number} [options.gridSize] - Spatial hash grid size (default 32)\n * @param {number} [options.occlusionEpsilon] - Occlusion test tolerance (relative to camera distance)\n * @param {boolean} [options.skipOcclusion] - Skip occlusion testing (debug mode)\n * @param {number} [options.width] - Viewport width\n * @param {number} [options.height] - Viewport height\n * @param {any} [options.renderer] - THREE.WebGLRenderer for depth buffer occlusion (fast)\n * @returns {{edges: Edge2D[], profiles: Edge2D[]}}\n */\nexport function computeHiddenLines(mesh, camera, scene, options = {}) {\n    const {\n        smoothThreshold = 0.99,\n        gridSize = 32,\n        occlusionEpsilon = 0.01, // 1% depth tolerance for depth buffer\n        skipOcclusion = false,\n        width = 800,\n        height = 600,\n        renderer = null\n    } = options;\n\n    console.time('extractEdges');\n    const edges3d = extractEdges(mesh, camera.position);\n    console.timeEnd('extractEdges');\n    console.log(`Extracted ${edges3d.length} edges`);\n\n    console.time('filterBackfacing');\n    const frontEdges = filterBackfacing(edges3d, camera.position);\n    console.timeEnd('filterBackfacing');\n    console.log(`After backface filter: ${frontEdges.length} edges`);\n\n    console.time('classifyEdges');\n    const { profiles, smoothFiltered } = classifyEdges(frontEdges, camera.position, smoothThreshold);\n    console.timeEnd('classifyEdges');\n    console.log(`Profiles: ${profiles.length}, Smooth edges: ${smoothFiltered.length}`);\n\n    // Combine profile and smooth edges for processing\n    const allEdges = [...profiles, ...smoothFiltered];\n\n    console.time('projectEdges');\n    let edges2d = projectEdges(allEdges, camera, width, height);\n    console.timeEnd('projectEdges');\n\n    // Mark profile edges\n    for (let i = 0; i < profiles.length; i++) {\n        edges2d[i].isProfile = true;\n    }\n\n    console.time('spatialHash');\n    const cellSize = Math.max(width, height) / gridSize;\n    const hash = new SpatialHash(cellSize);\n    for (const edge of edges2d) {\n        hash.insert(edge);\n    }\n    console.timeEnd('spatialHash');\n\n    console.time('splitIntersections');\n    // Process each cell\n    const processedEdges = new Set();\n    let splitEdges = [];\n\n    for (const cellKey of hash.getAllCells()) {\n        const cellEdges = hash.query(cellKey).filter(e => !processedEdges.has(e));\n        const split = splitAtIntersections(cellEdges);\n        splitEdges.push(...split);\n        for (const e of cellEdges) processedEdges.add(e);\n    }\n    console.timeEnd('splitIntersections');\n    console.log(`After splitting: ${splitEdges.length} edges`);\n\n    let visibleEdges;\n    if (skipOcclusion) {\n        console.log('Skipping occlusion test (debug mode)');\n        visibleEdges = splitEdges;\n    } else if (renderer) {\n        console.time('testOcclusion (face ID buffer)');\n        // Separate profile and non-profile edges\n        const profileEdges = splitEdges.filter(e => e.isProfile);\n        const otherEdges = splitEdges.filter(e => !e.isProfile);\n\n        // Profile edges are ALWAYS visible (silhouette edges)\n        profileEdges.forEach(e => e.visible = true);\n\n        // Test occlusion only for non-profile edges using face ID buffer\n        const visibleOtherEdges = testOcclusionFaceID(otherEdges, [mesh], camera, width, height, renderer, false);\n\n        visibleEdges = [...profileEdges, ...visibleOtherEdges];\n        console.timeEnd('testOcclusion (face ID buffer)');\n    } else {\n        console.time('testOcclusion (raycaster - slow)');\n        visibleEdges = testOcclusion(splitEdges, scene, camera, occlusionEpsilon);\n        console.timeEnd('testOcclusion (raycaster - slow)');\n    }\n    console.log(`Visible edges: ${visibleEdges.length}`);\n\n    console.time('optimize');\n    const optimizedEdges = optimizeEdges(visibleEdges);\n    console.timeEnd('optimize');\n\n    console.time('cleanup orphans');\n    const finalEdges = cleanupOrphanedEdges(optimizedEdges);\n    console.timeEnd('cleanup orphans');\n    console.log(`Final edges: ${finalEdges.length}`);\n\n    return {\n        edges: finalEdges,\n        profiles: finalEdges.filter(e => e.isProfile)\n    };\n}\n\n/**\n * Hidden line removal for multiple meshes with cross-object occlusion\n * All meshes are rendered to a single face ID buffer for correct occlusion\n * @param {Mesh[]} meshes \n * @param {Camera} camera \n * @param {Scene} scene \n * @param {Object} options\n * @param {number} [options.smoothThreshold]\n * @param {number} [options.gridSize]\n * @param {boolean} [options.skipOcclusion]\n * @param {number} [options.width]\n * @param {number} [options.height]\n * @param {any} [options.renderer]\n * @param {Edge3D[]} [options.hatchEdges] - Optional array of Edge3D objects for hatching\n * @param {number} [options.minHatchDotProduct] - Minimum dot product with view vector to keep hatch edges (0-1)\n * @param {number} [options.internalScale] - Internal scale factor (default: 4)\n * @param {number} [options.distanceThreshold] - Distance threshold for coplanar detection (default: 0.5)\n * @returns {{edges: Edge2D[], profiles: Edge2D[], allEdges: Edge2D[], projectedFaces: ProjectedFace[]}}\n */\nexport function computeHiddenLinesMultiple(meshes, camera, scene, options = {}) {\n    const {\n        smoothThreshold = 0.99,\n        gridSize = 32,\n        skipOcclusion = false,\n        width = 800,\n        height = 600,\n        renderer = null,\n        internalScale = 4,  // Scale up internally for better precision\n        distanceThreshold = 0.5 // Default plane distance threshold\n    } = options;\n\n    // Process each mesh to extract edges (keep local face indices with mesh reference)\n    let allEdges3d = [];\n\n    for (const mesh of meshes) {\n        mesh.updateMatrixWorld(true);\n        const edges3d = extractEdges(mesh, camera.position);\n        // Edges already have mesh reference and local faceIdx1/faceIdx2 from extractEdges\n        allEdges3d.push(...edges3d);\n    }\n\n    console.log(`Extracted ${allEdges3d.length} edges from ${meshes.length} meshes`);\n\n    // Classify edges: identify profiles and filter smooth edges\n    const { profiles, smoothFiltered } = classifyEdges(allEdges3d, camera.position, smoothThreshold);\n    console.log(`Profiles: ${profiles.length}, Crease edges: ${smoothFiltered.length}`);\n\n    const allEdges = [...profiles, ...smoothFiltered];\n    console.log(`After smooth filter: ${allEdges.length} edges`);\n\n    // Project to 2D (with internal scale for precision)\n    let edges2d = projectEdges(allEdges, camera, width, height, internalScale);\n\n    // Process additional hatch edges if provided\n    if (options.hatchEdges && options.hatchEdges.length > 0) {\n        console.log(`Processing ${options.hatchEdges.length} hatch edges...`);\n        // Filter backfacing hatch edges\n        let visibleHatch = filterBackfacing(options.hatchEdges, camera.position);\n\n        // Filter over-dense hatching based on view angle\n        if (options.minHatchDotProduct !== undefined) {\n            const threshold = options.minHatchDotProduct;\n            visibleHatch = visibleHatch.filter(edge => {\n                const edgeMidpoint = new Vector3().addVectors(edge.a, edge.b).multiplyScalar(0.5);\n                const viewDir = new Vector3().subVectors(camera.position, edgeMidpoint).normalize();\n                const dot = edge.normal1.dot(viewDir);\n                return Math.abs(dot) >= threshold;\n            });\n            console.log(`Density filter: kept ${visibleHatch.length} hatch edges (threshold ${threshold})`);\n        }\n\n        // Project\n        const hatch2d = projectEdges(visibleHatch, camera, width, height, internalScale);\n\n        // Mark explicitly (in case projectEdges didn't catch it from source)\n        hatch2d.forEach(e => e.isHatch = true);\n\n        // Add to main list\n        edges2d.push(...hatch2d);\n        console.log(`Added ${hatch2d.length} visible hatch edges`);\n    }\n\n    // Mark profile edges\n    // Split all edges at intersections (direct O(n) comparison - no spatial hash)\n    console.time('splitIntersections');\n    const splitEdges = splitAtIntersections(edges2d);\n    console.timeEnd('splitIntersections');\n    console.log(`After splitting: ${splitEdges.length} edges`);\n\n    // Build projected faces array for math occlusion\n    console.time('buildProjectedFaces');\n    /** @type {ProjectedFace[]} */\n    const projectedFaces = [];\n    const cameraPos = camera.position;\n    const halfWidth = width / 2;\n    const halfHeight = height / 2;\n\n    for (const mesh of meshes) {\n        const geom = mesh.geometry;\n        const position = geom.attributes.position;\n        const index = geom.index;\n        const numFaces = index ? index.count / 3 : position.count / 3;\n\n        for (let f = 0; f < numFaces; f++) {\n            let i0, i1, i2;\n            if (index) {\n                i0 = index.getX(f * 3);\n                i1 = index.getX(f * 3 + 1);\n                i2 = index.getX(f * 3 + 2);\n            } else {\n                i0 = f * 3;\n                i1 = f * 3 + 1;\n                i2 = f * 3 + 2;\n            }\n\n            // Get world-space vertices\n            const v0 = new Vector3(position.getX(i0), position.getY(i0), position.getZ(i0)).applyMatrix4(mesh.matrixWorld);\n            const v1 = new Vector3(position.getX(i1), position.getY(i1), position.getZ(i1)).applyMatrix4(mesh.matrixWorld);\n            const v2 = new Vector3(position.getX(i2), position.getY(i2), position.getZ(i2)).applyMatrix4(mesh.matrixWorld);\n\n            // Compute face normal and check if front-facing\n            const edge1 = new Vector3().subVectors(v1, v0);\n            const edge2 = new Vector3().subVectors(v2, v0);\n            const normal = new Vector3().crossVectors(edge1, edge2).normalize();\n            const faceMid = new Vector3().addVectors(v0, v1).add(v2).divideScalar(3);\n            const viewDir = new Vector3().subVectors(cameraPos, faceMid);\n\n            // Plane constant d for the plane equation ax + by + cz + d = 0\n            // d = -(n . p)\n            const constant = -normal.dot(v0);\n\n            // Only include front-facing faces (back-facing can't occlude)\n            if (normal.dot(viewDir) <= 0) continue;\n\n            // Project to 2D\n            const p0 = v0.clone().project(camera);\n            const p1 = v1.clone().project(camera);\n            const p2 = v2.clone().project(camera);\n\n            // Convert to screen coordinates (with same scale as edges)\n            const a2d = new Vector2(p0.x * halfWidth * internalScale, -p0.y * halfHeight * internalScale);\n            const b2d = new Vector2(p1.x * halfWidth * internalScale, -p1.y * halfHeight * internalScale);\n            const c2d = new Vector2(p2.x * halfWidth * internalScale, -p2.y * halfHeight * internalScale);\n\n            // Compute depths using view-space Z-coordinate (not Euclidean distance)\n            // This correctly handles perspective distortion for barycentric interpolation\n            const viewMatrix = camera.matrixWorldInverse;\n            const depthA = -v0.clone().applyMatrix4(viewMatrix).z;\n            const depthB = -v1.clone().applyMatrix4(viewMatrix).z;\n            const depthC = -v2.clone().applyMatrix4(viewMatrix).z;\n\n            projectedFaces.push({\n                a2d, b2d, c2d,\n                depthA, depthB, depthC,\n                mesh, faceIdx: f,\n                normal,  // Store normal for post-split smooth filter\n                constant // Store plane constant for coplanar detection\n            });\n        }\n    }\n    console.timeEnd('buildProjectedFaces');\n    console.log(`Built ${projectedFaces.length} projected faces for occlusion`);\n\n    // Classify silhouette edges (edges that border the void) - BEFORE cleanup/optimization\n    console.time('classifySilhouettes');\n    classifySilhouettes(splitEdges, projectedFaces);\n    console.timeEnd('classifySilhouettes');\n\n    // Geometric straggler filter: remove edges lying between coplanar faces\n    console.time('filterSmoothSplitEdges');\n    const smoothFilteredEdges = filterSmoothSplitEdges(splitEdges, projectedFaces, smoothThreshold, distanceThreshold);\n    console.timeEnd('filterSmoothSplitEdges');\n\n    // Occlusion using pure math\n    let visibleEdges;\n    if (skipOcclusion) {\n        visibleEdges = smoothFilteredEdges;\n    } else {\n        console.time('testOcclusion (math)');\n        // Test ALL edges through occlusion (no special treatment for profiles)\n        visibleEdges = testOcclusionMath(smoothFilteredEdges, projectedFaces, camera);\n        console.timeEnd('testOcclusion (math)');\n    }\n    console.log(`Visible edges: ${visibleEdges.length}`);\n\n    console.time('optimize');\n    const optimizedEdges = optimizeEdges(visibleEdges);\n    console.timeEnd('optimize');\n\n    console.time('cleanup orphans');\n    const cleanedEdges = cleanupOrphanedEdges(optimizedEdges);\n    console.timeEnd('cleanup orphans');\n\n    // Remove completely isolated edges (orphaned at both ends)\n    const filteredEdges = removeIsolatedEdges(cleanedEdges);\n    console.log(`Final edges before optimization: ${filteredEdges.length}`);\n\n    // Run through Optimize.js\n    let optimizedFinal = filteredEdges;\n    if (filteredEdges.length > 0) {\n        let totalLen = 0;\n        for (const e of filteredEdges) {\n            const dx = e.b.x - e.a.x;\n            const dy = e.b.y - e.a.y;\n            totalLen += Math.sqrt(dx * dx + dy * dy);\n        }\n        const avgLen = totalLen / filteredEdges.length;\n        const smallDist = avgLen / 10;\n        console.log(`Optimization: avgLen=${avgLen.toFixed(2)}, trim limit=${smallDist.toFixed(2)}`);\n\n        console.time('Optimize.segments');\n        // @ts-ignore - _segments is private but we need the raw objects to preserve metadata\n        optimizedFinal = Optimize.segments(filteredEdges, false, true, smallDist, false, false, false)._segments;\n        console.timeEnd('Optimize.segments');\n        console.log(`After optimization: ${optimizedFinal.length} edges`);\n    }\n\n\n\n    // Scale edges back down to original coordinate space\n    for (const edge of optimizedFinal) {\n        edge.a.x /= internalScale;\n        edge.a.y /= internalScale;\n        edge.b.x /= internalScale;\n        edge.b.y /= internalScale;\n    }\n    const finalEdges = optimizedFinal;\n\n    return {\n        edges: finalEdges,\n        profiles: finalEdges.filter(e => e.isProfile),\n        allEdges: splitEdges, // For debug visualization\n        projectedFaces: projectedFaces  // For face visualization\n    };\n}\n\n/**\n * Classify edges as silhouettes if they border the void (one side has no mesh)\n * Uses 2D ray casting from edge midpoint perpendicular to the edge\n * @param {Edge2D[]} edges - Edges to classify\n * @param {ProjectedFace[]} projectedFaces - Projected triangles for hit testing\n */\nfunction classifySilhouettes(edges, projectedFaces) {\n    const RAY_LENGTH = 1000; // Long ray to ensure we hit any face on that side\n\n    for (const edge of edges) {\n        // Hatches are never silhouettes\n        if (edge.isHatch) {\n            edge.isSilhouette = false;\n            continue;\n        }\n\n        // Calculate midpoint\n        const midX = (edge.a.x + edge.b.x) / 2;\n        const midY = (edge.a.y + edge.b.y) / 2;\n\n        // Calculate edge direction and perpendicular\n        const dx = edge.b.x - edge.a.x;\n        const dy = edge.b.y - edge.a.y;\n        const len = Math.sqrt(dx * dx + dy * dy);\n\n        if (len < 0.001) {\n            edge.isSilhouette = false;\n            continue;\n        }\n\n        // Perpendicular direction (normalized)\n        const perpX = -dy / len;\n        const perpY = dx / len;\n\n        // Raycast on each side - check if ray intersects any face edge\n        const leftHit = rayHitsAnyFace(midX, midY, perpX, perpY, RAY_LENGTH, projectedFaces);\n        const rightHit = rayHitsAnyFace(midX, midY, -perpX, -perpY, RAY_LENGTH, projectedFaces);\n\n        // Silhouette if one side has no intersection\n        edge.isSilhouette = !leftHit || !rightHit;\n    }\n\n    const silCount = edges.filter(e => e.isSilhouette).length;\n    console.log(`Classified ${silCount} silhouette edges out of ${edges.length}`);\n}\n\n/**\n * Check if a 2D ray from origin in direction (dx, dy) intersects any projected triangle\n * @param {number} ox - Ray origin X\n * @param {number} oy - Ray origin Y\n * @param {number} dx - Ray direction X\n * @param {number} dy - Ray direction Y\n * @param {number} maxDist - Maximum ray distance\n * @param {ProjectedFace[]} faces - Array of projected faces\n * @returns {boolean}\n */\nfunction rayHitsAnyFace(ox, oy, dx, dy, maxDist, faces) {\n    for (const face of faces) {\n        if (rayIntersectsTriangle(ox, oy, dx, dy, maxDist, face.a2d, face.b2d, face.c2d)) {\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * Check if 2D ray intersects a triangle (any of its 3 edges)\n * @param {number} ox - Ray origin X\n * @param {number} oy - Ray origin Y\n * @param {number} rdx - Ray direction X\n * @param {number} rdy - Ray direction Y\n * @param {number} maxDist\n * @param {Vector2} a - Triangle vertex A\n * @param {Vector2} b - Triangle vertex B\n * @param {Vector2} c - Triangle vertex C\n * @returns {boolean}\n */\nfunction rayIntersectsTriangle(ox, oy, rdx, rdy, maxDist, a, b, c) {\n    if (raySegmentIntersect(ox, oy, rdx, rdy, maxDist, a.x, a.y, b.x, b.y)) return true;\n    if (raySegmentIntersect(ox, oy, rdx, rdy, maxDist, b.x, b.y, c.x, c.y)) return true;\n    if (raySegmentIntersect(ox, oy, rdx, rdy, maxDist, c.x, c.y, a.x, a.y)) return true;\n    return false;\n}\n\n/**\n * Check if 2D ray (origin ox,oy, direction rdx,rdy) intersects line segment (x1,y1)-(x2,y2)\n * @param {number} ox\n * @param {number} oy\n * @param {number} rdx\n * @param {number} rdy\n * @param {number} maxDist\n * @param {number} x1\n * @param {number} y1\n * @param {number} x2\n * @param {number} y2\n * @returns {boolean}\n */\nfunction raySegmentIntersect(ox, oy, rdx, rdy, maxDist, x1, y1, x2, y2) {\n    const sdx = x2 - x1;\n    const sdy = y2 - y1;\n\n    const denom = rdx * sdy - rdy * sdx;\n    if (Math.abs(denom) < 1e-10) return false; // Parallel\n\n    const t = ((x1 - ox) * sdy - (y1 - oy) * sdx) / denom;\n    const u = ((x1 - ox) * rdy - (y1 - oy) * rdx) / denom;\n\n    // t > 0.1 (past origin, small epsilon), t <= maxDist, u in [0,1] (on segment)\n    return t > 0.1 && t <= maxDist && u >= 0 && u <= 1;\n}\n\n/**\n * Check if a 2D point is inside any projected triangle\n * @param {number} px \n * @param {number} py \n * @param {ProjectedFace[]} faces \n * @returns {boolean}\n */\nfunction pointInAnyFace(px, py, faces) {\n    for (const face of faces) {\n        if (pointInTriangle(px, py, face.a2d, face.b2d, face.c2d)) {\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * Check if point (px, py) is inside triangle (a, b, c) using barycentric coordinates\n * @param {number} px \n * @param {number} py \n * @param {Vector2} a \n * @param {Vector2} b \n * @param {Vector2} c \n * @returns {boolean}\n */\nfunction pointInTriangle(px, py, a, b, c) {\n    const v0x = c.x - a.x;\n    const v0y = c.y - a.y;\n    const v1x = b.x - a.x;\n    const v1y = b.y - a.y;\n    const v2x = px - a.x;\n    const v2y = py - a.y;\n\n    const dot00 = v0x * v0x + v0y * v0y;\n    const dot01 = v0x * v1x + v0y * v1y;\n    const dot02 = v0x * v2x + v0y * v2y;\n    const dot11 = v1x * v1x + v1y * v1y;\n    const dot12 = v1x * v2x + v1y * v2y;\n\n    const invDenom = 1 / (dot00 * dot11 - dot01 * dot01);\n    const u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n    const v = (dot00 * dot12 - dot01 * dot02) * invDenom;\n\n    return (u >= 0) && (v >= 0) && (u + v <= 1);\n}\n","/**\n * PlotterRenderer - GPU-based SVG renderer for Three.js\n * Based on SVGRenderer by @mrdoob / http://mrdoob.com/\n */\n\nimport { Camera, Color, Object3D, Vector3 } from \"three\";\nimport { extractNormalRegions } from \"./gpu-silhouette.js\";\nimport { generatePerspectiveHatches, clipLineOutsidePolygon } from \"./perspective-hatch.js\";\nimport { computeHiddenLinesMultiple } from \"./hidden-line.js\";\n\nvar lop = (n) => {\n  return Math.round(n * 100) / 100;\n};\n\nvar SVGObject = function (node) {\n  Object3D.call(this);\n  this.node = node;\n};\n\nSVGObject.prototype = Object.create(Object3D.prototype);\nSVGObject.prototype.constructor = SVGObject;\n\nvar PlotterRenderer = function () {\n  var _this = this,\n    _svg = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\"),\n    _silhouettes = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\"),\n    _edges = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\"),\n    _shading = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\"),\n    _svgWidth,\n    _svgHeight,\n    _svgWidthHalf,\n    _svgHeightHalf,\n    _clearColor = new Color();\n\n  // Add proper SVG namespace attributes for macOS and native rendering\n  _svg.setAttribute(\"xmlns\", \"http://www.w3.org/2000/svg\");\n  _svg.setAttribute(\"xmlns:inkscape\", \"http://www.inkscape.org/namespaces/inkscape\");\n  _svg.setAttribute(\"xmlns:xlink\", \"http://www.w3.org/1999/xlink\");\n  _svg.setAttribute(\"version\", \"1.1\");\n\n  // Setup SVG layers (order determines z-index: later = on top)\n  _silhouettes.setAttribute(\"inkscape:label\", \"Silhouettes\");\n  _silhouettes.setAttribute(\"inkscape:groupmode\", \"layer\");\n  _silhouettes.id = \"silhouettes_layer\";\n  _svg.appendChild(_silhouettes);\n\n  _shading.setAttribute(\"inkscape:label\", \"Shading\");\n  _shading.setAttribute(\"inkscape:groupmode\", \"layer\");\n  _shading.id = \"shading_layer\";\n  _svg.appendChild(_shading);\n\n  _edges.setAttribute(\"inkscape:label\", \"Edges\");\n  _edges.setAttribute(\"inkscape:groupmode\", \"layer\");\n  _edges.id = \"edges_layer\";\n  _svg.appendChild(_edges);\n\n  this.domElement = _svg;\n\n  // Layer toggles\n  this.showSilhouettes = true;\n  this.showEdges = true;\n  this.showHatches = true;\n\n  // Silhouette options (GPU normal regions)\n  this.silhouetteOptions = {\n    normalBuckets: 12,\n    simplifyTolerance: 2.0,\n    minArea: 100\n  };\n\n  // Hatch options (perspective hatching)\n  this.hatchOptions = {\n    baseSpacing: 8,\n    minSpacing: 3,\n    maxSpacing: 40,\n    depthFactor: 0.5,\n    insetPixels: 3,\n    stroke: 'black',\n    strokeWidth: '1px',\n    axisSettings: {\n      x: { rotation: 0, spacing: 8 },\n      y: { rotation: 0, spacing: 8 },\n      z: { rotation: 0, spacing: 8 }\n    }\n  };\n\n  // Edge options (hidden line edges)\n  this.edgeOptions = {\n    stroke: 'white',\n    strokeWidth: '1px'\n  };\n\n  // Hidden-line options\n  this.hiddenLineOptions = {\n    smoothThreshold: 0.99\n  };\n\n  // WebGL renderer reference (needed for GPU operations)\n  this._glRenderer = null;\n\n  this.autoClear = true;\n\n  this.setClearColor = function (color) {\n    _clearColor.set(color);\n  };\n\n  this.setPixelRatio = function () { };\n\n  this.setSize = function (width, height) {\n    _svgWidth = width;\n    _svgHeight = height;\n    _svgWidthHalf = _svgWidth / 2;\n    _svgHeightHalf = _svgHeight / 2;\n\n    _svg.setAttribute(\"viewBox\", -_svgWidthHalf + \" \" + -_svgHeightHalf + \" \" + _svgWidth + \" \" + _svgHeight);\n    _svg.setAttribute(\"width\", _svgWidth);\n    _svg.setAttribute(\"height\", _svgHeight);\n  };\n\n  this.getSize = function () {\n    return {\n      width: _svgWidth,\n      height: _svgHeight,\n    };\n  };\n\n  this.setGLRenderer = function (glRenderer) {\n    _this._glRenderer = glRenderer;\n  };\n\n  function removeChildNodes() {\n    while (_silhouettes.childNodes.length > 0) {\n      _silhouettes.removeChild(_silhouettes.childNodes[0]);\n    }\n    while (_edges.childNodes.length > 0) {\n      _edges.removeChild(_edges.childNodes[0]);\n    }\n    while (_shading.childNodes.length > 0) {\n      _shading.removeChild(_shading.childNodes[0]);\n    }\n  }\n\n  this.clear = function () {\n    removeChildNodes();\n    _svg.style.backgroundColor = _clearColor.getStyle();\n  };\n\n  /**\n   * Render GPU-based layers (silhouettes and hatches)\n   * @param {Object} scene - Three.js scene\n   * @param {Object} camera - Three.js camera\n   */\n  this.renderGPULayers = function (scene, camera) {\n    if (!_this._glRenderer) {\n      console.warn(\"PlotterRenderer: WebGL renderer not set. Call setGLRenderer() first.\");\n      return;\n    }\n\n    const glRenderer = _this._glRenderer;\n\n    // GPU Silhouettes (region fills based on normal direction)\n    if (_this.showSilhouettes || _this.showHatches) {\n      const regions = extractNormalRegions(glRenderer, scene, camera, {\n        normalBuckets: _this.silhouetteOptions.normalBuckets,\n        simplifyTolerance: _this.silhouetteOptions.simplifyTolerance,\n        minArea: _this.silhouetteOptions.minArea,\n        insetPixels: _this.showHatches ? _this.hatchOptions.insetPixels : 0\n      });\n\n      // Draw silhouette fills\n      if (_this.showSilhouettes) {\n        regions.forEach(region => {\n          if (region.boundary.length < 3) return;\n\n          const path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n          let d = \"\";\n          region.boundary.forEach((pt, i) => {\n            const x = pt.x;\n            const y = -pt.y; // GPU regions use different Y convention\n            d += (i === 0 ? \"M\" : \"L\") + lop(x) + \",\" + lop(y);\n          });\n          d += \"Z\";\n\n          // Color based on normal direction\n          const n = region.normal;\n          const r = Math.floor((n.x * 0.5 + 0.5) * 255);\n          const g = Math.floor((n.y * 0.5 + 0.5) * 255);\n          const b = Math.floor((n.z * 0.5 + 0.5) * 255);\n\n          path.setAttribute(\"d\", d);\n          path.setAttribute(\"fill\", `rgba(${r},${g},${b},0.3)`);\n          path.setAttribute(\"stroke\", \"none\");\n          _silhouettes.appendChild(path);\n        });\n      }\n\n      // GPU Perspective Hatches (render before edges so edges appear on top)\n      if (_this.showHatches) {\n        // Sort by depth (front first) for occlusion\n        regions.sort((a, b) => a.depth - b.depth);\n        const allRegionBounds = regions.map(r => r.boundary);\n\n        regions.forEach((region, idx) => {\n          let hatches = generatePerspectiveHatches(region, camera, {\n            baseSpacing: _this.hatchOptions.baseSpacing,\n            minSpacing: _this.hatchOptions.minSpacing,\n            maxSpacing: _this.hatchOptions.maxSpacing,\n            depthFactor: _this.hatchOptions.depthFactor,\n            insetPixels: _this.hatchOptions.insetPixels,\n            screenWidth: _svgWidth,\n            screenHeight: _svgHeight,\n            axisSettings: _this.hatchOptions.axisSettings\n          });\n\n          // Clip against front regions\n          for (let frontIdx = 0; frontIdx < idx; frontIdx++) {\n            hatches = hatches.flatMap(hatch =>\n              clipLineOutsidePolygon(hatch, allRegionBounds[frontIdx])\n            );\n          }\n\n          // Draw hatches\n          hatches.forEach(hatch => {\n            const path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n            const d = `M${lop(hatch.start.x)},${lop(-hatch.start.y)}L${lop(hatch.end.x)},${lop(-hatch.end.y)}`;\n            path.setAttribute(\"d\", d);\n            path.setAttribute(\"fill\", \"none\");\n            path.setAttribute(\"stroke\", _this.hatchOptions.stroke);\n            path.setAttribute(\"stroke-width\", _this.hatchOptions.strokeWidth);\n            _shading.appendChild(path);\n          });\n        });\n      }\n\n      // Hidden Line Edges (render last so they appear on top)\n      if (_this.showEdges) {\n        // Collect all meshes from scene\n        const meshes = [];\n        scene.traverse((obj) => {\n          if (obj.isMesh && obj.geometry) {\n            meshes.push(obj);\n          }\n        });\n\n        if (meshes.length > 0) {\n          const result = computeHiddenLinesMultiple(meshes, camera, scene, {\n            smoothThreshold: _this.hiddenLineOptions.smoothThreshold,\n            width: _svgWidth,\n            height: _svgHeight\n          });\n          const edges = result.edges || [];\n\n          edges.forEach(edge => {\n            const line = document.createElementNS(\"http://www.w3.org/2000/svg\", \"line\");\n            line.setAttribute(\"x1\", lop(edge.a.x));\n            line.setAttribute(\"y1\", lop(edge.a.y));\n            line.setAttribute(\"x2\", lop(edge.b.x));\n            line.setAttribute(\"y2\", lop(edge.b.y));\n            line.setAttribute(\"stroke\", _this.edgeOptions.stroke);\n            line.setAttribute(\"stroke-width\", _this.edgeOptions.strokeWidth);\n            _edges.appendChild(line);\n          });\n        }\n      }\n    }\n  };\n\n  /**\n   * Legacy render method - renders wireframe preview during camera movement\n   * For final output, use clear() + renderGPULayers()\n   * @param {Object} scene - Three.js scene\n   * @param {Object} camera - Three.js camera\n   */\n  this.render = function (scene, camera) {\n    if (camera instanceof Camera === false) {\n      console.error(\"PlotterRenderer.render: camera is not an instance of Camera.\");\n      return;\n    }\n\n    // For now, render is a no-op. Use renderGPULayers() for output.\n    // This maintains API compatibility with Three.js SVGRenderer\n  };\n\n};\n\nexport { SVGObject, PlotterRenderer };\n"],"names":["extractNormalRegions","renderer","scene","camera","options","resolution","normalBuckets","minArea","simplifyTolerance","insetPixels","size","Vector2","width","height","insetAmount","normalPixels","renderNormals","depthPixels","renderDepth","regionMap","normalLookup","quantizeNormals","labels","regionCount","connectedComponents","erodeRegionMap","regions","regionId","boundary","traceBoundary","simplified","rdpSimplify","area","polygonArea","normal","findRegionNormal","depth","sampleRegionDepth","p","target","WebGLRenderTarget","NearestFilter","normalMaterial","MeshNormalMaterial","originalMaterials","hiddenObjects","obj","pixels","depthMaterial","MeshDepthMaterial","RGBADepthPacking","targetLabel","sum","count","y","x","idx","g","b","a","iterations","current","iter","next","i","left","right","up","down","buckets","nextId","normalToId","nx","ny","nz","tolerance","qr","qg","qb","key","Vector3","parent","nextLabel","find","union","px","py","region","neighbors","minLabel","n","labelRemap","finalLabel","root","startX","startY","outer","dx","dy","dir","maxIter","found","checkDir","sumX","sumY","cx","normalId","points","epsilon","maxDist","maxIdx","first","last","dist","perpendicularDistance","point","lineStart","lineEnd","lenSq","t","projX","projY","j","computeHatchDirection","screenWidth","screenHeight","halfW","halfH","worldUp","worldForward","faceAxis","origin","farPoint","originScreen","farScreen","screenOrigin","direction","vpProjected","vanishingPoint","generatePerspectiveHatches","baseSpacing","minSpacing","maxSpacing","depthFactor","axisSettings","ax","ay","az","axis","settings","rotationDeg","spacingOverride","finalDirection","rad","cos","sin","perpDir","spacing","minX","maxX","minY","maxY","pt","centerX","centerY","center","diag","hatches","vpDist","numLines","angleStep","centerAngle","angle","clipped","clipLineToPolygon","offset","lineCenter","line","polygon","intersections","p1","p2","intersection","lineIntersection","result","midX","midY","pointInPolygon","clipLineOutsidePolygon","startInside","endInside","lineIntersectionFull","filtered","midT","x1","y1","x2","y2","x3","y3","x4","y4","denom","u","inside","xi","yi","xj","yj","EPSILON","Point","BoundingBox","BoundingCircle","r","Segment","segA","segB","GeomUtil","seg","SegmentCollection","pts","rot","ptA","segs","ptB","local","bb","bc","Segments","segments","arr","sA","sB","d","aA","aB","deg","oldY","oldX","rA","rB","angle1","angle2","scale","numSegs","perc","deltaX","deltaY","targetPt","sourcePt","delta","numFit","remain","travel","bbs","ab","p3","fn","ignoreTouching","s1_x","s1_y","s2_x","s2_y","s","atX","atY","intPt","ca","boundingBox","polySegs","startPt","aTouching","bTouching","aWithin","bWithin","v1","v2","v3","d1","d2","d3","has_neg","has_pos","out","polySegsA","polySegsB","ptC","divide","spts","Analyzer","splitTeeIntersections","splitCrossIntersections","cxs","originalPts","token","allPts","crossPts","da","db","newSegs","k","ta","tb","res","nekot","str","byNumConnections","oppIdx","endTokens","ang","searchMultiplier","cenTokens","pointGroups","minDx","minDy","ptArray","hDx","hDy","rayPts","rayPt","nearPts","nPt","nPtA","tokenA","ok","nPtB","tokenB","npA","npB","polyPts","cen","cenToken","Optimize","segCols","noSplit","trimSmall","smallDist","optimizePathOrder","allsegs","sc","noSplitColinear","sb","sn","aa","ba","heading","same","isRev","extractEdges","mesh","cameraPosition","geometry","position","index","edgeMap","SNAP","getEdgeKey","va","vb","bx","by","bz","keyA","keyB","getVertex","getFaceNormal","v0","edge1","edge2","numFaces","i0","i1","i2","faceMid","viewDir","edges","existing","filterBackfacing","edge","edgeMidpoint","facing1","facing2","classifyEdges","smoothThreshold","profiles","smoothFiltered","projectEdges","halfWidth","halfHeight","projectPoint","p3d","projected","SpatialHash","cellSize","cy","cells","steps","_a","findIntersection","e1","e2","t1","t2","eps","splitAtIntersections","splits","pointOnEdgeInterior","potentialStragglers","_b","tAonJ","_c","tBonJ","_d","tAonI","_e","tBonI","_f","edgeSplits","isStraggler","prevPoint","prevPoint3d","split","point3d","testOcclusionFaceID","meshes","isProfile","e","visibleEdges","renderTarget","RGBAFormat","UnsignedByteType","faceIdMaterial","ShaderMaterial","DoubleSide","faceIdMeshes","globalFaceOffset","geom","newPositions","faceColors","f","globalFaceId","newGeom","BufferGeometry","BufferAttribute","faceIdMesh","Mesh","tempScene","Scene","faceIdData","sx","sy","sampledFaceId","parentMeshOffset","parentFaceId","parentFaceId2","m","pointInTriangle2D","c","sign","hasNeg","hasPos","edgeLiesAlongFaceEdge","edgeA","edgeB","faceEdgeA","faceEdgeB","projectAndCheck","findAdjacentFaces","projectedFaces","results","face","faceEdges","fe","barycentricDepth","depthA","depthB","depthC","dot00","dot01","dot02","dot11","dot12","v","filterSmoothSplitEdges","coplanarThreshold","distanceThreshold","filteredEdges","removedCount","adjacentFaces","shouldRemove","f1","f2","fn1","fn2","dot","similarity","distDiff","faces","af","allCoplanar","minSimilarity","sim","testOcclusionMath","cameraPos","viewMatrix","testOcclusionMathJS","debugHitCount","debugOccludedCount","mid2d","mid3d","edgeDepth","occluded","testOcclusion","raycaster","Raycaster","toMidpoint","expectedDist","relEps","intersects","hit","optimizeEdges","unique","hashPoint","hashEdge","h1","h2","cleanupOrphanedEdges","maxExtension","vertexKey","vertices","endpoint","orphans","vertex","orphanPoint","otherPoint","len","cross","extensionsCount","processed","orphan","bestMatch","bestIntersection","bestDist","candidate","ix","iy","intersectDist","crosses1","segmentCrossesEdges","crosses2","totalLength","avgEdgeLength","snapThreshold","finalVertices","finalOrphans","snapCount","snapped","nearestOrphan","nearestDist","remainingOrphans","removeIsolatedEdges","vertexConnections","connectionsA","connectionsB","removed","excludeEdge1","excludeEdge2","d1x","d1y","d2x","d2y","computeHiddenLines","gridSize","occlusionEpsilon","skipOcclusion","edges3d","frontEdges","allEdges","edges2d","hash","processedEdges","splitEdges","cellKey","cellEdges","profileEdges","otherEdges","visibleOtherEdges","optimizedEdges","finalEdges","computeHiddenLinesMultiple","internalScale","allEdges3d","visibleHatch","threshold","hatch2d","constant","p0","a2d","b2d","c2d","classifySilhouettes","smoothFilteredEdges","cleanedEdges","optimizedFinal","totalLen","avgLen","perpX","perpY","leftHit","rayHitsAnyFace","rightHit","silCount","ox","oy","rayIntersectsTriangle","rdx","rdy","raySegmentIntersect","sdx","sdy","lop","SVGObject","node","Object3D","PlotterRenderer","_this","_svg","_silhouettes","_edges","_shading","_svgWidth","_svgHeight","_svgWidthHalf","_svgHeightHalf","_clearColor","Color","color","glRenderer","removeChildNodes","path","allRegionBounds","frontIdx","hatch","Camera"],"mappings":"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"}