{"version":3,"file":"three-plotter-renderer.es.js","sources":["../src/gpu-silhouette.js","../src/perspective-hatch.js","../src/geom/geom.js","../src/analyzer.js","../src/optimize.js","../src/hidden-line.js","../src/plotter-renderer.js"],"sourcesContent":["/**\n * GPU Normal-Region Polygon Extraction\n * \n * Renders quantized normals to texture, uses connected component labeling\n * to find contiguous regions with same normal, then traces boundaries.\n * \n * This approach is:\n * - Fast (GPU parallel rendering)\n * - 3D-aware (normals from actual geometry)\n * - Produces clean polygons grouped by normal direction\n */\n\nimport {\n    WebGLRenderTarget,\n    MeshNormalMaterial,\n    MeshDepthMaterial,\n    ShaderMaterial,\n    RGBADepthPacking,\n    NearestFilter,\n    Vector2,\n    Vector3\n} from 'three';\n\n/**\n * @typedef {Object} NormalRegion\n * @property {Vector2[]} boundary - Closed boundary polygon points\n * @property {Vector3} normal - The normal direction for this region\n * @property {number} area - Region area in pixels\n * @property {number} regionId - Unique ID for this region\n */\n\n/**\n * Extract polygons grouped by normal direction\n * @param {WebGLRenderer} renderer\n * @param {Scene} scene\n * @param {Camera} camera\n * @param {Object} options\n * @returns {NormalRegion[]}\n */\nexport function extractNormalRegions(renderer, scene, camera, options = {}) {\n    const {\n        resolution = 2.0,        // Render at 2x for smooth boundaries\n        normalBuckets = 12,      // Quantize normals into N directions\n        minArea = 100,           // Minimum region area in pixels (at output scale)\n        simplifyTolerance = 2.0,\n        insetPixels = 0          // Inset boundaries by this many pixels (GPU erosion)\n    } = options;\n\n    const size = renderer.getSize(new Vector2());\n    const width = Math.floor(size.x * resolution);\n    const height = Math.floor(size.y * resolution);\n\n    // Scale inset by resolution\n    const insetAmount = Math.round(insetPixels * resolution);\n\n\n\n    // Step 1: Render normals and depth to textures\n    const normalPixels = renderNormals(renderer, scene, camera, width, height);\n    const depthPixels = renderDepth(renderer, scene, camera, width, height);\n\n    // Step 2: Quantize normals to region IDs\n    const { regionMap, normalLookup } = quantizeNormals(normalPixels, width, height, normalBuckets);\n\n    // Step 3: Connected component labeling on ORIGINAL (non-eroded) regions\n    // This gives us the true silhouette boundaries\n    const { labels, regionCount } = connectedComponents(regionMap, width, height);\n\n    // Step 3.5: Apply erosion for insetting (only affects hatch clipping, not boundaries)\n    let erodedRegionMap = regionMap;\n    if (insetAmount > 0) {\n        erodedRegionMap = erodeRegionMap(regionMap, width, height, insetAmount);\n    }\n\n    // Step 4: Trace boundaries for each region (using ORIGINAL labels, not eroded)\n    const regions = [];\n    for (let regionId = 1; regionId <= regionCount; regionId++) {\n        const boundary = traceBoundary(labels, width, height, regionId);\n        if (boundary.length < 3) continue;\n\n        // Simplify boundary\n        const simplified = rdpSimplify(boundary, simplifyTolerance);\n        const area = Math.abs(polygonArea(simplified));\n\n        if (area < minArea) continue;\n\n\n        // Find the normal for this region (sample from center)\n        const normal = findRegionNormal(labels, regionMap, normalLookup, width, height, regionId);\n\n        // Sample depth at region center\n        const depth = sampleRegionDepth(labels, depthPixels, width, height, regionId);\n\n        regions.push({\n            boundary: simplified.map(p => new Vector2(\n                (p.x / resolution) - size.x / 2,\n                (p.y / resolution) - size.y / 2  // Y already flipped during readback\n            )),\n            normal,\n            depth,  // 0-1 normalized depth\n            area: area / (resolution * resolution),\n            regionId\n        });\n    }\n\n\n    return regions;\n}\n\n/**\n * Render normals to pixel buffer\n */\nfunction renderNormals(renderer, scene, camera, width, height) {\n    const target = new WebGLRenderTarget(width, height, {\n        minFilter: NearestFilter,\n        magFilter: NearestFilter\n    });\n\n    // Use MeshNormalMaterial for normal extraction\n    // Note: This outputs VIEW SPACE normals, not world space\n    const normalMaterial = new MeshNormalMaterial({ flatShading: true });\n\n    const originalMaterials = new Map();\n    const hiddenObjects = [];\n\n    scene.traverse(obj => {\n        // Only render Mesh objects, hide helpers/lines\n        if (obj.isMesh) {\n            originalMaterials.set(obj, obj.material);\n            obj.material = normalMaterial;\n        } else if (obj.isLineSegments || obj.isLine || obj.isPoints) {\n            // Hide grid helpers, line helpers, etc.\n            if (obj.visible) {\n                hiddenObjects.push(obj);\n                obj.visible = false;\n            }\n        }\n    });\n\n    renderer.setRenderTarget(target);\n    renderer.render(scene, camera);\n\n    scene.traverse(obj => {\n        if (obj.isMesh && originalMaterials.has(obj)) {\n            obj.material = originalMaterials.get(obj);\n        }\n    });\n\n    // Restore hidden objects (grid helpers, lines, etc.)\n    for (const obj of hiddenObjects) {\n        obj.visible = true;\n    }\n\n    renderer.setRenderTarget(null);\n\n    const pixels = new Uint8Array(width * height * 4);\n    renderer.readRenderTargetPixels(target, 0, 0, width, height, pixels);\n\n    target.dispose();\n    normalMaterial.dispose();\n\n    return pixels;\n}\n\n/**\n * Render depth to pixel buffer\n */\nfunction renderDepth(renderer, scene, camera, width, height) {\n    const target = new WebGLRenderTarget(width, height, {\n        minFilter: NearestFilter,\n        magFilter: NearestFilter\n    });\n\n    const depthMaterial = new MeshDepthMaterial({ depthPacking: RGBADepthPacking });\n\n    const originalMaterials = new Map();\n    const hiddenObjects = [];\n\n    scene.traverse(obj => {\n        if (obj.isMesh) {\n            originalMaterials.set(obj, obj.material);\n            obj.material = depthMaterial;\n        } else if (obj.isLineSegments || obj.isLine || obj.isPoints) {\n            if (obj.visible) {\n                hiddenObjects.push(obj);\n                obj.visible = false;\n            }\n        }\n    });\n\n    renderer.setRenderTarget(target);\n    renderer.render(scene, camera);\n\n    scene.traverse(obj => {\n        if (obj.isMesh && originalMaterials.has(obj)) {\n            obj.material = originalMaterials.get(obj);\n        }\n    });\n\n    for (const obj of hiddenObjects) {\n        obj.visible = true;\n    }\n\n    renderer.setRenderTarget(null);\n\n    const pixels = new Uint8Array(width * height * 4);\n    renderer.readRenderTargetPixels(target, 0, 0, width, height, pixels);\n\n    target.dispose();\n    depthMaterial.dispose();\n\n    return pixels;\n}\n\n/**\n * Sample average depth for a region\n */\nfunction sampleRegionDepth(labels, depthPixels, width, height, targetLabel) {\n    let sum = 0, count = 0;\n\n    for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n            if (labels[y * width + x] === targetLabel) {\n                const idx = (y * width + x) * 4;\n                // Unpack RGBA depth\n                const r = depthPixels[idx] / 255;\n                const g = depthPixels[idx + 1] / 255;\n                const b = depthPixels[idx + 2] / 255;\n                const a = depthPixels[idx + 3] / 255;\n                const depth = r + g / 256 + b / 65536 + a / 16777216;\n                sum += depth;\n                count++;\n            }\n        }\n    }\n\n    return count > 0 ? sum / count : 0.5;\n}\n\n/**\n * Morphological erosion on region map\n * Only erodes pixels at the OUTER boundary (next to background 0)\n * Does NOT erode at boundaries between different regions (holes)\n */\nfunction erodeRegionMap(regionMap, width, height, iterations) {\n    let current = regionMap;\n\n    for (let iter = 0; iter < iterations; iter++) {\n        const next = new Uint16Array(current);  // Start with copy\n\n        for (let y = 1; y < height - 1; y++) {\n            for (let x = 1; x < width - 1; x++) {\n                const i = y * width + x;\n                const region = current[i];\n\n                if (region === 0) continue;\n\n                // Check 4-connected neighbors\n                // Only erode if ANY neighbor is background (0)\n                // Don't erode if neighbors are just different regions\n                const left = current[i - 1];\n                const right = current[i + 1];\n                const up = current[i - width];\n                const down = current[i + width];\n\n                if (left === 0 || right === 0 || up === 0 || down === 0) {\n                    next[i] = 0;  // Erode this pixel (it touches background)\n                }\n                // else: keep the pixel even if it touches other regions\n            }\n        }\n\n        current = next;\n    }\n\n    return current;\n}\n\n/**\n * Quantize normals into buckets and create region map\n * Returns regionMap (pixel -> regionId) and normalLookup (regionId -> Vector3)\n */\nfunction quantizeNormals(pixels, width, height, buckets) {\n    const regionMap = new Uint16Array(width * height);\n    const normalLookup = {}; // regionId -> Vector3 normal\n    let nextId = 1;\n    const normalToId = {}; // quantized normal string -> regionId\n\n    for (let i = 0; i < width * height; i++) {\n        const idx = i * 4;\n        const r = pixels[idx];\n        const g = pixels[idx + 1];\n        const b = pixels[idx + 2];\n\n        // Background check (black = no geometry)\n        if (r < 5 && g < 5 && b < 5) {\n            regionMap[i] = 0; // Background\n            continue;\n        }\n\n        // Decode normal from RGB (MeshNormalMaterial encodes: (n+1)/2 * 255)\n        const nx = (r / 255) * 2 - 1;\n        const ny = (g / 255) * 2 - 1;\n        const nz = (b / 255) * 2 - 1;\n\n        // Round RGB to nearest 4 for tolerance at grazing angles\n        // This groups very similar normals together to avoid sub-pixel noise\n        const tolerance = 4;\n        const qr = Math.round(r / tolerance) * tolerance;\n        const qg = Math.round(g / tolerance) * tolerance;\n        const qb = Math.round(b / tolerance) * tolerance;\n        const key = `${qr}|${qg}|${qb}`;\n\n        if (!normalToId[key]) {\n            normalToId[key] = nextId;\n            normalLookup[nextId] = new Vector3(nx, ny, nz).normalize();\n            nextId++;\n        }\n\n        regionMap[i] = normalToId[key];\n    }\n\n    return { regionMap, normalLookup };\n}\n\n/**\n * Connected component labeling using union-find\n */\nfunction connectedComponents(regionMap, width, height) {\n    const labels = new Uint32Array(width * height);\n    const parent = [];\n    let nextLabel = 1;\n\n    function find(x) {\n        if (parent[x] !== x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    function union(x, y) {\n        const px = find(x);\n        const py = find(y);\n        if (px !== py) {\n            parent[py] = px;\n        }\n    }\n\n    // First pass: assign labels\n    for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n            const i = y * width + x;\n            const region = regionMap[i];\n\n            if (region === 0) continue; // Background\n\n            const neighbors = [];\n\n            // Check left neighbor\n            if (x > 0 && regionMap[i - 1] === region && labels[i - 1] > 0) {\n                neighbors.push(labels[i - 1]);\n            }\n            // Check top neighbor\n            if (y > 0 && regionMap[i - width] === region && labels[i - width] > 0) {\n                neighbors.push(labels[i - width]);\n            }\n\n            if (neighbors.length === 0) {\n                // New label\n                labels[i] = nextLabel;\n                parent[nextLabel] = nextLabel;\n                nextLabel++;\n            } else {\n                // Use minimum neighbor label\n                const minLabel = Math.min(...neighbors);\n                labels[i] = minLabel;\n                // Union all neighbors\n                for (const n of neighbors) {\n                    union(minLabel, n);\n                }\n            }\n        }\n    }\n\n    // Second pass: flatten labels\n    const labelRemap = {};\n    let finalLabel = 0;\n\n    for (let i = 0; i < width * height; i++) {\n        if (labels[i] === 0) continue;\n        const root = find(labels[i]);\n        if (labelRemap[root] === undefined) {\n            finalLabel++;\n            labelRemap[root] = finalLabel;\n        }\n        labels[i] = labelRemap[root];\n    }\n\n    return { labels, regionCount: finalLabel };\n}\n\n/**\n * Trace boundary of a labeled region using Moore neighborhood\n */\nfunction traceBoundary(labels, width, height, targetLabel) {\n    const boundary = [];\n\n    // Find starting point (leftmost pixel on top row of region)\n    let startX = -1, startY = -1;\n    outer: for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n            if (labels[y * width + x] === targetLabel) {\n                // Check if it's on boundary (has non-region neighbor)\n                const hasEdge =\n                    x === 0 || labels[y * width + x - 1] !== targetLabel ||\n                    y === 0 || labels[(y - 1) * width + x] !== targetLabel;\n                if (hasEdge) {\n                    startX = x;\n                    startY = y;\n                    break outer;\n                }\n            }\n        }\n    }\n\n    if (startX === -1) return boundary;\n\n    // Moore neighborhood: 8 directions clockwise from right\n    const dx = [1, 1, 0, -1, -1, -1, 0, 1];\n    const dy = [0, 1, 1, 1, 0, -1, -1, -1];\n\n    let x = startX, y = startY;\n    let dir = 7; // Start looking up-right\n    const maxIter = width * height * 2;\n    let iter = 0;\n\n    do {\n        boundary.push({ x, y });\n\n        // Find next boundary pixel\n        let found = false;\n        for (let i = 0; i < 8; i++) {\n            const checkDir = (dir + 6 + i) % 8; // Start from dir-2 (backtrack)\n            const nx = x + dx[checkDir];\n            const ny = y + dy[checkDir];\n\n            if (nx >= 0 && nx < width && ny >= 0 && ny < height) {\n                if (labels[ny * width + nx] === targetLabel) {\n                    x = nx;\n                    y = ny;\n                    dir = checkDir;\n                    found = true;\n                    break;\n                }\n            }\n        }\n\n        if (!found) break;\n        iter++;\n    } while ((x !== startX || y !== startY) && iter < maxIter);\n\n    return boundary;\n}\n\n/**\n * Find representative normal for a region\n */\nfunction findRegionNormal(labels, regionMap, normalLookup, width, height, targetLabel) {\n    // Find center of region and sample normal\n    let sumX = 0, sumY = 0, count = 0;\n    for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n            if (labels[y * width + x] === targetLabel) {\n                sumX += x;\n                sumY += y;\n                count++;\n            }\n        }\n    }\n\n    if (count === 0) return new Vector3(0, 0, 1);\n\n    const cx = Math.round(sumX / count);\n    const cy = Math.round(sumY / count);\n    const i = cy * width + cx;\n    const normalId = regionMap[i];\n\n    return normalLookup[normalId] || new Vector3(0, 0, 1);\n}\n\n/**\n * Ramer-Douglas-Peucker simplification\n */\nfunction rdpSimplify(points, epsilon) {\n    if (points.length < 3) return points;\n\n    let maxDist = 0, maxIdx = 0;\n    const first = points[0];\n    const last = points[points.length - 1];\n\n    for (let i = 1; i < points.length - 1; i++) {\n        const dist = perpendicularDistance(points[i], first, last);\n        if (dist > maxDist) {\n            maxDist = dist;\n            maxIdx = i;\n        }\n    }\n\n    if (maxDist > epsilon) {\n        const left = rdpSimplify(points.slice(0, maxIdx + 1), epsilon);\n        const right = rdpSimplify(points.slice(maxIdx), epsilon);\n        return left.slice(0, -1).concat(right);\n    } else {\n        return [first, last];\n    }\n}\n\nfunction perpendicularDistance(point, lineStart, lineEnd) {\n    const dx = lineEnd.x - lineStart.x;\n    const dy = lineEnd.y - lineStart.y;\n    const lenSq = dx * dx + dy * dy;\n    if (lenSq < 1e-10) {\n        return Math.sqrt((point.x - lineStart.x) ** 2 + (point.y - lineStart.y) ** 2);\n    }\n    // Clamp t to [0,1] to get distance to segment, not infinite line\n    let t = ((point.x - lineStart.x) * dx + (point.y - lineStart.y) * dy) / lenSq;\n    t = Math.max(0, Math.min(1, t));\n    const projX = lineStart.x + t * dx;\n    const projY = lineStart.y + t * dy;\n    return Math.sqrt((point.x - projX) ** 2 + (point.y - projY) ** 2);\n}\n\nfunction polygonArea(points) {\n    let area = 0;\n    for (let i = 0; i < points.length; i++) {\n        const j = (i + 1) % points.length;\n        area += points[i].x * points[j].y;\n        area -= points[j].x * points[i].y;\n    }\n    return area / 2;\n}\n\n/**\n * Debug visualization: show normal regions colored by their normal direction\n */\nexport function debugNormalRegions(renderer, scene, camera) {\n    const size = renderer.getSize(new Vector2());\n    const width = Math.floor(size.x);\n    const height = Math.floor(size.y);\n\n    const normalPixels = renderNormals(renderer, scene, camera, width, height);\n    const { regionMap, normalLookup } = quantizeNormals(normalPixels, width, height, 12);\n    const { labels, regionCount } = connectedComponents(regionMap, width, height);\n\n\n\n    // Create visualization\n    const canvas = document.createElement('canvas');\n    canvas.width = width;\n    canvas.height = height;\n    const ctx = canvas.getContext('2d');\n    const imageData = ctx.createImageData(width, height);\n\n    // Generate colors for each region\n    const regionColors = {};\n    for (let i = 1; i <= regionCount; i++) {\n        const hue = (i * 137.508) % 360; // Golden angle for good distribution\n        regionColors[i] = hslToRgb(hue / 360, 0.7, 0.5);\n    }\n\n    for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n            const srcIdx = (height - 1 - y) * width + x;\n            const dstIdx = (y * width + x) * 4;\n            const label = labels[srcIdx];\n\n            if (label === 0) {\n                imageData.data[dstIdx] = 30;\n                imageData.data[dstIdx + 1] = 30;\n                imageData.data[dstIdx + 2] = 30;\n            } else {\n                const [r, g, b] = regionColors[label] || [128, 128, 128];\n                imageData.data[dstIdx] = r;\n                imageData.data[dstIdx + 1] = g;\n                imageData.data[dstIdx + 2] = b;\n            }\n            imageData.data[dstIdx + 3] = 255;\n        }\n    }\n    ctx.putImageData(imageData, 0, 0);\n\n    // Show modal\n    const modal = document.createElement('div');\n    modal.style.cssText = 'position:fixed;top:0;left:0;width:100vw;height:100vh;background:rgba(0,0,0,0.8);display:flex;align-items:center;justify-content:center;z-index:10000;cursor:pointer;';\n    modal.onclick = () => modal.remove();\n    canvas.style.cssText = 'max-width:90vw;max-height:90vh;border:2px solid lime;';\n    const info = document.createElement('div');\n    info.style.cssText = 'position:absolute;top:20px;left:20px;color:lime;font-family:monospace;';\n    info.textContent = `${regionCount} regions, ${Object.keys(normalLookup).length} normal buckets (click to close)`;\n    modal.appendChild(canvas);\n    modal.appendChild(info);\n    document.body.appendChild(modal);\n}\n\nfunction hslToRgb(h, s, l) {\n    let r, g, b;\n    if (s === 0) {\n        r = g = b = l;\n    } else {\n        const hue2rgb = (p, q, t) => {\n            if (t < 0) t += 1;\n            if (t > 1) t -= 1;\n            if (t < 1 / 6) return p + (q - p) * 6 * t;\n            if (t < 1 / 2) return q;\n            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n            return p;\n        };\n        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n        const p = 2 * l - q;\n        r = hue2rgb(p, q, h + 1 / 3);\n        g = hue2rgb(p, q, h);\n        b = hue2rgb(p, q, h - 1 / 3);\n    }\n    return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];\n}\n","/**\n * Perspective Hatching\n * \n * Generates architect-style perspective hatches that converge toward\n * vanishing points based on face orientation.\n */\n\nimport { Vector2, Vector3 } from 'three';\n\n/**\n * @typedef {Object} HatchLine\n * @property {Vector2} start\n * @property {Vector2} end\n */\n\n/**\n * Compute the 2D hatch direction for a face based on its normal\n * Projects the face's primary axis to screen space\n * @param {Vector3} normal - Face normal in world space\n * @param {Camera} camera - Three.js camera\n * @param {number} screenWidth\n * @param {number} screenHeight\n * @returns {{direction: Vector2, vanishingPoint: Vector2|null}}\n */\nexport function computeHatchDirection(normal, camera, screenWidth, screenHeight) {\n    const halfW = screenWidth / 2;\n    const halfH = screenHeight / 2;\n\n    // Find a primary axis direction in the face plane\n    // For most faces, use the horizontal (XZ) direction projected onto the face\n    const worldUp = new Vector3(0, 1, 0);\n    const worldForward = new Vector3(0, 0, 1);\n\n    // Get a vector in the face plane\n    let faceAxis;\n\n    // For horizontal faces (floor/ceiling), use world Z direction\n    if (Math.abs(normal.y) > 0.9) {\n        faceAxis = worldForward.clone();\n    } else {\n        // For vertical/angled faces, use horizontal direction in face plane\n        // This is the cross product of normal with world up, gives horizontal direction in face\n        faceAxis = new Vector3().crossVectors(worldUp, normal).normalize();\n\n        // If face is vertical and facing up/down, cross product might be zero\n        if (faceAxis.lengthSq() < 0.01) {\n            faceAxis = worldForward.clone();\n        }\n    }\n\n    // Project two points along this axis to screen to get 2D direction\n    const origin = new Vector3(0, 0, 0);\n    const farPoint = faceAxis.clone().multiplyScalar(100);\n\n    const originScreen = origin.clone().project(camera);\n    const farScreen = farPoint.clone().project(camera);\n\n    // Convert to screen pixels\n    const screenOrigin = new Vector2(\n        originScreen.x * halfW,\n        -originScreen.y * halfH\n    );\n    const screenFar = new Vector2(\n        farScreen.x * halfW,\n        -farScreen.y * halfH\n    );\n\n    // 2D direction on screen\n    const direction = screenFar.clone().sub(screenOrigin).normalize();\n\n    // Compute vanishing point by projecting point at infinity along this direction\n    // VP is where parallel 3D lines converge in 2D\n    const veryFarPoint = faceAxis.clone().multiplyScalar(100000);\n    const vpProjected = veryFarPoint.clone().project(camera);\n\n    // Check if VP is visible/finite\n    let vanishingPoint = null;\n    if (Math.abs(vpProjected.x) < 100 && Math.abs(vpProjected.y) < 100 && vpProjected.z < 1) {\n        vanishingPoint = new Vector2(\n            vpProjected.x * halfW,\n            -vpProjected.y * halfH\n        );\n    }\n\n    return { direction, vanishingPoint };\n}\n\n/**\n * Generate perspective hatch lines for a region\n * @param {Object} region - Region from extractNormalRegions\n * @param {Camera} camera\n * @param {Object} options\n * @returns {HatchLine[]}\n */\nexport function generatePerspectiveHatches(region, camera, options = {}) {\n    const {\n        baseSpacing = 8,      // Base spacing in screen pixels\n        minSpacing = 3,       // Minimum spacing\n        maxSpacing = 20,      // Maximum spacing\n        depthFactor = 0.5,    // How much depth affects density\n        screenWidth = 1200,\n        screenHeight = 800,\n        axisSettings = {},    // { x: { rotation: 0, spacing: 10 }, y: ... }\n        brightness = null,    // 0-1 lighting brightness (null = disabled)\n        invertBrightness = false  // True for white-on-black (bright = dense)\n    } = options;\n\n    const { boundary, normal, depth = 0.5 } = region;\n    if (boundary.length < 3) return [];\n\n    // Determine dominant axis\n    const ax = Math.abs(normal.x);\n    const ay = Math.abs(normal.y);\n    const az = Math.abs(normal.z);\n\n    let axis = 'y'; // default up\n    if (ax >= ay && ax >= az) axis = 'x';\n    else if (az >= ay && az >= ax) axis = 'z';\n\n    // Get settings for this axis\n    const settings = axisSettings[axis] || {};\n    const rotationDeg = settings.rotation || 0;\n    const spacingOverride = settings.spacing;\n\n    console.log(`[Hatch] normal=(${normal.x.toFixed(2)}, ${normal.y.toFixed(2)}, ${normal.z.toFixed(2)}) => axis=${axis}, rotation=${rotationDeg}, spacing=${spacingOverride}`);\n\n    // Get hatch direction from normal\n    const { direction, vanishingPoint } = computeHatchDirection(\n        normal, camera, screenWidth, screenHeight\n    );\n\n    // Apply rotation if needed\n    let finalDirection = direction;\n    if (rotationDeg !== 0) {\n        const rad = rotationDeg * (Math.PI / 180);\n        const cos = Math.cos(rad);\n        const sin = Math.sin(rad);\n        finalDirection = new Vector2(\n            direction.x * cos - direction.y * sin,\n            direction.x * sin + direction.y * cos\n        );\n    }\n\n    // Perpendicular direction for spacing\n    const perpDir = new Vector2(-finalDirection.y, finalDirection.x);\n\n    // Calculate spacing based on depth (closer = denser)\n    // Use override if available, otherwise baseSpacing\n    const effectiveBase = spacingOverride !== undefined ? spacingOverride : baseSpacing;\n    let spacing = Math.max(minSpacing, Math.min(maxSpacing,\n        effectiveBase + (depth * depthFactor * (maxSpacing - minSpacing))\n    ));\n\n    // Apply brightness-based density adjustment if enabled\n    if (brightness !== null && brightness !== undefined) {\n        // brightness: 0 = dark (should be dense), 1 = bright (should be sparse)\n        // For black-on-white: bright areas = more spacing (less ink)\n        // For white-on-black (inverted): bright areas = less spacing (more ink)\n        let effectiveBrightness = invertBrightness ? brightness : (1 - brightness);\n\n        // Map brightness to spacing multiplier (0.5x to 2x)\n        const brightnessMultiplier = 0.5 + effectiveBrightness * 1.5;\n        spacing = Math.max(minSpacing, Math.min(maxSpacing, spacing * brightnessMultiplier));\n    }\n\n    // Get bounding box of region\n    let minX = Infinity, maxX = -Infinity;\n    let minY = Infinity, maxY = -Infinity;\n    for (const pt of boundary) {\n        minX = Math.min(minX, pt.x);\n        maxX = Math.max(maxX, pt.x);\n        minY = Math.min(minY, pt.y);\n        maxY = Math.max(maxY, pt.y);\n    }\n\n    const centerX = (minX + maxX) / 2;\n    const centerY = (minY + maxY) / 2;\n    const center = new Vector2(centerX, centerY);\n\n    // Size of region along perpendicular direction\n    const diag = Math.sqrt((maxX - minX) ** 2 + (maxY - minY) ** 2);\n\n    const hatches = [];\n\n    // If rotated, we can't easily use the VP logic unless we rotate the VP too, \n    // but typically architectural hatching with rotation implies a pattern override, \n    // so we'll often fall back to parallel for rotated patterns unless it's 0/90.\n    // For now, if rotation is significant, force parallel to avoid weird VP artifacts.\n    // OR: Rotate the vector from VP to center? \n    // Let's stick to parallel for significantly rotated hatches to keep it clean for now,\n    // as \"perspective rotated hatching\" is geometrically ambiguous.\n    const usePerspective = vanishingPoint && Math.abs(rotationDeg) < 5 && vanishingPoint.distanceTo(center) < diag * 5;\n\n    if (usePerspective) {\n        // Perspective lines converging to visible VP\n        const vpDist = vanishingPoint.distanceTo(center);\n\n        // Generate lines radiating from VP\n        const numLines = Math.ceil(diag / spacing) * 2;\n        const angularSpan = Math.atan2(diag, vpDist);\n        const angleStep = angularSpan * 2 / numLines;\n\n        // Angle from VP to center\n        const centerAngle = Math.atan2(\n            centerY - vanishingPoint.y,\n            centerX - vanishingPoint.x\n        );\n\n        for (let i = -numLines; i <= numLines; i++) {\n            const angle = centerAngle + i * angleStep;\n            const dir = new Vector2(Math.cos(angle), Math.sin(angle));\n\n            // Line from VP extending far past region\n            const lineStart = vanishingPoint.clone();\n            const lineEnd = vanishingPoint.clone().add(dir.clone().multiplyScalar(vpDist * 10));\n\n            const clipped = clipLineToPolygon({ start: lineStart, end: lineEnd }, boundary);\n            hatches.push(...clipped);\n        }\n    } else {\n        // Parallel lines (VP at infinity or very far)\n        const numLines = Math.ceil(diag / spacing) + 2;\n\n        for (let i = -numLines; i <= numLines; i++) {\n            // Offset along perpendicular direction\n            const offset = perpDir.clone().multiplyScalar(i * spacing);\n            const lineCenter = center.clone().add(offset);\n\n            // Line extending in hatch direction\n            const lineStart = lineCenter.clone().add(finalDirection.clone().multiplyScalar(-diag));\n            const lineEnd = lineCenter.clone().add(finalDirection.clone().multiplyScalar(diag));\n\n            const clipped = clipLineToPolygon({ start: lineStart, end: lineEnd }, boundary);\n            hatches.push(...clipped);\n        }\n    }\n\n    return hatches;\n}\n\n/**\n * Clip a line to a polygon\n */\nexport function clipLineToPolygon(line, polygon) {\n    const intersections = [];\n    const n = polygon.length;\n\n    for (let i = 0; i < n; i++) {\n        const p1 = polygon[i];\n        const p2 = polygon[(i + 1) % n];\n\n        const intersection = lineIntersection(\n            line.start.x, line.start.y, line.end.x, line.end.y,\n            p1.x, p1.y, p2.x, p2.y\n        );\n\n        if (intersection) {\n            intersections.push({\n                point: new Vector2(intersection.x, intersection.y),\n                t: intersection.t\n            });\n        }\n    }\n\n    if (intersections.length < 2) return [];\n\n    // Sort by parameter along line\n    intersections.sort((a, b) => a.t - b.t);\n\n    // Create segments between consecutive pairs, checking midpoint is inside\n    const result = [];\n    for (let i = 0; i < intersections.length - 1; i++) {\n        const midX = (intersections[i].point.x + intersections[i + 1].point.x) / 2;\n        const midY = (intersections[i].point.y + intersections[i + 1].point.y) / 2;\n\n        if (pointInPolygon(midX, midY, polygon)) {\n            result.push({\n                start: intersections[i].point,\n                end: intersections[i + 1].point\n            });\n        }\n    }\n\n    return result;\n}\n\n/**\n * Clip a line to OUTSIDE a polygon (inverse of clipLineToPolygon)\n * Returns segments that are OUTSIDE the polygon\n */\nexport function clipLineOutsidePolygon(line, polygon) {\n    const intersections = [];\n    const n = polygon.length;\n\n    // Add start and end points\n    const startInside = pointInPolygon(line.start.x, line.start.y, polygon);\n    const endInside = pointInPolygon(line.end.x, line.end.y, polygon);\n\n    intersections.push({ point: line.start.clone(), t: 0, inside: startInside });\n\n    // Find all intersections with polygon edges\n    for (let i = 0; i < n; i++) {\n        const p1 = polygon[i];\n        const p2 = polygon[(i + 1) % n];\n\n        const intersection = lineIntersectionFull(\n            line.start.x, line.start.y, line.end.x, line.end.y,\n            p1.x, p1.y, p2.x, p2.y\n        );\n\n        if (intersection && intersection.t > 0 && intersection.t < 1) {\n            intersections.push({\n                point: new Vector2(intersection.x, intersection.y),\n                t: intersection.t,\n                inside: null // will be determined by neighbors\n            });\n        }\n    }\n\n    intersections.push({ point: line.end.clone(), t: 1, inside: endInside });\n\n    // Sort by parameter\n    intersections.sort((a, b) => a.t - b.t);\n\n    // Remove duplicates (points too close together)\n    const filtered = [intersections[0]];\n    for (let i = 1; i < intersections.length; i++) {\n        if (intersections[i].t - filtered[filtered.length - 1].t > 0.0001) {\n            filtered.push(intersections[i]);\n        }\n    }\n\n    if (filtered.length < 2) return [line]; // No intersections, check if line is outside\n\n    // Build segments that are OUTSIDE\n    const result = [];\n    for (let i = 0; i < filtered.length - 1; i++) {\n        const midT = (filtered[i].t + filtered[i + 1].t) / 2;\n        const midX = line.start.x + midT * (line.end.x - line.start.x);\n        const midY = line.start.y + midT * (line.end.y - line.start.y);\n\n        // If midpoint is OUTSIDE polygon, include this segment\n        if (!pointInPolygon(midX, midY, polygon)) {\n            result.push({\n                start: filtered[i].point.clone(),\n                end: filtered[i + 1].point.clone()\n            });\n        }\n    }\n\n    return result;\n}\n\n// Full line intersection (both segments)\nfunction lineIntersectionFull(x1, y1, x2, y2, x3, y3, x4, y4) {\n    const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n    if (Math.abs(denom) < 1e-10) return null;\n\n    const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;\n    const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;\n\n    if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {\n        return {\n            x: x1 + t * (x2 - x1),\n            y: y1 + t * (y2 - y1),\n            t\n        };\n    }\n    return null;\n}\n\nfunction lineIntersection(x1, y1, x2, y2, x3, y3, x4, y4) {\n    const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n    if (Math.abs(denom) < 1e-10) return null;\n\n    const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;\n    const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;\n\n    if (u >= 0 && u <= 1) {\n        return {\n            x: x1 + t * (x2 - x1),\n            y: y1 + t * (y2 - y1),\n            t\n        };\n    }\n    return null;\n}\n\nfunction pointInPolygon(x, y, polygon) {\n    let inside = false;\n    const n = polygon.length;\n\n    for (let i = 0, j = n - 1; i < n; j = i++) {\n        const xi = polygon[i].x, yi = polygon[i].y;\n        const xj = polygon[j].x, yj = polygon[j].y;\n\n        if (((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) {\n            inside = !inside;\n        }\n    }\n\n    return inside;\n}\n","const EPSILON = 0.001;\n\nexport class Point {\n  /**\n   * @param {number} x\n   * @param {number} y\n   */\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n  /**\n   * @param {Point} pt\n   */\n  static clone(pt) {\n    return new Point(pt.x, pt.y);\n  }\n}\n\nexport class BoundingBox {\n  /**\n   * @param {number} minX\n   * @param {number} minY\n   * @param {number} maxX\n   * @param {number} maxY\n   */\n  constructor(minX, minY, maxX, maxY) {\n    this.minX = minX;\n    this.minY = minY;\n    this.maxX = maxX;\n    this.maxY = maxY;\n  }\n  width() {\n    return Math.abs(this.maxX - this.minX);\n  }\n  height() {\n    return Math.abs(this.maxY - this.minY);\n  }\n}\n\nexport class BoundingCircle {\n  /**\n   *\n   * @param {number} r radius\n   */\n  constructor(r = 0) {\n    this.r = r;\n  }\n}\n\nexport class Segment {\n  /**\n   *\n   * @param {Point} a start point\n   * @param {Point} b end point\n   */\n  constructor(a, b) {\n    this.a = a;\n    this.b = b;\n    this.tags = {};\n  }\n\n  /**\n   *\n   * @param {Segment} segA\n   * @param {Segment} segB\n   */\n  static isEqual(segA, segB) {\n    return (\n      (GeomUtil.pointsEqual(segA.a, segB.a) && GeomUtil.pointsEqual(segA.b, segB.b)) ||\n      (GeomUtil.pointsEqual(segA.b, segB.a) && GeomUtil.pointsEqual(segA.a, segB.b))\n    );\n  }\n\n  /**\n   * @param {Segment} seg\n   */\n  static clone(seg) {\n    return new Segment(new Point(seg.a.x, seg.a.y), new Point(seg.b.x, seg.b.y));\n  }\n}\n\nexport class SegmentCollection {\n  constructor() {\n    this.pivot = { x: 0, y: 0 };\n    this.rotation = 0;\n    this.isOpen = true;\n    this.isGroup = false;\n    this.isStrong = false;\n    /**\n     *\n     * @param {Point[]} pts\n     */\n    this._makeAbsolute = (pts) => {\n      let rot = (this.rotation * Math.PI) / 180;\n      pts.forEach((pt, idx) => {\n        const ptA = { x: pt.x, y: pt.y };\n        GeomUtil.rotatePoint(ptA, rot);\n        ptA.x += this.pivot.x;\n        ptA.y += this.pivot.y;\n        pts[idx] = ptA;\n      });\n    };\n    /**\n     *\n     * @param {Segment[]} segs\n     */\n    this._makeSegsAbsolute = (segs) => {\n      let rot = (this.rotation * Math.PI) / 180;\n      segs.forEach((seg) => {\n        const ptA = { x: seg.a.x, y: seg.a.y };\n        const ptB = { x: seg.b.x, y: seg.b.y };\n        GeomUtil.rotatePoint(ptA, rot);\n        GeomUtil.rotatePoint(ptB, rot);\n        GeomUtil.addToPoint(ptA, this.pivot);\n        GeomUtil.addToPoint(ptB, this.pivot);\n        seg.a = ptA;\n        seg.b = ptB;\n      });\n    };\n  }\n\n  /**\n   * @param {boolean} local\n   * @returns {Point[]}\n   */\n  toPoints(local = false) {\n    throw \"not implemented\";\n  }\n\n  /**\n   *\n   * @param {boolean} local\n   * @returns {Segment[]};\n   */\n  toSegments(local = false) {\n    throw \"not implemented\";\n  }\n\n  /**\n   *\n   * @param {boolean} local\n   * @returns {BoundingBox}\n   */\n  getBoundingBox(local = false) {\n    const bb = new BoundingBox(1000000, 1000000, -1000000, -1000000);\n    const pts = this.toPoints(local);\n    pts.forEach((pt) => {\n      bb.minX = Math.min(bb.minX, pt.x);\n      bb.minY = Math.min(bb.minY, pt.y);\n      bb.maxX = Math.max(bb.maxX, pt.x);\n      bb.maxY = Math.max(bb.maxY, pt.y);\n    });\n\n    return bb;\n  }\n\n  /**\n   * @returns {BoundingCircle}\n   */\n  getBoundingCircle() {\n    const bc = new BoundingCircle();\n    const pts = this.toPoints(true);\n    pts.forEach((pt) => {\n      bc.r = Math.max(bc.r, Math.sqrt(pt.x * pt.x + pt.y * pt.y));\n    });\n    return bc;\n  }\n}\n\nexport class Segments extends SegmentCollection {\n  /**\n   *\n   * @param {Segment[]} segments\n   */\n  constructor(segments) {\n    super();\n    /** @type {Segment[]} */\n    this._segments = segments;\n  }\n\n  /**\n   * @param {Segment[]} segs\n   */\n  add(...segs) {\n    this._segments = this._segments.concat(segs);\n  }\n\n  /**\n   * @param {boolean} local\n   * @returns {Point[]}\n   */\n  toPoints(local = false) {\n    return this.toSegments(local).reduce((arr, seg) => (seg ? arr.concat([seg.a, seg.b]) : arr), []);\n  }\n  /**\n   *\n   * @param {boolean} local\n   * @returns {Segment[]};\n   */\n  toSegments(local = false) {\n    let segs = this._segments.reduce((arr, seg) => (seg ? arr.concat(Segment.clone(seg)) : arr), []);\n    if (!local) {\n      this._makeSegsAbsolute(segs);\n    }\n    return segs;\n  }\n\n  bake() {\n    // noOp\n  }\n\n  result() {\n    return Segments.clone(this);\n  }\n\n  /**\n   *\n   * @param {Segments} segs\n   */\n  static clone(segs) {\n    let sA = segs._segments;\n    let sB = [];\n    let i = sA.length;\n    while (i--) {\n      sB.unshift(Segment.clone(sA[i]));\n    }\n    let s = new Segments(sB);\n    s.pivot.x = segs.pivot.x;\n    s.pivot.y = segs.pivot.y;\n    s.rotation = segs.rotation;\n    return s;\n  }\n}\n\nexport class GeomUtil {\n  /**\n   *\n   * @param {number} a\n   * @param {number} b\n   * @param {number} d\n   * @returns {number}\n   */\n  static lerp(a, b, d) {\n    return (1 - d) * a + d * b;\n  }\n\n  /**\n   *\n   * @param {Point} ptA\n   * @param {Point} ptB\n   */\n  static angleBetween(ptA, ptB) {\n    return Math.atan2(ptB.y - ptA.y, ptB.x - ptA.x);\n  }\n\n  /**\n   *\n   * @param {Segment} segA\n   * @param {Segment} segB\n   */\n  static sameAngle(segA, segB) {\n    let aA = GeomUtil.angleBetween(segA.a, segA.b);\n    let aB = GeomUtil.angleBetween(segB.a, segB.b);\n\n    return Math.abs(aA - aB) < EPSILON;\n  }\n\n  /**\n   *\n   * @param {Segment} segA\n   * @param {Segment} segB\n   */\n  static sameAngleRev(segA, segB) {\n    let aA = GeomUtil.angleBetween(segA.a, segA.b);\n    let aB = GeomUtil.angleBetween(segB.b, segB.a);\n\n    return Math.abs(aA - aB) < EPSILON;\n  }\n\n  /**\n   *\n   * @param {Point} ptA\n   * @param {Point} ptB\n   * @param {number} d\n   * @returns {Point}\n   */\n  static lerpPoints(ptA, ptB, d) {\n    return {\n      x: GeomUtil.lerp(ptA.x, ptB.x, d),\n      y: GeomUtil.lerp(ptA.y, ptB.y, d),\n    };\n  }\n\n  /**\n   *\n   * @param {Point} pt the point to rotate in place\n   * @param {number} deg angle in degrees\n   */\n  static rotatePointDeg(pt, deg) {\n    GeomUtil.rotatePoint(pt, (deg * Math.PI) / 180);\n  }\n\n  /**\n   *\n   * @param {Point} pt\n   * @param {*} rad\n   */\n  static rotatePoint(pt, rad) {\n    const cos = Math.cos(rad);\n    const sin = Math.sin(rad);\n\n    const oldY = pt.y;\n    const oldX = pt.x;\n\n    pt.y = cos * oldY - sin * oldX;\n    pt.x = sin * oldY + cos * oldX;\n  }\n\n  /**\n   *\n   * @param {number} rad\n   * @param  {...Point} points\n   */\n  static rotatePoints(rad, ...points) {\n    points.forEach((pt) => {\n      GeomUtil.rotatePoint(pt, rad);\n    });\n  }\n\n  /**\n   *\n   * @param {number} deg\n   * @param  {...Point} points\n   */\n  static rotatePointsDeg(deg, ...points) {\n    let rad = (deg * Math.PI) / 180;\n    points.forEach((pt) => {\n      GeomUtil.rotatePoint(pt, rad);\n    });\n  }\n\n  // Based on http://stackoverflow.com/a/12037737\n\n  static outerTangents(ptA, rA, ptB, rB) {\n    var dx = ptB.x - ptA.x;\n    var dy = ptB.y - ptA.y;\n    var dist = Math.sqrt(dx * dx + dy * dy);\n\n    if (dist <= Math.abs(rB - rA)) return []; // no valid tangents\n\n    // Rotation from x-axis\n    var angle1 = Math.atan2(dy, dx);\n    var angle2 = Math.acos((rA - rB) / dist);\n\n    return [\n      new Segment(\n        {\n          x: ptA.x + rA * Math.cos(angle1 + angle2),\n          y: ptA.y + rA * Math.sin(angle1 + angle2),\n        },\n        {\n          x: ptB.x + rB * Math.cos(angle1 + angle2),\n          y: ptB.y + rB * Math.sin(angle1 + angle2),\n        }\n      ),\n      new Segment(\n        {\n          x: ptA.x + rA * Math.cos(angle1 - angle2),\n          y: ptA.y + rA * Math.sin(angle1 - angle2),\n        },\n        {\n          x: ptB.x + rB * Math.cos(angle1 - angle2),\n          y: ptB.y + rB * Math.sin(angle1 - angle2),\n        }\n      ),\n    ];\n  }\n\n  /**\n   *\n   * @param {Point} pt\n   */\n  static cartesian2Polar(pt) {\n    const d = Math.sqrt(pt.x * pt.x + pt.y * pt.y);\n    const r = Math.atan2(pt.y, pt.x);\n    pt.x = d;\n    pt.y = r;\n  }\n\n  /**\n   *\n   * @param {Point} ptA\n   * @param {Point} ptB\n   * @param {number} [scale]\n   */\n  static pointsEqual(ptA, ptB, scale = 1) {\n    return (\n      Math.round(ptA.x * 10000 / scale) == Math.round(ptB.x * 10000 / scale) && Math.round(ptA.y * 10000 / scale) == Math.round(ptB.y * 10000 / scale)\n    );\n  }\n\n  /**\n   *\n   * @param {Point} ptA\n   * @param {Point} ptB\n   * @returns {number}\n   */\n  static distanceBetween(ptA, ptB) {\n    const dx = ptB.x - ptA.x;\n    const dy = ptB.y - ptA.y;\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n  /**\n   *\n   * @param {Point} ptA\n   * @param {Point} ptB\n   * @returns {number}\n   */\n  static distanceBetweenSquared(ptA, ptB) {\n    const dx = ptB.x - ptA.x;\n    const dy = ptB.y - ptA.y;\n    return dx * dx + dy * dy;\n  }\n\n  /**\n   *\n   * @param {Point} ptA\n   * @param {Point} ptB\n   * @param {number} numSegs\n   * @returns {Point[]}\n   */\n  static interpolatePoints(ptA, ptB, numSegs) {\n    let pts = [{ x: ptA.x, y: ptA.y }];\n    let perc = 1 / numSegs;\n    let deltaX = (ptB.x - ptA.x) * perc;\n    let deltaY = (ptB.y - ptA.y) * perc;\n    for (var i = 1; i < numSegs; i++) {\n      pts.push(new Point(ptA.x + deltaX * i, ptA.y + deltaY * i));\n    }\n    pts.push({ x: ptB.x, y: ptB.y });\n    return pts;\n  }\n\n  /**\n   *\n   * @param  {...Point} pts\n   */\n  static averagePoints(...pts) {\n    let a = new Point(0, 0);\n    pts.forEach((pt) => {\n      a.x += pt.x;\n      a.y += pt.y;\n    });\n    a.x /= pts.length;\n    a.y /= pts.length;\n    return a;\n  }\n\n  /**\n   *\n   * @param {Point} targetPt the point that will be added to\n   * @param {Point} sourcePt the point to add to the target\n   */\n  static addToPoint(targetPt, sourcePt) {\n    targetPt.x += sourcePt.x;\n    targetPt.y += sourcePt.y;\n  }\n\n  /**\n   *\n   * @param {Point} targetPt the point that will be subtracted from\n   * @param {Point} sourcePt the point tosubtract from the target\n   */\n  static subFromPoint(targetPt, sourcePt) {\n    targetPt.x -= sourcePt.x;\n    targetPt.y -= sourcePt.y;\n  }\n\n  /**\n   *\n   * @param {Point} ptA\n   * @param {Point} ptB\n   * @param {number} delta\n   * @returns {Point[]}\n   */\n  static subdivideByDistance(ptA, ptB, delta) {\n    if (delta === 0) {\n      return [ptA, ptB];\n    }\n    let pts = [{ x: ptA.x, y: ptA.y }];\n    let dist = GeomUtil.distanceBetween(ptA, ptB);\n    let perc = delta / dist;\n    let numFit = Math.floor(1 / perc);\n    let remain = dist % delta;\n    delta += remain / numFit;\n    perc = delta / dist;\n    let travel = perc;\n    let i = 1;\n    let deltaX = (ptB.x - ptA.x) * perc;\n    let deltaY = (ptB.y - ptA.y) * perc;\n    while (travel < 1) {\n      pts.push(new Point(ptA.x + deltaX * i, ptA.y + deltaY * i));\n      travel += perc;\n      i++;\n    }\n    pts.push({ x: ptB.x, y: ptB.y });\n    return pts;\n  }\n\n  /**\n   *\n   * @param {Segment} segA\n   * @param {Segment} segB\n   * @param {number} [scale]\n   */\n  static segmentsConnected(segA, segB, scale = 1) {\n    return GeomUtil.pointsEqual(segA.b, segB.a, scale) || GeomUtil.pointsEqual(segA.a, segB.b, scale);\n  }\n\n  /**\n   *\n   * @param {Segment[]} segs\n   * @returns {Point[]}\n   */\n  static segmentsToPoints(segs) {\n    let pts = segs.reduce((arr, seg) => {\n      return arr.concat(seg.a, seg.b);\n    }, []);\n    let i = pts.length;\n    while (i--) {\n      let pt = pts[i];\n      if (i > 0 && GeomUtil.pointsEqual(pt, pts[i - 1])) {\n        pts.splice(i, 1);\n      }\n    }\n    return pts;\n  }\n\n  /**\n   *\n   * @param {Point[]} pts\n   * @returns {number}\n   */\n  static polygonArea(pts) {\n    let area = 0;\n    let j = pts.length - 1;\n    for (var i = 0; i < pts.length; i++) {\n      area += pts[i].x * pts[j].y;\n      area -= pts[j].x * pts[i].y;\n      j = i;\n    }\n    return area / 2;\n  }\n\n  /**\n   *\n   * @param {Point[]} pts\n   * @returns {BoundingBox}\n   */\n  static pointsBoundingBox(pts) {\n    const b = new BoundingBox(1000000, 1000000, -1000000, -1000000);\n\n    pts.forEach((pt) => {\n      b.minX = Math.min(b.minX, pt.x);\n      b.minY = Math.min(b.minY, pt.y);\n      b.maxX = Math.max(b.maxX, pt.x);\n      b.maxY = Math.max(b.maxY, pt.y);\n    });\n\n    return b;\n  }\n\n  /**\n   *\n   * @param {BoundingBox[]} bbs\n   * @returns {BoundingBox}\n   */\n  static boundingBoxesBoundingBox(bbs) {\n    const b = new BoundingBox(1000000, 1000000, -1000000, -1000000);\n\n    bbs.forEach((bb) => {\n      b.minX = Math.min(b.minX, bb.minX);\n      b.minY = Math.min(b.minY, bb.minY);\n      b.maxX = Math.max(b.maxX, bb.maxX);\n      b.maxY = Math.max(b.maxY, bb.maxY);\n    });\n\n    return b;\n  }\n\n  /**\n   *\n   * @param {Segment[]} segs\n   * @returns {BoundingBox}\n   */\n  static segmentsBoundingBox(segs) {\n    const pts = [];\n    segs.forEach((seg) => {\n      pts.push(seg.a);\n      pts.push(seg.b);\n    });\n    return GeomUtil.pointsBoundingBox(pts);\n  }\n\n  /**\n   *\n   * @param {BoundingBox} ab\n   * @param {BoundingBox} bb\n   */\n  static boundingBoxesIntersect(ab, bb) {\n    return ab.maxX >= bb.minX && ab.maxY >= bb.minY && ab.minX <= bb.maxX && ab.minY <= bb.maxY;\n  }\n\n  /**\n   *\n   * @param {Point[]} pts\n   * @returns {boolean}\n   */\n  static polygonIsClockwise(pts) {\n    return GeomUtil.polygonArea(pts) > 0;\n  }\n\n  /**\n   *\n   * @param {Point} p1\n   * @param {Point} p2\n   * @param {Point} p3\n   */\n  static ccw(p1, p2, p3) {\n    return (p3.y - p1.y) * (p2.x - p1.x) > (p2.y - p1.y) * (p3.x - p1.x);\n  }\n\n  /**\n   *\n   * @param {Segment} segA\n   * @param {Segment} segB\n   * @returns {boolean}\n   */\n  static segmentsIntersect(segA, segB) {\n    const fn = GeomUtil.ccw;\n    return (\n      fn(segA.a, segB.a, segB.b) != fn(segA.b, segB.a, segB.b) &&\n      fn(segA.a, segA.b, segB.a) != fn(segA.a, segA.b, segB.b)\n    );\n  }\n\n  /**\n   *\n   * @param {Segment} segA\n   * @param {Segment} segB\n   * @returns {Point}\n   */\n  static segmentSegmentIntersect(segA, segB, ignoreTouching = false) {\n    const x1 = segA.a.x;\n    const y1 = segA.a.y;\n    const x2 = segA.b.x;\n    const y2 = segA.b.y;\n    const x3 = segB.a.x;\n    const y3 = segB.a.y;\n    const x4 = segB.b.x;\n    const y4 = segB.b.y;\n\n    const s1_x = x2 - x1;\n    const s1_y = y2 - y1;\n    const s2_x = x4 - x3;\n    const s2_y = y4 - y3;\n\n    const s = (-s1_y * (x1 - x3) + s1_x * (y1 - y3)) / (-s2_x * s1_y + s1_x * s2_y);\n    const t = (s2_x * (y1 - y3) - s2_y * (x1 - x3)) / (-s2_x * s1_y + s1_x * s2_y);\n\n    if (s >= 0 && s <= 1 && t >= 0 && t <= 1) {\n      const atX = x1 + t * s1_x;\n      const atY = y1 + t * s1_y;\n      let intPt = { x: atX, y: atY };\n      if (ignoreTouching) {\n        if (GeomUtil.pointsEqual(intPt, segB.a) || GeomUtil.pointsEqual(intPt, segB.b)) {\n          return;\n        }\n        if (GeomUtil.pointsEqual(intPt, segA.a) || GeomUtil.pointsEqual(intPt, segA.b)) {\n          return;\n        }\n      }\n      return intPt;\n    }\n\n    return null;\n  }\n\n  /**\n   *\n   * @param {Segment} segA\n   * @param {Segment[]} segs\n   * @returns {Point[]}\n   */\n  static segmentSegmentsIntersections(segA, segs, ignoreTouching = false) {\n    let pts = [];\n    segs.forEach((seg) => {\n      if (seg == segA) {\n        return;\n      }\n      let intPt = GeomUtil.segmentSegmentIntersect(segA, seg, ignoreTouching);\n      if (intPt) {\n        pts.push(intPt);\n      }\n    });\n    return pts;\n  }\n\n  /**\n   *\n   * @param {Point} ptA\n   * @param {Point} ptB\n   */\n  static dot(ptA, ptB) {\n    return ptA.x * ptB.x + ptA.y * ptB.y;\n  }\n\n  /**\n   *\n   * @param {Point} ptA\n   * @param {Point} ptB\n   */\n  static cross(ptA, ptB) {\n    return ptA.x * ptB.y - ptA.y * ptB.x;\n  }\n\n  /**\n   * \n   * @param {Point} pt \n   * @param {Point} ptA \n   * @param {Point} ptB \n   */\n  static lineSide (pt, ptA, ptB) {\n    return Math.round(((ptB.x - ptA.x) * (pt.y - ptA.y) - (ptB.y - ptA.y) * (pt.x - ptA.x)) * 100) / 100;\n  }\n\n  /**\n   *\n   * @param {Point} ptA\n   * @param {Point} ptB\n   */\n  static sub(ptA, ptB) {\n    return new Point(ptA.x - ptB.x, ptA.y - ptB.y);\n  }\n\n  /**\n   *\n   * @param {Point} ptA\n   * @param {Point} ptB\n   */\n  static add(ptA, ptB) {\n    return new Point(ptA.x + ptB.x, ptA.y + ptB.y);\n  }\n\n  /**\n   *\n   * @param {Point} pt\n   * @param {Segment} seg\n   * @returns {Point}\n   */\n  static closestPtPointSegment(pt, seg) {\n    var ab = GeomUtil.sub(seg.b, seg.a);\n    var ca = GeomUtil.sub(pt, seg.a);\n    var t = GeomUtil.dot(ca, ab);\n\n    if (t < 0) {\n      pt = seg.a;\n    } else {\n      var denom = GeomUtil.dot(ab, ab);\n      if (t >= denom) {\n        pt = seg.b;\n      } else {\n        t /= denom;\n        // reuse ca\n        ca.x = seg.a.x + t * ab.x;\n        ca.y = seg.a.y + t * ab.y;\n        pt = ca;\n      }\n    }\n\n    return Point.clone(pt);\n  }\n\n  /**\n   *\n   * @param {Point} pt\n   * @param {Segment} seg\n   */\n  static distancePointSegment(pt, seg) {\n    return GeomUtil.distanceBetween(pt, GeomUtil.closestPtPointSegment(pt, seg));\n  }\n\n  /**\n   *\n   * @param {*} pt\n   * @param {*} boundingBox\n   * @returns {boolean}\n   */\n  static pointWithinBoundingBox(pt, boundingBox) {\n    return pt.x >= boundingBox.minX && pt.y >= boundingBox.minY && pt.x <= boundingBox.maxX && pt.y <= boundingBox.maxY;\n  }\n\n  /**\n   *\n   * @param {Point} pt\n   * @param {Segment[]} polySegs\n   * @returns {boolean}\n   */\n  static pointWithinPolygon(pt, polySegs, ignoreTouching) {\n    const b = GeomUtil.segmentsBoundingBox(polySegs);\n    // early out\n    if (!this.pointWithinBoundingBox(pt, b)) {\n      return false;\n    }\n\n    let startPt = new Point(100000, 100000);\n    let seg = new Segment(startPt, pt);\n\n    let pts = GeomUtil.segmentSegmentsIntersections(seg, polySegs);\n\n    if (!(pts.length % 2 == 0)) {\n      if (ignoreTouching && GeomUtil.pointsEqual(pt, pts[0])) {\n        return false;\n      }\n    }\n    return !(pts.length % 2 == 0);\n  }\n\n  /**\n   *\n   * @param {Segment} seg\n   * @param {Segment[]} polySegs\n   * @returns {boolean}\n   */\n  static segmentWithinPolygon(seg, polySegs) {\n    let aTouching = this.pointWithinPolygon(seg.a, polySegs, false);\n    let bTouching = this.pointWithinPolygon(seg.b, polySegs, false);\n    let aWithin = this.pointWithinPolygon(seg.a, polySegs, true);\n    let bWithin = this.pointWithinPolygon(seg.b, polySegs, true);\n    return (aWithin && bWithin) || (aWithin && bTouching) || (bWithin && aTouching);\n  }\n\n  static sign(p1, p2, p3) {\n    return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);\n  }\n\n  /**\n   *\n   * @param {Point} pt\n   * @param {Point} v1\n   * @param {Point} v2\n   * @param {Point} v3\n   * @returns {boolean}\n   */\n  static pointWithinTriangle(pt, v1, v2, v3, ignoreTouching) {\n    const d1 = GeomUtil.sign(pt, v1, v2);\n    const d2 = GeomUtil.sign(pt, v2, v3);\n    const d3 = GeomUtil.sign(pt, v3, v1);\n\n    const has_neg = d1 < 0 || d2 < 0 || d3 < 0;\n    const has_pos = d1 > 0 || d2 > 0 || d3 > 0;\n\n    if (!(has_neg && has_pos) && ignoreTouching) {\n      let seg = { a: v1, b: v2, tags: null };\n      if (GeomUtil.distancePointSegment(pt, seg) < 1) return false;\n      seg.a = v2;\n      seg.b = v3;\n      if (GeomUtil.distancePointSegment(pt, seg) < 1) return false;\n      seg.a = v3;\n      seg.b = v1;\n      if (GeomUtil.distancePointSegment(pt, seg) < 1) return false;\n    }\n\n    return !(has_neg && has_pos);\n  }\n\n  /**\n   *\n   * @param {Segment} seg\n   * @param {Point} v1\n   * @param {Point} v2\n   * @param {Point} v3\n   * @returns {boolean}\n   */\n  static segmentWithinTriangle(seg, v1, v2, v3) {\n    let aTouching = this.pointWithinTriangle(seg.a, v1, v2, v3, false);\n    let bTouching = this.pointWithinTriangle(seg.b, v1, v2, v3, false);\n    let aWithin = this.pointWithinTriangle(seg.a, v1, v2, v3, true);\n    let bWithin = this.pointWithinTriangle(seg.b, v1, v2, v3, true);\n    let pt = GeomUtil.averagePoints(seg.a, seg.b);\n    return (aWithin && bWithin) || (aWithin && bTouching) || (bWithin && aTouching) || (aTouching && bTouching);\n  }\n\n  /**\n   *\n   * @param {Point[]} pts\n   * @returns {Segment[]}\n   */\n  static pointsToClosedPolySegments(...pts) {\n    let out = [];\n    for (let i = 0; i < pts.length; i++) {\n      out.push(new Segment(pts[i], i < pts.length - 1 ? pts[i + 1] : pts[0]));\n    }\n    return out;\n  }\n\n  /**\n   *\n   * @param {Segment[]} polySegsA\n   * @param {Segment[]} polySegsB\n   * @returns {boolean}\n   */\n  static polygonWithinPolygon(polySegsA, polySegsB) {\n    const ab = GeomUtil.segmentsBoundingBox(polySegsA);\n    const bb = GeomUtil.segmentsBoundingBox(polySegsB);\n\n    // early out\n    if (!GeomUtil.boundingBoxesIntersect(ab, bb)) {\n      return false;\n    }\n\n    const startPt = new Point(bb.minX - 100, bb.minY - 100);\n\n    for (let i = 0; i < polySegsA.length; i++) {\n      let seg = polySegsA[i];\n      let pts = GeomUtil.segmentSegmentsIntersections(seg, polySegsB);\n\n      if (pts.length % 2 == 0) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   *\n   * @param {Point} ptA\n   * @param {Point} ptB\n   * @param {Point} ptC\n   * @param {number} iterations\n   */\n  static splinePoints(ptA, ptB, ptC, iterations = 0) {\n    let divide = (pts) => {\n      let out = [pts[0]];\n      for (let i = 0; i < pts.length - 1; i++) {\n        let pt = new Point(0, 0);\n        if (i + 1 < pts.length * 0.4) {\n          pt.x = (pts[i].x * 40 + pts[i + 1].x * 60) * 0.01;\n          pt.y = (pts[i].y * 40 + pts[i + 1].y * 60) * 0.01;\n        } else if (i + 1 > pts.length * 0.6) {\n          pt.x = (pts[i].x * 60 + pts[i + 1].x * 40) * 0.01;\n          pt.y = (pts[i].y * 60 + pts[i + 1].y * 40) * 0.01;\n        } else {\n          pt.x = (pts[i].x + pts[i + 1].x) * 0.5;\n          pt.y = (pts[i].y + pts[i + 1].y) * 0.5;\n        }\n        out.push(pt);\n      }\n      out.push(pts[pts.length - 1]);\n      return out;\n    };\n\n    let spts = [ptA, ptB, ptC];\n\n    for (let i = 0; i < iterations; i++) {\n      spts = divide(spts);\n    }\n\n    return spts;\n  }\n}","import { Segment, Point, GeomUtil } from \"./geom/geom.js\";\nimport { PolygonShape } from \"./geom/shapes.js\";\n\nexport class Analyzer {\n\n  /**\n   * @property {Segment[]} segs\n   * @property {boolean} splitTeeIntersections\n   * @returns {{ originalPts: Object.<string, Point>, pts: string[], cxs: Object.<string,string[]> }}\n   */\n  static getSegsAndConnections(segs, splitTeeIntersections = false, splitCrossIntersections = false) {\n\n    /** @type {Object.<string,string[]>} */\n    let cxs = {};\n    /** @type {string[]} */\n    let pts = [];\n    /** @type {Object.<string, Point>} */\n    let originalPts = {};\n\n    let token = pt => {\n      let t = `${Math.round(pt.x * 1)}|${Math.round(pt.y * 1)}`;\n      originalPts[t] = pt;\n      return t;\n    }\n\n    if (splitTeeIntersections) {\n\n      // step 0, split segments that cross a point (T intersections);\n\n      let allPts = segs.reduce((arr, seg) => arr.concat(seg.a, seg.b), []);\n      let j = allPts.length;\n\n      while (j--) {\n        let ptA = allPts[j];\n        let i = j;\n        while (i--) {\n          let ptB = allPts[i];\n          if (GeomUtil.pointsEqual(ptA, ptB)) {\n            allPts.splice(j, 1);\n            break;\n          }\n        }\n      }\n\n      let i = segs.length;\n\n      while (i--) {\n\n        let seg = segs[i];\n\n        let crossPts = [];\n\n        allPts.forEach(pt => {\n          if (GeomUtil.distancePointSegment(pt, seg) < 0.1) {\n            if (!GeomUtil.pointsEqual(pt, seg.a) && !GeomUtil.pointsEqual(pt, seg.b)) {\n              crossPts.push(pt);\n            }\n          }\n        });\n\n        if (crossPts.length) {\n\n          crossPts.sort((ptA, ptB) => {\n            const da = GeomUtil.distanceBetweenSquared(ptA, seg.a);\n            const db = GeomUtil.distanceBetweenSquared(ptB, seg.a);\n            if (da < db) {\n              return -1;\n            } else if (da > db) {\n              return 1;\n            }\n            return 0;\n          });\n\n          const newSegs = [];\n\n          let ptA = seg.a;\n          for (let k = 0; k < crossPts.length; k++) {\n            let ptB = crossPts[k];\n            newSegs.push(new Segment(ptA, ptB));\n            ptA = ptB;\n          }\n          newSegs.push(new Segment(ptA, seg.b));\n\n          segs.splice(i, 1, ...newSegs);\n\n        }\n\n      }\n\n    }\n\n    if (splitCrossIntersections) {\n\n      let j = segs.length;\n      while (j--) {\n        let i = j;\n        let found = false\n        while (i--) {\n          let segA = segs[j];\n          let segB = segs[i];\n          let intPt = GeomUtil.segmentSegmentIntersect(segA, segB, true);\n          if (intPt) {\n            found = true;\n            segs.splice(j, 1, new Segment(Point.clone(segA.a), Point.clone(intPt)), new Segment(Point.clone(intPt), Point.clone(segA.b)));\n            segs.splice(i, 1, new Segment(Point.clone(segB.a), Point.clone(intPt)), new Segment(Point.clone(intPt), Point.clone(segB.b)));\n          }\n        }\n        if (found) {\n          j = segs.length;\n        }\n      }\n\n    }\n\n    // step 1, collect endpoints\n    // step 2, filter out dupes\n    // step 3, collect connected endpoints for each endpoint\n\n    segs.forEach(seg => {\n      let ta = token(seg.a);\n      let tb = token(seg.b);\n      if (!cxs[ta]) cxs[ta] = [];\n      if (!cxs[tb]) cxs[tb] = [];\n      if (cxs[ta].indexOf(tb) === -1) {\n        cxs[ta].push(tb);\n      }\n      if (cxs[tb].indexOf(ta) === -1) {\n        cxs[tb].push(ta);\n      }\n      if (pts.indexOf(ta) === -1) {\n        pts.push(ta);\n      }\n      if (pts.indexOf(tb) === -1) {\n        pts.push(tb);\n      }\n    });\n\n    return {\n      originalPts,\n      pts,\n      cxs\n    };\n\n  }\n\n  /**\n   * @property {Segment[]} segs\n   * @property {boolean} splitTeeIntersections\n   * @returns {Segment[]}\n   */\n  static pathOrder(segs, splitTeeIntersections = false, splitCrossIntersections = false) {\n\n    let res = [];\n    let { originalPts, pts, cxs } = Analyzer.getSegsAndConnections(segs, splitTeeIntersections, splitCrossIntersections);\n\n    let nekot = str => {\n      return originalPts[str];\n    };\n\n    let byNumConnections = (ta, tb) => {\n      if (cxs[ta].length > cxs[tb].length) {\n        return 1;\n      } else if (cxs[ta].length < cxs[tb].length) {\n        return -1;\n      }\n      return 0;\n    }\n\n    // step 1, sort by number of connections, desc\n    // step 2, choose first endpoint\n    // step 3, pick the connected one with the lowest index that isn't in the stack, remove from connections list, push onto stack\n    // step 4, resort by number of connections, desc\n    // step 5, repeat step 6 until no more connections\n\n    pts.sort(byNumConnections);\n\n    while (pts.length) {\n\n      pts.sort(byNumConnections);\n      let ptA = pts.shift();\n\n      while (ptA) {\n\n        if (cxs[ptA].length) {\n\n          cxs[ptA].sort(byNumConnections);\n          let ptB = cxs[ptA].shift();\n\n          let oppIdx = cxs[ptB].indexOf(ptA);\n          if (oppIdx !== -1) cxs[ptB].splice(oppIdx, 1);\n\n          res.push(new Segment(nekot(ptA), nekot(ptB)));\n\n          if (cxs[ptA].length) {\n            pts.unshift(ptA);\n          }\n\n          ptA = ptB;\n\n        } else {\n\n          ptA = null;\n\n        }\n\n      }\n\n    }\n\n    return res;\n\n  }\n\n  /**\n   * @property {Segment[]} segs\n   * @property {number} offset\n   * @returns {Point[]}\n   */\n  static getEndingSegmentPoints(segs, offset = 0) {\n\n    segs = segs.concat();\n    segs = Analyzer.pathOrder(segs, true, true);\n\n    let { originalPts, pts, cxs } = Analyzer.getSegsAndConnections(segs, true);\n\n    let nekot = str => {\n      return originalPts[str];\n    };\n\n    // return all points with one connection\n\n    const endTokens = pts.filter(ta => cxs[ta].length === 1);\n\n    const out = [];\n    endTokens.forEach(tb => {\n      const ptB = Point.clone(nekot(tb));\n      if (offset === 0) {\n        out.push(ptB);\n        return;\n      }\n      const ptA = nekot(cxs[tb]);\n      const ang = GeomUtil.angleBetween(ptA, ptB);\n      const pt = new Point(0, offset);\n      GeomUtil.rotatePoint(pt, Math.PI * 0.5 - ang);\n      GeomUtil.addToPoint(ptB, pt);\n      out.push(ptB);\n    });\n\n    return out;\n\n  }\n\n  /**\n   * @property {Segment[]} segs\n   * @property {number} searchMultiplier multiple of typical segmentation distance to search for flood-fill points\n   * @returns {Point[][]}\n   */\n  static getFills(segs, searchMultiplier = 5) {\n\n    segs = segs.concat();\n\n    let { originalPts, pts, cxs } = Analyzer.getSegsAndConnections(segs, true, true);\n\n    let token = pt => {\n      let t = `${Math.round(pt.x * 1)}|${Math.round(pt.y * 1)}`;\n      originalPts[t] = pt;\n      return t;\n    }\n\n    let cenTokens = [];\n    let pointGroups = [];\n\n    // 1. iterate through all points\n    // 2. for each point pick a each connection\n    // 3. for each pair, proceed to find a winding polygon\n\n    let minX = 100000;\n    let minY = 100000;\n    let maxX = -100000;\n    let maxY = -100000;\n    let minDx = 100000;\n    let minDy = 100000;\n\n    let ptArray = [];\n\n    // get extents\n\n    for (let token in originalPts) {\n      let pt = originalPts[token];\n      ptArray.push(pt);\n      minX = Math.min(minX, pt.x);\n      minY = Math.min(minY, pt.y);\n      maxX = Math.max(maxX, pt.x);\n      maxY = Math.max(maxY, pt.y);\n    }\n\n    // get minimum spacing\n\n    ptArray.sort((a, b) => {\n      if (a.x < b.x) {\n        return -1;\n      } else if (a.x > b.x) {\n        return 1;\n      }\n      return 0;\n    });\n\n    ptArray.forEach((ptA, idx) => {\n      if (idx > 0) {\n        let ptB = ptArray[idx - 1];\n        let dx = Math.round(Math.abs(ptA.x - ptB.x));\n        if (dx > 1) {\n          minDx = Math.min(minDx, dx);\n        }\n      }\n    });\n\n    ptArray.sort((a, b) => {\n      if (a.y < b.y) {\n        return -1;\n      } else if (a.y > b.y) {\n        return 1;\n      }\n      return 0;\n    });\n\n    ptArray.forEach((ptA, idx) => {\n      if (idx > 0) {\n        let ptB = ptArray[idx - 1];\n        let dy = Math.round(Math.abs(ptA.y - ptB.y));\n        if (dy > 1) {\n          minDy = Math.min(minDy, dy);\n        }\n      }\n    });\n\n    let hDx = minDx * 0.5;\n    let hDy = minDy * 0.5;\n\n    let rayPts = [];\n\n    for (let j = minY; j < maxY; j += minDy) {\n      for (let i = minX; i < maxX; i += minDx) {\n        rayPts.push(new Point(i + hDx, j + hDy));\n      }\n    }\n\n    rayPts.forEach(rayPt => {\n      let nearPts = [];\n      ptArray.forEach(pt => {\n        let dist = GeomUtil.distanceBetween(pt, rayPt);\n        if (dist < Math.max(minDx, minDy) * searchMultiplier) {\n          let ang = GeomUtil.angleBetween(pt, rayPt);\n          nearPts.push({\n            pt,\n            dist,\n            ang\n          });\n        }\n      });\n      if (nearPts.length < 4) {\n        return;\n      }\n      let i = nearPts.length;\n      while (i--) {\n        let nPt = nearPts[i].pt;\n        let seg = new Segment(rayPt, nPt);\n        let hits = GeomUtil.segmentSegmentsIntersections(seg, segs, true);\n        if (hits.length > 0) {\n          nearPts.splice(i, 1);\n        }\n      }\n      nearPts.sort((a, b) => {\n        if (a.ang < b.ang) {\n          return -1;\n        } else if (a.ang > b.ang) {\n          return 1;\n        }\n        return 0;\n      });\n      i = nearPts.length;\n      while (i--) {\n        let nPtA = nearPts[i].pt;\n        let tokenA = token(nPtA);\n        let j = nearPts.length;\n        let ok = false;\n        while (j--) {\n          if (i === j) {\n            continue;\n          }\n          let nPtB = nearPts[j].pt;\n          let tokenB = token(nPtB);\n          if (cxs[tokenA].indexOf(tokenB) === -1) {\n            ok = true;\n            break;\n          }\n        }\n        if (!ok) {\n          nearPts.splice(i, 1);\n        }\n      }\n      let ok = true;\n      nearPts.forEach((npA, idx) => {\n        let npB = nearPts[(idx + 1) % nearPts.length];\n        let tokenA = token(npA.pt);\n        let tokenB = token(npB.pt);\n        if (cxs[tokenA].indexOf(tokenB) === -1) {\n          ok = false;\n        }\n      });\n      if (ok) {\n        let polyPts = nearPts.map(nPt => nPt.pt);\n        let cen = GeomUtil.averagePoints(...polyPts);\n        let cenToken = token(cen);\n        if (cenTokens.indexOf(cenToken) === -1) {\n          cenTokens.push(cenToken);\n          pointGroups.push(polyPts);\n        }\n      }\n    });\n\n    return pointGroups;\n\n  }\n\n}\n\n","import { Segment, Segments, SegmentCollection, Point, GeomUtil } from \"./geom/geom.js\";\nimport { Analyzer } from \"./analyzer.js\";\n\nexport class Optimize {\n  /**\n   *\n   * @param {SegmentCollection[]} segCols\n   * @param {boolean} [noSplit]\n   * @param {boolean} [trimSmall]\n   * @param {number} [smallDist]\n   * @param {boolean} [optimizePathOrder]\n   * @param {boolean} [splitTeeIntersections]\n   * @returns {Segments}\n   */\n  static segmentCollections(segCols, noSplit = false, trimSmall = true, smallDist = 1, optimizePathOrder = false, splitTeeIntersections = false, splitCrossIntersections = false) {\n    let allsegs = segCols.reduce((arr, sc) => arr.concat(sc.toSegments()), []);\n    return Optimize.segments(allsegs, noSplit, trimSmall, smallDist, optimizePathOrder, splitTeeIntersections, splitCrossIntersections);\n  }\n  /**\n   *\n   * @param {SegmentCollection[]} segCols\n   * @param {boolean} [splitTeeIntersections]\n   * @returns {Segments}\n   */\n  static segmentCollectionsPathOrder(segCols, splitTeeIntersections = false, splitCrossIntersections = false) {\n    let allsegs = segCols.reduce((arr, sc) => arr.concat(sc.toSegments()), []);\n    return new Segments(Analyzer.pathOrder(allsegs, splitTeeIntersections, splitCrossIntersections));\n  }\n  /**\n   *\n   * @param {Segment[]} segs\n   * @param {boolean} [noSplitColinear]\n   * @param {boolean} [trimSmall]\n   * @param {number} [smallDist]\n   * @param {boolean} [optimizePathOrder]\n   * @param {boolean} [splitTeeIntersections]\n   * @returns {Segments}\n   */\n  static segments(segs, noSplitColinear = false, trimSmall = true, smallDist = 1, optimizePathOrder = false, splitTeeIntersections = false, splitCrossIntersections = false) {\n\n    segs = Optimize._segments(segs, noSplitColinear, trimSmall, smallDist);\n\n    if (optimizePathOrder) {\n      segs = Analyzer.pathOrder(segs, splitTeeIntersections, splitCrossIntersections);\n    }\n\n    return new Segments(segs);\n  }\n\n  /**\n   * JS fallback for segment optimization  \n   * @private\n   */\n  static _segments(segs, noSplitColinear, trimSmall, smallDist) {\n    const sb = segs;\n    segs = [];\n\n    // Dedupe\n    while (sb.length) {\n      let s = sb.shift();\n      let n = segs.length\n      let found = false;\n      while (n--) {\n        const sn = segs[n];\n        if (Segment.isEqual(s, sn)) {\n          found = true;\n          break;\n        }\n      }\n      if (!found) {\n        segs.push(s);\n      }\n    }\n\n    // Merge colinear\n    if (!noSplitColinear) {\n\n      for (let n = 0; n < 3; n++) {\n        let i = segs.length;\n        let overlaps = 0;\n\n        while (i--) {\n          let segA = segs[i];\n          let aa, ab, ba, bb, heading;\n          for (let j = i - 1; j >= 0; j--) {\n            let segB = segs[j];\n            let same = false;\n            let isRev = false;\n            if (GeomUtil.sameAngle(segA, segB)) {\n              same = true;\n              aa = Point.clone(segA.a);\n              ab = Point.clone(segA.b);\n              ba = Point.clone(segB.a);\n              bb = Point.clone(segB.b);\n            } else if (GeomUtil.sameAngleRev(segA, segB)) {\n              same = isRev = true;\n              aa = Point.clone(segA.b);\n              ab = Point.clone(segA.a);\n              ba = Point.clone(segB.a);\n              bb = Point.clone(segB.b);\n            }\n            if (same) {\n              heading = GeomUtil.angleBetween(aa, ab);\n              GeomUtil.rotatePoints(heading, aa, ab, ba, bb);\n              if (Math.abs(aa.y - ba.y) < 0.1 && ab.x >= ba.x - 0.0001 && aa.x <= bb.x + 0.0001) {\n                overlaps++;\n                if (aa.x < ba.x) {\n                  if (!isRev) {\n                    segB.a = segA.a;\n                  } else {\n                    segB.a = segA.b;\n                  }\n                }\n                if (ab.x > bb.x) {\n                  if (!isRev) {\n                    segB.b = segA.b;\n                  } else {\n                    segB.b = segA.a;\n                  }\n                }\n                segs.splice(i, 1);\n                break;\n              }\n            }\n          }\n        }\n      }\n\n    }\n\n    // Trim small\n    let i = segs.length;\n    while (i--) {\n      let seg = segs[i];\n      if (!seg) {\n        segs.splice(i, 1);\n        continue;\n      }\n      if (trimSmall && GeomUtil.distanceBetween(seg.a, seg.b) < smallDist) {\n        segs.splice(i, 1);\n        continue;\n      }\n    }\n\n    console.log(`[JS] Optimize: ${sb.length + segs.length} -> ${segs.length} segments`);\n    return segs;\n  }\n\n}\n","// @ts-check\n/**\n * Edge-Based Hidden Line Renderer\n * \n * A faster alternative to clipper-based boolean operations.\n * Uses per-edge occlusion testing.\n */\n\nimport { Optimize } from './optimize.js';\n\nimport {\n    Vector3,\n    Vector2,\n    Raycaster,\n    Camera,\n    Scene,\n    Mesh,\n    WebGLRenderTarget,\n    NearestFilter,\n    RGBAFormat,\n    UnsignedByteType,\n    MeshDepthMaterial,\n    RGBADepthPacking,\n    ShaderMaterial,\n    BufferAttribute,\n    BufferGeometry,\n    DoubleSide\n} from \"three\";\n\n/**\n * @typedef {Object} Edge3D\n * @property {Vector3} a - Start point (world space)\n * @property {Vector3} b - End point (world space)\n * @property {Vector3} normal1 - First face normal\n * @property {Vector3} [normal2] - Second face normal (if shared edge)\n * @property {number} faceIdx1 - First face index\n * @property {number} [faceIdx2] - Second face index\n * @property {Mesh} mesh - Parent mesh\n * @property {boolean} [isHatch] - Is this a hatch line?\n */\n\n/**\n * @typedef {Object} Edge2D\n * @property {Vector2} a - Start point (screen space)\n * @property {Vector2} b - End point (screen space)\n * @property {Vector3} a3d - Start point (world space)\n * @property {Vector3} b3d - End point (world space)\n * @property {Vector3} midpoint3d - Midpoint in world space\n * @property {boolean} isProfile - Is this a silhouette edge?\n * @property {boolean} visible - Is this edge visible?\n * @property {number} faceIdx - Parent face index\n * @property {number} [faceIdx2] - Second face index (if shared edge)\n * @property {Mesh} mesh - Parent mesh\n * @property {boolean} [isHatch] - Is this a hatch line?\n * @property {boolean} [isSilhouette] - Is this a silhouette edge (borders void)?\n * @property {Vector3} [normal1] - First face normal (propagated)\n * @property {Vector3} [normal2] - Second face normal (propagated)\n * @property {number} [adjacentFaceCount] - Number of adjacent faces (debug/filtering)\n * @property {number} [faceSimilarity] - Similarity of adjacent face normals (debug/filtering)\n * @property {boolean} [isTJunctionStraggler] - Is this edge a result of a T-junction split?\n */\n\n/**\n * @typedef {Object} Point2D\n * @property {number} x\n * @property {number} y\n */\n\n/**\n * @typedef {Object} ProjectedFace\n * @property {Vector2} a2d - Screen space vertex A\n * @property {Vector2} b2d - Screen space vertex B\n * @property {Vector2} c2d - Screen space vertex C\n * @property {number} depthA - Depth at vertex A\n * @property {number} depthB - Depth at vertex B\n * @property {number} depthC - Depth at vertex C\n * @property {Mesh} mesh - Source mesh\n * @property {number} faceIdx - Original face index\n * @property {Vector3} normal - Face normal (world space)\n * @property {number} constant - Plane constant d\n */\n\n/**\n * Extract edges from a mesh with face normal information\n * Only extracts edges from front-facing faces (skips back-facing)\n * @param {Mesh} mesh \n * @param {Vector3} cameraPosition - Camera position for face culling\n * @returns {Edge3D[]}\n */\nexport function extractEdges(mesh, cameraPosition) {\n    const geometry = mesh.geometry;\n    const position = geometry.attributes.position;\n    const index = geometry.index;\n\n    if (!position) return [];\n\n    /** @type {Map<string, Edge3D>} */\n    const edgeMap = new Map();\n\n    // Snap tolerance for position-based edge matching\n    const SNAP = 1000; // Precision: 3 decimal places\n\n    // Position-based edge key (not index-based, handles duplicate vertices)\n    /**\n     * \n     * @param {Vector3} va \n     * @param {Vector3} vb \n     * @returns \n     */\n    const getEdgeKey = (va, vb) => {\n        const ax = Math.round(va.x * SNAP);\n        const ay = Math.round(va.y * SNAP);\n        const az = Math.round(va.z * SNAP);\n        const bx = Math.round(vb.x * SNAP);\n        const by = Math.round(vb.y * SNAP);\n        const bz = Math.round(vb.z * SNAP);\n\n        const keyA = `${ax},${ay},${az}`;\n        const keyB = `${bx},${by},${bz}`;\n\n        // Consistent ordering for undirected edges\n        return keyA < keyB ? `${keyA}|${keyB}` : `${keyB}|${keyA}`;\n    };\n\n    /**\n     * \n     * @param {number} idx \n     * @returns \n     */\n    const getVertex = (idx) => {\n        const v = new Vector3(\n            position.getX(idx),\n            position.getY(idx),\n            position.getZ(idx)\n        );\n        return v.applyMatrix4(mesh.matrixWorld);\n    };\n\n    /**\n     * \n     * @param {Vector3} v0 \n     * @param {Vector3} v1 \n     * @param {Vector3} v2 \n     * @returns \n     */\n    const getFaceNormal = (v0, v1, v2) => {\n        const edge1 = new Vector3().subVectors(v1, v0);\n        const edge2 = new Vector3().subVectors(v2, v0);\n        return new Vector3().crossVectors(edge1, edge2).normalize();\n    };\n\n    const numFaces = index ? index.count / 3 : position.count / 3;\n\n    for (let f = 0; f < numFaces; f++) {\n        let i0, i1, i2;\n\n        if (index) {\n            i0 = index.getX(f * 3);\n            i1 = index.getX(f * 3 + 1);\n            i2 = index.getX(f * 3 + 2);\n        } else {\n            i0 = f * 3;\n            i1 = f * 3 + 1;\n            i2 = f * 3 + 2;\n        }\n\n        const v0 = getVertex(i0);\n        const v1 = getVertex(i1);\n        const v2 = getVertex(i2);\n        const normal = getFaceNormal(v0, v1, v2);\n\n        // Skip back-facing faces - only extract edges from front-facing faces\n        const faceMid = new Vector3().addVectors(v0, v1).add(v2).divideScalar(3);\n        const viewDir = new Vector3().subVectors(cameraPosition, faceMid);\n        if (normal.dot(viewDir) <= 0) {\n            continue; // Skip back-facing face\n        }\n\n        // Process three edges of the triangle\n        const edges = [\n            [v0, v1],\n            [v1, v2],\n            [v2, v0]\n        ];\n\n        for (const [va, vb] of edges) {\n            const key = getEdgeKey(va, vb);\n\n            if (edgeMap.has(key)) {\n                // Edge already exists - add second face normal\n                const existing = edgeMap.get(key);\n                if (existing && !existing.normal2) {\n                    existing.normal2 = normal.clone();\n                    existing.faceIdx2 = f;\n                }\n            } else {\n                edgeMap.set(key, {\n                    a: va.clone(),\n                    b: vb.clone(),\n                    normal1: normal.clone(),\n                    faceIdx1: f,\n                    mesh\n                });\n            }\n        }\n    }\n\n    return Array.from(edgeMap.values());\n}\n\n/**\n * Filter edges: remove those where both faces are back-facing\n * @param {Edge3D[]} edges \n * @param {Vector3} cameraPosition \n * @returns {Edge3D[]}\n */\nexport function filterBackfacing(edges, cameraPosition) {\n    return edges.filter(edge => {\n        const edgeMidpoint = new Vector3().addVectors(edge.a, edge.b).multiplyScalar(0.5);\n        const viewDir = new Vector3().subVectors(cameraPosition, edgeMidpoint).normalize();\n\n        const facing1 = edge.normal1.dot(viewDir) > 0;\n\n        // Boundary edges (only one face) are always kept - they're silhouettes\n        if (!edge.normal2) {\n            return true;\n        }\n\n        const facing2 = edge.normal2.dot(viewDir) > 0;\n\n        // Keep edge if at least one face is front-facing\n        return facing1 || facing2;\n    });\n}\n\n/**\n * Detect profile (silhouette) edges and mark smooth edges for removal\n * @param {Edge3D[]} edges \n * @param {Vector3} cameraPosition \n * @param {number} smoothThreshold - Dot product threshold for similar normals (default 0.99)\n * @returns {{profiles: Edge3D[], smoothFiltered: Edge3D[]}}\n */\nexport function classifyEdges(edges, cameraPosition, smoothThreshold = 0.99) {\n    const profiles = [];\n    const smoothFiltered = [];\n\n    // Debug counters\n    let boundaryCount = 0;\n    let profileCount = 0;\n    let smoothCount = 0;\n    let discardedCount = 0;\n\n    for (const edge of edges) {\n        const edgeMidpoint = new Vector3().addVectors(edge.a, edge.b).multiplyScalar(0.5);\n        const viewDir = new Vector3().subVectors(cameraPosition, edgeMidpoint).normalize();\n\n        const facing1 = edge.normal1.dot(viewDir) > 0;\n        const facing2 = edge.normal2 ? edge.normal2.dot(viewDir) > 0 : true; // Boundary edges count as profile\n\n        // Profile edge: one face front, one face back (or boundary)\n        if (facing1 !== facing2 || !edge.normal2) {\n            profiles.push(edge);\n            continue;\n        }\n\n        // Check if normals are similar (smooth shading edge)\n        if (edge.normal2) {\n            const similarity = edge.normal1.dot(edge.normal2);\n            // Keep edge only if normals are different enough (crease/hard edge)\n            // Filter out smooth edges where normals are nearly parallel\n            if (similarity < smoothThreshold) {\n                smoothFiltered.push(edge);\n            }\n            // Edges with similar normals (similarity >= threshold) are discarded as smooth surface edges\n        }\n    }\n\n    console.log(`classifyEdges: ${profiles.length} profiles, ${smoothFiltered.length} smooth/crease edges`);\n\n    return { profiles, smoothFiltered };\n}\n\n/**\n * Project 3D edges to screen space\n * @param {Edge3D[]} edges \n * @param {Camera} camera \n * @param {number} width \n * @param {number} height \n * @param {number} scale - Internal scale factor for precision (default 1)\n * @returns {Edge2D[]}\n */\nexport function projectEdges(edges, camera, width, height, scale = 1) {\n    const halfWidth = width / 2;\n    const halfHeight = height / 2;\n\n    /**\n     * \n     * @param {Vector3} p3d \n     * @returns \n     */\n    const projectPoint = (p3d) => {\n        const projected = p3d.clone().project(camera);\n        return new Vector2(\n            projected.x * halfWidth * scale,\n            -projected.y * halfHeight * scale\n        );\n    };\n\n    return edges.map(edge => ({\n        a: projectPoint(edge.a),\n        b: projectPoint(edge.b),\n        a3d: edge.a.clone(),\n        b3d: edge.b.clone(),\n        midpoint3d: new Vector3().addVectors(edge.a, edge.b).multiplyScalar(0.5),\n        isProfile: false, // Will be set by classifyEdges\n        visible: true,\n        faceIdx: edge.faceIdx1,\n        faceIdx2: edge.faceIdx2,\n        mesh: edge.mesh,\n        isHatch: edge.isHatch,\n        normal1: edge.normal1,  // Propagate normals for straggler detection\n        normal2: edge.normal2\n    }));\n}\n\n/**\n * Spatial hash for efficient edge queries\n */\nexport class SpatialHash {\n    /**\n     * @param {number} cellSize \n     */\n    constructor(cellSize) {\n        this.cellSize = cellSize;\n        /** @type {Map<string, Edge2D[]>} */\n        this.cells = new Map();\n    }\n\n    /**\n     * Get cell key for a point\n     * @param {number} x \n     * @param {number} y \n     * @returns {string}\n     */\n    getCellKey(x, y) {\n        const cx = Math.floor(x / this.cellSize);\n        const cy = Math.floor(y / this.cellSize);\n        return `${cx},${cy}`;\n    }\n\n    /**\n     * Get all cells an edge crosses\n     * @param {Edge2D} edge \n     * @returns {string[]}\n     */\n    getCellsCrossed(edge) {\n        const cells = new Set();\n\n        // Use line rasterization to find all cells\n        const dx = Math.abs(edge.b.x - edge.a.x);\n        const dy = Math.abs(edge.b.y - edge.a.y);\n        const steps = Math.max(dx, dy) / this.cellSize + 1;\n\n        for (let i = 0; i <= steps; i++) {\n            const t = i / steps;\n            const x = edge.a.x + t * (edge.b.x - edge.a.x);\n            const y = edge.a.y + t * (edge.b.y - edge.a.y);\n            cells.add(this.getCellKey(x, y));\n        }\n\n        return Array.from(cells);\n    }\n\n    /**\n     * Insert an edge into the spatial hash\n     * @param {Edge2D} edge \n     */\n    insert(edge) {\n        const cells = this.getCellsCrossed(edge);\n        for (const key of cells) {\n            if (!this.cells.has(key)) {\n                this.cells.set(key, []);\n            }\n            this.cells.get(key)?.push(edge);\n        }\n    }\n\n    /**\n     * Get all edges in a cell\n     * @param {string} key \n     * @returns {Edge2D[]}\n     */\n    query(key) {\n        return this.cells.get(key) || [];\n    }\n\n    /**\n     * Get all cell keys\n     * @returns {string[]}\n     */\n    getAllCells() {\n        return Array.from(this.cells.keys());\n    }\n\n    clear() {\n        this.cells.clear();\n    }\n}\n\n/**\n * Find intersection point of two 2D line segments\n * @param {Edge2D} e1 \n * @param {Edge2D} e2 \n * @returns {{t1: number, t2: number, point: Vector2} | null}\n */\nexport function findIntersection(e1, e2) {\n    const x1 = e1.a.x, y1 = e1.a.y;\n    const x2 = e1.b.x, y2 = e1.b.y;\n    const x3 = e2.a.x, y3 = e2.a.y;\n    const x4 = e2.b.x, y4 = e2.b.y;\n\n    const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n    if (Math.abs(denom) < 1e-10) return null; // Parallel\n\n    const t1 = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;\n    const t2 = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;\n\n    const eps = 0.001;\n    // Check if intersection is within both segments (excluding endpoints)\n    if (t1 > eps && t1 < 1 - eps && t2 > eps && t2 < 1 - eps) {\n        return {\n            t1,\n            t2,\n            point: new Vector2(\n                x1 + t1 * (x2 - x1),\n                y1 + t1 * (y2 - y1)\n            )\n        };\n    }\n\n    return null;\n}\n\n/**\n * Split edges at intersection points within a cell\n * @param {Edge2D[]} edges \n * @returns {Edge2D[]}\n */\nexport function splitAtIntersections(edges) {\n    /** @type {Map<Edge2D, {t: number, point: Vector2}[]>} */\n    const splits = new Map();\n\n    const eps = 0.01;\n\n    // Helper: check if point p lies on edge interior (not endpoints)\n    // Returns t parameter (0,1) if on edge, null otherwise\n    /**\n     * \n     * @param {Vector2} p \n     * @param {Edge2D} edge \n     * @returns \n     */\n    const pointOnEdgeInterior = (p, edge) => {\n        const dx = edge.b.x - edge.a.x;\n        const dy = edge.b.y - edge.a.y;\n        const lenSq = dx * dx + dy * dy;\n        if (lenSq < 1e-10) return null; // Degenerate edge\n\n        // Project p onto edge line\n        const t = ((p.x - edge.a.x) * dx + (p.y - edge.a.y) * dy) / lenSq;\n\n        // Check if t is in interior (not at endpoints)\n        if (t <= eps || t >= 1 - eps) return null;\n\n        // Check distance from point to projected point on line\n        const projX = edge.a.x + t * dx;\n        const projY = edge.a.y + t * dy;\n        const distSq = (p.x - projX) * (p.x - projX) + (p.y - projY) * (p.y - projY);\n\n        // Tolerance for \"on the edge\"\n        if (distSq < 1.0) { // 1 pixel tolerance\n            return t;\n        }\n        return null;\n    };\n\n    // Track edges that might be stragglers (their endpoint caused a T-junction)\n    const potentialStragglers = new Set();\n\n    // Find all intersections (crossing + T-junctions)\n    for (let i = 0; i < edges.length; i++) {\n        for (let j = i + 1; j < edges.length; j++) {\n            // Check for crossing intersection\n            const intersection = findIntersection(edges[i], edges[j]);\n            if (intersection) {\n                // Record split points for both edges\n                if (!splits.has(edges[i])) splits.set(edges[i], []);\n                if (!splits.has(edges[j])) splits.set(edges[j], []);\n\n                splits.get(edges[i])?.push({ t: intersection.t1, point: intersection.point });\n                splits.get(edges[j])?.push({ t: intersection.t2, point: intersection.point });\n            } else {\n                // Check for T-junctions: endpoint of one edge on interior of other\n                // Mark BOTH edges as potential stragglers\n\n                // Edge i's endpoints on edge j\n                const tAonJ = pointOnEdgeInterior(edges[i].a, edges[j]);\n                if (tAonJ !== null) {\n                    if (!splits.has(edges[j])) splits.set(edges[j], []);\n                    splits.get(edges[j])?.push({ t: tAonJ, point: edges[i].a.clone() });\n                    potentialStragglers.add(edges[i]);\n                    potentialStragglers.add(edges[j]);  // Mark BOTH\n                }\n\n                const tBonJ = pointOnEdgeInterior(edges[i].b, edges[j]);\n                if (tBonJ !== null) {\n                    if (!splits.has(edges[j])) splits.set(edges[j], []);\n                    splits.get(edges[j])?.push({ t: tBonJ, point: edges[i].b.clone() });\n                    potentialStragglers.add(edges[i]);\n                    potentialStragglers.add(edges[j]);  // Mark BOTH\n                }\n\n                // Edge j's endpoints on edge i\n                const tAonI = pointOnEdgeInterior(edges[j].a, edges[i]);\n                if (tAonI !== null) {\n                    if (!splits.has(edges[i])) splits.set(edges[i], []);\n                    splits.get(edges[i])?.push({ t: tAonI, point: edges[j].a.clone() });\n                    potentialStragglers.add(edges[i]);  // Mark BOTH\n                    potentialStragglers.add(edges[j]);\n                }\n\n                const tBonI = pointOnEdgeInterior(edges[j].b, edges[i]);\n                if (tBonI !== null) {\n                    if (!splits.has(edges[i])) splits.set(edges[i], []);\n                    splits.get(edges[i])?.push({ t: tBonI, point: edges[j].b.clone() });\n                    potentialStragglers.add(edges[i]);  // Mark BOTH\n                    potentialStragglers.add(edges[j]);\n                }\n            }\n        }\n    }\n\n    console.log(`T-junction detection: ${potentialStragglers.size} potential straggler edges`);\n\n    // Split edges at recorded points\n    const result = [];\n\n    for (const edge of edges) {\n        const edgeSplits = splits.get(edge);\n        const isStraggler = potentialStragglers.has(edge);\n\n        if (!edgeSplits || edgeSplits.length === 0) {\n            // Mark the edge as potential straggler if it was identified\n            edge.isTJunctionStraggler = isStraggler;\n            result.push(edge);\n            continue;\n        }\n\n        // Sort splits by t value\n        edgeSplits.sort((a, b) => a.t - b.t);\n\n        // Create sub-edges\n        let prevT = 0;\n        let prevPoint = edge.a;\n        let prevPoint3d = edge.a3d;\n\n        for (const split of edgeSplits) {\n            const point3d = new Vector3().lerpVectors(edge.a3d, edge.b3d, split.t);\n\n            result.push({\n                a: prevPoint.clone(),\n                b: split.point.clone(),\n                a3d: prevPoint3d.clone(),\n                b3d: point3d.clone(),\n                midpoint3d: new Vector3().addVectors(prevPoint3d, point3d).multiplyScalar(0.5),\n                isProfile: edge.isProfile,\n                visible: edge.visible,\n                faceIdx: edge.faceIdx,\n                mesh: edge.mesh,\n                isHatch: edge.isHatch,\n                normal1: edge.normal1,  // Propagate normal for smooth filter\n                isTJunctionStraggler: isStraggler\n            });\n\n            prevT = split.t;\n            prevPoint = split.point;\n            prevPoint3d = point3d;\n        }\n\n        // Final segment\n        result.push({\n            a: prevPoint.clone(),\n            b: edge.b.clone(),\n            a3d: prevPoint3d.clone(),\n            b3d: edge.b3d.clone(),\n            midpoint3d: new Vector3().addVectors(prevPoint3d, edge.b3d).multiplyScalar(0.5),\n            isProfile: edge.isProfile,\n            visible: edge.visible,\n            faceIdx: edge.faceIdx,\n            mesh: edge.mesh,\n            isHatch: edge.isHatch,\n            normal1: edge.normal1,  // Propagate normal for smooth filter\n            isTJunctionStraggler: isStraggler\n        });\n    }\n\n    return result;\n}\n\n/**\n * Test edge visibility using GPU depth buffer (fast O(1) per edge)\n * Uses a render target with depth material to read depth as RGBA\n * @param {Edge2D[]} edges \n * @param {Scene} scene \n * @param {Camera} camera \n * @param {number} epsilon - Depth tolerance (normalized 0-1)\n * @param {number} width - Viewport width\n * @param {number} height - Viewport height\n * @param {any} renderer - THREE.WebGLRenderer instance\n * @returns {Edge2D[]}\n */\nexport function testOcclusionDepthBuffer(edges, scene, camera, epsilon, width, height, renderer) {\n    const visibleEdges = [];\n\n    if (!renderer) {\n        console.warn('No renderer provided, skipping occlusion test');\n        return edges;\n    }\n\n    // Create render target for depth\n    const renderTarget = new WebGLRenderTarget(width, height, {\n        minFilter: NearestFilter,\n        magFilter: NearestFilter,\n        format: RGBAFormat,\n        type: UnsignedByteType\n    });\n\n    // Create depth material that encodes depth as color\n    const depthMaterial = new MeshDepthMaterial({\n        depthPacking: RGBADepthPacking\n    });\n\n    // Store original material overrides\n    const originalOverrideMaterial = scene.overrideMaterial;\n\n    // Render scene with depth material\n    scene.overrideMaterial = depthMaterial;\n    renderer.setRenderTarget(renderTarget);\n    renderer.render(scene, camera);\n\n    // Read the render target as RGBA\n    const depthData = new Uint8Array(width * height * 4);\n    renderer.readRenderTargetPixels(renderTarget, 0, 0, width, height, depthData);\n\n    // Restore scene\n    scene.overrideMaterial = originalOverrideMaterial;\n    renderer.setRenderTarget(null);\n\n    // Check if we got valid data\n    let hasData = false;\n    for (let i = 0; i < Math.min(4000, depthData.length); i += 4) {\n        if (depthData[i] !== 0 || depthData[i + 1] !== 0 || depthData[i + 2] !== 0) {\n            hasData = true;\n            break;\n        }\n    }\n\n    // Debug: sample center of depth buffer\n    const centerIdx = Math.floor(height / 2) * width * 4 + Math.floor(width / 2) * 4;\n    console.log(`Depth buffer center pixel (RGBA): ${depthData[centerIdx]}, ${depthData[centerIdx + 1]}, ${depthData[centerIdx + 2]}, ${depthData[centerIdx + 3]}`);\n\n    if (!hasData) {\n        console.warn('Could not read depth buffer, falling back to all-visible');\n        renderTarget.dispose();\n        depthMaterial.dispose();\n        return edges;\n    }\n\n    // Decode depth from RGBA using three.js formula\n    // See: https://github.com/mrdoob/three.js/blob/master/src/renderers/shaders/ShaderChunk/packing.glsl.js\n    // UnpackDownscale = 255/256\n    // UnpackFactors4 = (UnpackDownscale/1, UnpackDownscale/256, UnpackDownscale/65536, 1/16777216)\n    const UnpackDownscale = 255.0 / 256.0;\n    const PackFactors = [1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0];\n    const UnpackFactors4 = [\n        UnpackDownscale / PackFactors[0],  // 0.99609375\n        UnpackDownscale / PackFactors[1],  // 0.00389099...\n        UnpackDownscale / PackFactors[2],  // 0.0000152...\n        1.0 / PackFactors[3]               // 0.0000000059...\n    ];\n\n    /**\n     * \n     * @param {number} r \n     * @param {number} g \n     * @param {number} b \n     * @param {number} a \n     * @returns \n     */\n    const unpackDepth = (r, g, b, a) => {\n        // Normalize from 0-255 to 0-1\n        const rn = r / 255.0;\n        const gn = g / 255.0;\n        const bn = b / 255.0;\n        const an = a / 255.0;\n        // dot product with UnpackFactors4\n        return rn * UnpackFactors4[0] + gn * UnpackFactors4[1] + bn * UnpackFactors4[2] + an * UnpackFactors4[3];\n    };\n\n    // @ts-ignore\n    const near = camera.near;\n    // @ts-ignore  \n    const far = camera.far;\n\n    // Debug: log first few depth comparisons\n    let debugCount = 0;\n\n    for (const edge of edges) {\n        // Get screen-space coordinates of edge midpoint\n        const midX = (edge.a.x + edge.b.x) / 2;\n        const midY = (edge.a.y + edge.b.y) / 2;\n\n        const sx = Math.round(midX + width / 2);\n        const sy = Math.round(height / 2 + midY); // projectEdges already negates Y\n\n        // Check bounds\n        if (sx < 0 || sx >= width || sy < 0 || sy >= height) {\n            edge.visible = true;\n            visibleEdges.push(edge);\n            continue;\n        }\n\n        // Sample depth buffer (note: readRenderTargetPixels returns bottom-up)\n        const depthIdx = ((height - 1 - sy) * width + sx) * 4;\n        const sampledDepth = unpackDepth(\n            depthData[depthIdx],\n            depthData[depthIdx + 1],\n            depthData[depthIdx + 2],\n            depthData[depthIdx + 3]\n        );\n\n        // Compute expected depth using view-space Z (linear depth)\n        // MeshDepthMaterial stores: (viewZ - near) / (far - near) where viewZ is distance along camera's look direction\n        // For perspective cameras, we need to transform the midpoint to view space\n        const midpoint3d = edge.midpoint3d;\n\n        // Transform to view space (camera-relative coordinates)\n        const viewMatrix = camera.matrixWorldInverse;\n        const viewPos = midpoint3d.clone().applyMatrix4(viewMatrix);\n\n        // viewPos.z is negative in front of camera, so we negate it\n        const viewZ = -viewPos.z;\n\n        // Convert to 0-1 range matching MeshDepthMaterial\n        const expectedDepth = (viewZ - near) / (far - near);\n\n        // Debug logging\n        if (debugCount < 10) {\n            console.log(`Edge ${debugCount}: sample=${sampledDepth.toFixed(4)}, expected=${expectedDepth.toFixed(4)}, diff=${(sampledDepth - expectedDepth).toFixed(6)}`);\n            debugCount++;\n        }\n\n        // Compare: edge is visible if sampled depth >= expected depth (within tolerance)\n        // sampledDepth is depth of closest surface at this pixel\n        // expectedDepth is depth of the edge\n        // Edge is visible if it's at or in front of (closer than) the sampled surface\n        const isVisible = Math.abs(sampledDepth - expectedDepth) < epsilon || sampledDepth >= expectedDepth - epsilon;\n\n        if (isVisible) {\n            edge.visible = true;\n            visibleEdges.push(edge);\n        }\n    }\n\n    // Cleanup\n    renderTarget.dispose();\n    depthMaterial.dispose();\n\n    return visibleEdges;\n}\n\n/**\n * Test edge visibility using face ID buffer (correct occlusion)\n * Renders each face with a unique color = face index\n * Samples at edge midpoint to check if parent face is visible\n * @param {Edge2D[]} edges \n * @param {Mesh[]} meshes - All meshes in scene\n * @param {Camera} camera \n * @param {number} width - Viewport width\n * @param {number} height - Viewport height\n * @param {any} renderer - THREE.WebGLRenderer instance\n * @param {boolean} isProfile - If true, these are profile edges (always visible)\n * @returns {Edge2D[]}\n */\nexport function testOcclusionFaceID(edges, meshes, camera, width, height, renderer, isProfile = false) {\n    // Profile edges are ALWAYS visible (silhouette edges)\n    if (isProfile) {\n        edges.forEach(e => e.visible = true);\n        return edges;\n    }\n\n    const visibleEdges = [];\n\n    if (!renderer) {\n        console.warn('No renderer provided, skipping occlusion test');\n        return edges;\n    }\n\n    // Create render target for face IDs\n    const renderTarget = new WebGLRenderTarget(width, height, {\n        minFilter: NearestFilter,\n        magFilter: NearestFilter,\n        format: RGBAFormat,\n        type: UnsignedByteType\n    });\n\n    // Create face ID shader material\n    const faceIdMaterial = new ShaderMaterial({\n        vertexShader: `\n            attribute vec3 faceColor;\n            varying vec3 vFaceColor;\n            void main() {\n                vFaceColor = faceColor;\n                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n            }\n        `,\n        fragmentShader: `\n            varying vec3 vFaceColor;\n            void main() {\n                gl_FragColor = vec4(vFaceColor, 1.0);\n            }\n        `,\n        side: DoubleSide\n    });\n\n    // Build meshes with face ID colors\n    const faceIdMeshes = [];\n    let globalFaceOffset = 0;\n\n    for (const mesh of meshes) {\n        // @ts-ignore - Attach offset for later lookup\n        mesh.__globalFaceOffset = globalFaceOffset;\n        const geom = mesh.geometry;\n        const position = geom.attributes.position;\n        const index = geom.index;\n\n        const numFaces = index ? index.count / 3 : position.count / 3;\n\n        // Create new geometry with face colors - APPLY WORLD TRANSFORM\n        const newPositions = [];\n        const faceColors = [];\n\n        for (let f = 0; f < numFaces; f++) {\n            let i0, i1, i2;\n            if (index) {\n                i0 = index.getX(f * 3);\n                i1 = index.getX(f * 3 + 1);\n                i2 = index.getX(f * 3 + 2);\n            } else {\n                i0 = f * 3;\n                i1 = f * 3 + 1;\n                i2 = f * 3 + 2;\n            }\n\n            // Get vertices and APPLY WORLD TRANSFORM\n            const v0 = new Vector3(position.getX(i0), position.getY(i0), position.getZ(i0));\n            const v1 = new Vector3(position.getX(i1), position.getY(i1), position.getZ(i1));\n            const v2 = new Vector3(position.getX(i2), position.getY(i2), position.getZ(i2));\n\n            v0.applyMatrix4(mesh.matrixWorld);\n            v1.applyMatrix4(mesh.matrixWorld);\n            v2.applyMatrix4(mesh.matrixWorld);\n\n            // Add world-space positions\n            newPositions.push(v0.x, v0.y, v0.z, v1.x, v1.y, v1.z, v2.x, v2.y, v2.z);\n\n            // Encode face ID as RGB (globalFaceOffset + f + 1, reserve 0 for background)\n            const globalFaceId = globalFaceOffset + f + 1;\n            const r = (globalFaceId & 0xFF) / 255;\n            const g = ((globalFaceId >> 8) & 0xFF) / 255;\n            const b = ((globalFaceId >> 16) & 0xFF) / 255;\n\n            // Same color for all 3 vertices of this face\n            faceColors.push(r, g, b, r, g, b, r, g, b);\n        }\n\n        // Create geometry with world-space positions\n        const newGeom = new BufferGeometry();\n        newGeom.setAttribute('position', new BufferAttribute(new Float32Array(newPositions), 3));\n        newGeom.setAttribute('faceColor', new BufferAttribute(new Float32Array(faceColors), 3));\n\n        // Create mesh - no need for matrix since positions are already in world space\n        const faceIdMesh = new Mesh(newGeom, faceIdMaterial);\n        faceIdMeshes.push(faceIdMesh);\n\n        globalFaceOffset += numFaces;\n    }\n\n    // Create temporary scene with ALL face ID meshes\n    const tempScene = new Scene();\n    for (const faceIdMesh of faceIdMeshes) {\n        tempScene.add(faceIdMesh);\n    }\n\n    // Render ALL meshes TOGETHER in one pass\n    renderer.setRenderTarget(renderTarget);\n    renderer.setClearColor(0x000000, 1);\n    renderer.clear();\n    renderer.render(tempScene, camera);\n\n    // Read the render target\n    const faceIdData = new Uint8Array(width * height * 4);\n    renderer.readRenderTargetPixels(renderTarget, 0, 0, width, height, faceIdData);\n\n    // Restore renderer\n    renderer.setRenderTarget(null);\n\n    // Process edges\n    for (const edge of edges) {\n        const midX = (edge.a.x + edge.b.x) / 2;\n        const midY = (edge.a.y + edge.b.y) / 2;\n\n        const sx = Math.round(midX + width / 2);\n        const sy = Math.round(height / 2 + midY);\n\n        if (sx < 0 || sx >= width || sy < 0 || sy >= height) {\n            edge.visible = true;\n            visibleEdges.push(edge);\n            continue;\n        }\n\n        const idx = ((height - 1 - sy) * width + sx) * 4;\n        const r = faceIdData[idx];\n        const g = faceIdData[idx + 1];\n        const b = faceIdData[idx + 2];\n\n        const sampledFaceId = r + (g << 8) + (b << 16);\n\n        // If 0 (background), edge is visible\n        if (sampledFaceId === 0) {\n            edge.visible = true;\n            visibleEdges.push(edge);\n            continue;\n        }\n\n        // Edge parent face ID is faceIdx + 1 (we offset by 1 to reserve 0 for background)\n        // Add the mesh's global offset to its local face index.\n        // @ts-ignore - __globalFaceOffset is attached during mesh processing\n        const parentMeshOffset = edge.mesh.__globalFaceOffset || 0;\n        const parentFaceId = parentMeshOffset + edge.faceIdx + 1;\n\n        // Edge is visible if sampled face matches parent face\n        if (sampledFaceId === parentFaceId) {\n            edge.visible = true;\n            visibleEdges.push(edge);\n        } else {\n            // Also check the second face if it's a shared edge\n            if (edge.faceIdx2 !== undefined) {\n                const parentFaceId2 = parentMeshOffset + edge.faceIdx2 + 1;\n                if (sampledFaceId === parentFaceId2) {\n                    edge.visible = true;\n                    visibleEdges.push(edge);\n                    continue;\n                }\n            }\n            edge.visible = false;\n        }\n    }\n\n    // Cleanup\n    renderTarget.dispose();\n    faceIdMaterial.dispose();\n    for (const m of faceIdMeshes) {\n        m.geometry.dispose();\n    }\n\n    return visibleEdges;\n}\n\n/**\n * Pure mathematical point-in-triangle test (2D)\n * @param {Vector2} p - Point to test\n * @param {Vector2} a - Triangle vertex A\n * @param {Vector2} b - Triangle vertex B\n * @param {Vector2} c - Triangle vertex C\n * @returns {boolean}\n */\nfunction pointInTriangle2D(p, a, b, c) {\n    /**\n     * \n     * @param {Vector2} p1 \n     * @param {Vector2} p2 \n     * @param {Vector2} p3 \n     * @returns \n     */\n    const sign = (p1, p2, p3) =>\n        (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);\n\n    const d1 = sign(p, a, b);\n    const d2 = sign(p, b, c);\n    const d3 = sign(p, c, a);\n\n    const hasNeg = (d1 < 0) || (d2 < 0) || (d3 < 0);\n    const hasPos = (d1 > 0) || (d2 > 0) || (d3 > 0);\n\n    return !(hasNeg && hasPos);\n}\n\n/**\n * Check if edge lies along a face edge (collinear and within)\n * @param {Vector2} edgeA - Edge start point\n * @param {Vector2} edgeB - Edge end point\n * @param {Vector2} faceEdgeA - Face edge start point\n * @param {Vector2} faceEdgeB - Face edge end point\n * @param {number} tolerance - Distance tolerance in pixels\n * @returns {boolean}\n */\nfunction edgeLiesAlongFaceEdge(edgeA, edgeB, faceEdgeA, faceEdgeB, tolerance = 2.0) {\n    // Get face edge direction and length\n    const dx = faceEdgeB.x - faceEdgeA.x;\n    const dy = faceEdgeB.y - faceEdgeA.y;\n    const lenSq = dx * dx + dy * dy;\n    if (lenSq < 1e-10) return false;  // Degenerate face edge\n\n    // Project edge endpoints onto face edge line\n    /** @param {{x:number, y:number}} p - Point with x,y */\n    const projectAndCheck = (p) => {\n        // Project p onto line defined by faceEdgeA->faceEdgeB\n        const t = ((p.x - faceEdgeA.x) * dx + (p.y - faceEdgeA.y) * dy) / lenSq;\n\n        // Projected point\n        const projX = faceEdgeA.x + t * dx;\n        const projY = faceEdgeA.y + t * dy;\n\n        // Distance from p to projected point\n        const distSq = (p.x - projX) * (p.x - projX) + (p.y - projY) * (p.y - projY);\n\n        // Check if close to line and within segment (with small margin)\n        return distSq < tolerance * tolerance && t >= -0.01 && t <= 1.01;\n    };\n\n    // Both edge endpoints must lie along the face edge\n    return projectAndCheck(edgeA) && projectAndCheck(edgeB);\n}\n\n/**\n * Find all faces adjacent to an edge geometrically\n * @param {Edge2D} edge - Edge with a, b (2D points)\n * @param {ProjectedFace[]} projectedFaces - Array of projected faces\n * @returns {{ face: ProjectedFace, matchedEdge: string, matchType: string}[]} - Array of matching faces with match type\n */\nexport function findAdjacentFaces(edge, projectedFaces) {\n    const results = [];\n\n    for (const face of projectedFaces) {\n        // Get the three edges of the face\n        const faceEdges = [\n            { a: face.a2d, b: face.b2d, name: 'AB' },\n            { a: face.b2d, b: face.c2d, name: 'BC' },\n            { a: face.c2d, b: face.a2d, name: 'CA' }\n        ];\n\n        for (const fe of faceEdges) {\n            if (edgeLiesAlongFaceEdge(edge.a, edge.b, fe.a, fe.b)) {\n                results.push({\n                    face,\n                    matchedEdge: fe.name,\n                    matchType: 'collinear'\n                });\n                break;  // Found a match for this face, move to next\n            }\n        }\n    }\n\n    return results;\n}\n\n/**\n * Compute depth at point inside triangle using barycentric interpolation\n * @param {Vector2} p - Point to compute depth at\n * @param {Vector2} a - Triangle vertex A (2D)\n * @param {Vector2} b - Triangle vertex B (2D)\n * @param {Vector2} c - Triangle vertex C (2D)\n * @param {number} depthA - Depth at vertex A\n * @param {number} depthB - Depth at vertex B\n * @param {number} depthC - Depth at vertex C\n * @returns {number} - Interpolated depth at p\n */\nfunction barycentricDepth(p, a, b, c, depthA, depthB, depthC) {\n    // Compute barycentric coordinates\n    const v0 = { x: c.x - a.x, y: c.y - a.y };\n    const v1 = { x: b.x - a.x, y: b.y - a.y };\n    const v2 = { x: p.x - a.x, y: p.y - a.y };\n\n    const dot00 = v0.x * v0.x + v0.y * v0.y;\n    const dot01 = v0.x * v1.x + v0.y * v1.y;\n    const dot02 = v0.x * v2.x + v0.y * v2.y;\n    const dot11 = v1.x * v1.x + v1.y * v1.y;\n    const dot12 = v1.x * v2.x + v1.y * v2.y;\n\n    const denom = dot00 * dot11 - dot01 * dot01;\n    if (Math.abs(denom) < 1e-10) return Infinity;\n\n    const u = (dot11 * dot02 - dot01 * dot12) / denom;\n    const v = (dot00 * dot12 - dot01 * dot02) / denom;\n    const w = 1 - u - v;\n\n    return w * depthA + v * depthB + u * depthC;\n}\n\n/**\n * Post-split smooth filter: removes T-junction straggler edges that lie on a coplanar face\n * This catches \"straggler\" edges from T-junctions that extend into smooth surfaces\n * @param {Edge2D[]} edges - Split edges to filter\n * @param {ProjectedFace[]} projectedFaces - Projected faces with normals\n * @param {number} coplanarThreshold - Normal dot product threshold (default 0.99)\n * @param {number} distanceThreshold - Plane distance threshold (default 0.5)\n * @returns {Edge2D[]}\n */\nexport function filterSmoothSplitEdges(edges, projectedFaces, coplanarThreshold = 0.99, distanceThreshold = 0.5) {\n    const filteredEdges = [];\n    let removedCount = 0;\n\n    for (const edge of edges) {\n        // Find all adjacent faces geometrically\n        const adjacentFaces = findAdjacentFaces(edge, projectedFaces);\n\n        // Store adjacent face count for debugging\n        edge.adjacentFaceCount = adjacentFaces.length;\n\n        let shouldRemove = false;\n\n        // Only remove if we have exactly 2 faces with matching normals AND matching plane constants\n        if (adjacentFaces.length === 2) {\n            const f1 = adjacentFaces[0].face;\n            const f2 = adjacentFaces[1].face;\n            const fn1 = f1.normal;\n            const fn2 = f2.normal;\n\n            if (fn1 && fn2) {\n                const dot = fn1.dot(fn2);\n                const similarity = Math.abs(dot);\n                edge.faceSimilarity = similarity;\n\n                // Check distance between planes (must be very close to be truly coplanar)\n                // If normals are parallel (dot > 0), d1 ~ d2 => diff ~ 0\n                // If normals are anti-parallel (dot < 0), d1 ~ -d2 => sum ~ 0\n                let distDiff;\n                if (dot > 0) {\n                    distDiff = Math.abs(f1.constant - f2.constant);\n                } else {\n                    distDiff = Math.abs(f1.constant + f2.constant);\n                }\n\n                if (similarity >= coplanarThreshold && distDiff < distanceThreshold) {\n                    // Edge lies between exactly 2 coplanar faces - remove it\n                    shouldRemove = true;\n                    removedCount++;\n                }\n            }\n        } else if (adjacentFaces.length > 2) {\n            // 3+ faces: check if ALL normals match AND ALL planes match\n            const faces = adjacentFaces.map(af => af.face).filter(f => f.normal);\n            if (faces.length >= 2) {\n                let allCoplanar = true;\n                let minSimilarity = 1;\n\n                for (let i = 1; i < faces.length; i++) {\n                    const dot = faces[0].normal.dot(faces[i].normal);\n                    const sim = Math.abs(dot);\n\n                    let distDiff;\n                    if (dot > 0) {\n                        distDiff = Math.abs(faces[0].constant - faces[i].constant);\n                    } else {\n                        distDiff = Math.abs(faces[0].constant + faces[i].constant);\n                    }\n\n                    minSimilarity = Math.min(minSimilarity, sim);\n\n                    if (sim < coplanarThreshold || distDiff >= distanceThreshold) {\n                        allCoplanar = false;\n                        break;\n                    }\n                }\n                edge.faceSimilarity = minSimilarity;\n\n                if (allCoplanar) {\n                    shouldRemove = true;\n                    removedCount++;\n                }\n            }\n        }\n\n        if (!shouldRemove) {\n            filteredEdges.push(edge);\n        }\n    }\n\n    console.log(`Geometric straggler filter: removed ${removedCount} coplanar edges`);\n    return filteredEdges;\n}\n/**\n * Test edge visibility using pure math (point-in-triangle + depth)\n * No GPU, no raycasting - fully mathematical\n * @param {Edge2D[]} edges \n * @param {ProjectedFace[]} projectedFaces - Array of {a2d, b2d, c2d, depthA, depthB, depthC, mesh, faceIdx}\n * @param {Camera} camera\n * @returns {Edge2D[]}\n */\nexport function testOcclusionMath(edges, projectedFaces, camera) {\n    const cameraPos = camera.position;\n    const viewMatrix = camera.matrixWorldInverse;\n\n    // JS fallback\n    return testOcclusionMathJS(edges, projectedFaces, cameraPos, viewMatrix);\n}\n\n/**\n * JS fallback for occlusion testing\n * @param {Edge2D[]} edges \n * @param {ProjectedFace[]} projectedFaces \n * @param {Vector3} cameraPos \n * @param {import('three').Matrix4} [viewMatrix] - Optional view matrix for proper depth calculation\n * @returns {Edge2D[]}\n */\nfunction testOcclusionMathJS(edges, projectedFaces, cameraPos, viewMatrix) {\n    const visibleEdges = [];\n    let debugHitCount = 0;\n    let debugOccludedCount = 0;\n\n    for (const edge of edges) {\n        // Get midpoint in 2D and 3D\n        const mid2d = new Vector2(\n            (edge.a.x + edge.b.x) / 2,\n            (edge.a.y + edge.b.y) / 2\n        );\n\n        // Compute edge midpoint depth using view-space Z-coordinate\n        // This correctly handles perspective distortion (not Euclidean distance)\n        const mid3d = edge.midpoint3d;\n        let edgeDepth;\n        if (viewMatrix) {\n            // Use view-space Z for proper perspective handling\n            edgeDepth = -mid3d.clone().applyMatrix4(viewMatrix).z;\n        } else {\n            // Fallback to Euclidean distance if no view matrix\n            edgeDepth = cameraPos.distanceTo(mid3d);\n        }\n\n        let occluded = false;\n\n        // Check against ALL faces\n        for (const face of projectedFaces) {\n            // Skip if this is the edge's parent face\n            if (face.mesh === edge.mesh &&\n                (face.faceIdx === edge.faceIdx || face.faceIdx === edge.faceIdx2)) {\n                continue;\n            }\n\n            // Point-in-triangle test in 2D\n            if (!pointInTriangle2D(mid2d, face.a2d, face.b2d, face.c2d)) {\n                continue;\n            }\n\n            // Compute depth of the face at this 2D point\n            const faceDepthAtPoint = barycentricDepth(\n                mid2d, face.a2d, face.b2d, face.c2d,\n                face.depthA, face.depthB, face.depthC\n            );\n\n            // If face is closer  edge is occluded\n            if (faceDepthAtPoint < edgeDepth - 0.001) {\n                occluded = true;\n                debugOccludedCount++;\n                break;\n            }\n            debugHitCount++;\n        }\n\n        if (!occluded) {\n            edge.visible = true;\n            visibleEdges.push(edge);\n        } else {\n            edge.visible = false;\n        }\n    }\n\n    console.log(`[JS] Occlusion debug: ${debugHitCount} point-in-triangle hits, ${debugOccludedCount} occluded`);\n    return visibleEdges;\n}\n\n/**\n * Test edge visibility using raycasting (slow fallback)\n * @param {Edge2D[]} edges \n * @param {Scene} scene \n * @param {Camera} camera \n * @param {number} epsilon - Distance tolerance (as fraction of distance)\n * @returns {Edge2D[]}\n */\nexport function testOcclusion(edges, scene, camera, epsilon = 0.05) {\n    const raycaster = new Raycaster();\n    const visibleEdges = [];\n\n    // Collect all meshes in the scene for intersection testing\n    /** @type {any[]} */\n    const meshes = [];\n    scene.traverse((obj) => {\n        // @ts-ignore - isMesh exists on Mesh objects\n        if (obj.isMesh) {\n            meshes.push(obj);\n        }\n    });\n\n    for (const edge of edges) {\n        // Get direction from camera to midpoint\n        const toMidpoint = new Vector3().subVectors(edge.midpoint3d, camera.position);\n        const direction = toMidpoint.clone().normalize();\n        const expectedDist = toMidpoint.length();\n\n        // Use relative epsilon based on distance\n        const relEps = expectedDist * epsilon;\n\n        // Raycast from camera towards the edge midpoint\n        raycaster.set(camera.position.clone(), direction);\n\n        const intersects = raycaster.intersectObjects(meshes, true);\n\n        if (intersects.length === 0) {\n            // No hit - edge is visible\n            edge.visible = true;\n            visibleEdges.push(edge);\n        } else {\n            // Check if any hit is significantly in front of the edge\n            let occluded = false;\n\n            for (const hit of intersects) {\n                // Skip hits at or beyond the edge's depth\n                if (hit.distance >= expectedDist - relEps) {\n                    continue;\n                }\n\n                // For same-mesh hits, check if it's the edge's own face\n                if (hit.object === edge.mesh) {\n                    // Skip if this is the same face the edge belongs to\n                    if (hit.faceIndex === edge.faceIdx) {\n                        continue;\n                    }\n                }\n\n                // Something is in front of the edge - it's occluded\n                occluded = true;\n                break;\n            }\n\n            if (!occluded) {\n                edge.visible = true;\n                visibleEdges.push(edge);\n            } else {\n                edge.visible = false;\n            }\n        }\n    }\n\n    return visibleEdges;\n}\n\n/**\n * Remove duplicate segments and merge colinear ones\n * @param {Edge2D[]} edges \n * @param {number} tolerance \n * @returns {Edge2D[]}\n */\nexport function optimizeEdges(edges, tolerance = 0.5) {\n    // Deduplicate using hash\n    /** @type {Map<string, Edge2D>} */\n    const unique = new Map();\n\n    /** @param {Point2D} p */\n    const hashPoint = (p) => `${Math.round(p.x / tolerance)},${Math.round(p.y / tolerance)}`;\n    /** @param {Edge2D} e */\n    const hashEdge = (e) => {\n        const h1 = hashPoint(e.a);\n        const h2 = hashPoint(e.b);\n        return h1 < h2 ? `${h1}-${h2}` : `${h2}-${h1}`;\n    };\n\n    for (const edge of edges) {\n        const key = hashEdge(edge);\n        if (!unique.has(key)) {\n            unique.set(key, edge);\n        }\n    }\n\n    // TODO: Merge colinear segments\n\n    return Array.from(unique.values());\n}\n\n/**\n * Cleanup orphaned edges by extending to find intersections\n * An orphaned endpoint is a vertex with only 1 connected edge\n * Strategy: extend orphan edges and find line-line intersections\n * @param {Edge2D[]} edges - Edges to clean up\n * @param {number} tolerance - Distance tolerance for vertex matching\n * @param {number} maxExtension - Maximum distance to extend an edge\n * @returns {Edge2D[]}\n */\nexport function cleanupOrphanedEdges(edges, tolerance = 1.0, maxExtension = 50) {\n    // Build vertex -> edge connectivity map\n\n    const vertexKey = (/** @type {Point2D} */ p) => `${Math.round(p.x / tolerance)},${Math.round(p.y / tolerance)}`;\n\n    // Map of vertex hash -> { edges: [{edge, endpoint: 'a'|'b'}], point: Point2D }\n    const vertices = new Map();\n\n    for (const edge of edges) {\n        for (const endpoint of /** @type {const} */ (['a', 'b'])) {\n            /** @type {Point2D} */\n            const p = endpoint === 'a' ? edge.a : edge.b;\n            const key = vertexKey(p);\n            if (!vertices.has(key)) {\n                vertices.set(key, { edges: [], point: { x: p.x, y: p.y } });\n            }\n            vertices.get(key).edges.push({ edge, endpoint });\n        }\n    }\n\n    // Find orphaned endpoints (vertices with only 1 edge)\n    const orphans = [];\n    for (const [key, vertex] of vertices) {\n        if (vertex.edges.length === 1) {\n            const { edge, endpoint } = vertex.edges[0];\n            const orphanPoint = vertex.point;\n            const otherPoint = endpoint === 'a' ? edge.b : edge.a;\n\n            // Compute direction (from fixed end toward orphan end)\n            const dx = orphanPoint.x - otherPoint.x;\n            const dy = orphanPoint.y - otherPoint.y;\n            const len = Math.sqrt(dx * dx + dy * dy);\n            if (len < 0.001) continue;\n\n            orphans.push({\n                key,\n                edge,\n                endpoint,\n                point: orphanPoint,\n                otherPoint,\n                dirX: dx / len,\n                dirY: dy / len,\n                len\n            });\n        }\n    }\n\n    console.log(`Edge cleanup: found ${orphans.length} orphaned endpoints`);\n    if (orphans.length === 0) return edges;\n\n    // Line-line intersection helper\n    // Returns t values for intersection point on both lines, or null if parallel\n    /**\n     * \n     * @param {Point2D} p1 \n     * @param {Point2D} d1 \n     * @param {Point2D} p2 \n     * @param {Point2D} d2 \n     * @returns {{t1: number, t2: number}|null}\n     */\n    const lineIntersection = (p1, d1, p2, d2) => {\n        const cross = d1.x * d2.y - d1.y * d2.x;\n        if (Math.abs(cross) < 0.0001) return null; // Parallel\n\n        const dx = p2.x - p1.x;\n        const dy = p2.y - p1.y;\n\n        const t1 = (dx * d2.y - dy * d2.x) / cross;\n        const t2 = (dx * d1.y - dy * d1.x) / cross;\n\n        return { t1, t2 };\n    };\n\n    let extensionsCount = 0;\n    const processed = new Set();\n\n    for (let i = 0; i < orphans.length; i++) {\n        const orphan = orphans[i];\n        if (processed.has(orphan.key)) continue;\n\n        let bestMatch = null;\n        /** @type {Point2D | null} */\n        let bestIntersection = null;\n        let bestDist = Infinity;\n\n        for (let j = 0; j < orphans.length; j++) {\n            if (i === j) continue;\n            const candidate = orphans[j];\n            if (processed.has(candidate.key)) continue;\n\n            // Check if candidate's orphan point is reasonably close\n            const dist = Math.sqrt(\n                (candidate.point.x - orphan.point.x) ** 2 +\n                (candidate.point.y - orphan.point.y) ** 2\n            );\n            if (dist > maxExtension * 2) continue;\n\n            // Extend both lines and find intersection\n            // orphan: starts at orphan.point, direction orphan.dirX/dirY\n            // candidate: starts at candidate.point, direction candidate.dirX/dirY\n            const result = lineIntersection(\n                { x: orphan.point.x, y: orphan.point.y },\n                { x: orphan.dirX, y: orphan.dirY },\n                { x: candidate.point.x, y: candidate.point.y },\n                { x: candidate.dirX, y: candidate.dirY }\n            );\n\n            if (!result) continue; // Parallel lines\n\n            // t1 > 0 means intersection is in forward direction from orphan\n            // t2 > 0 means intersection is in forward direction from candidate\n            // Both must be positive (extending, not backtracking)\n            if (result.t1 < -0.1 || result.t2 < -0.1) continue;\n            if (result.t1 > maxExtension || result.t2 > maxExtension) continue;\n\n            // Compute intersection point\n            const ix = orphan.point.x + result.t1 * orphan.dirX;\n            const iy = orphan.point.y + result.t1 * orphan.dirY;\n\n            // Prefer closer intersections\n            const intersectDist = result.t1 + result.t2;\n            if (intersectDist < bestDist) {\n                bestDist = intersectDist;\n                bestMatch = candidate;\n                bestIntersection = { x: ix, y: iy };\n            }\n        }\n\n        if (bestMatch && bestIntersection) {\n            // Check if extension would cross any other edges\n            // Check segment from orphan.point to intersection\n            const crosses1 = segmentCrossesEdges(\n                orphan.point,\n                bestIntersection,\n                edges,\n                orphan.edge,\n                bestMatch.edge\n            );\n            // Check segment from bestMatch.point to intersection\n            const crosses2 = segmentCrossesEdges(\n                bestMatch.point,\n                bestIntersection,\n                edges,\n                orphan.edge,\n                bestMatch.edge\n            );\n\n            if (crosses1 || crosses2) {\n                // Skip this extension - it would cross existing edges\n                continue;\n            }\n\n            // Extend both edges to meet at intersection point\n            if (orphan.endpoint === 'a') {\n                orphan.edge.a.x = bestIntersection.x;\n                orphan.edge.a.y = bestIntersection.y;\n            } else {\n                orphan.edge.b.x = bestIntersection.x;\n                orphan.edge.b.y = bestIntersection.y;\n            }\n\n            if (bestMatch.endpoint === 'a') {\n                bestMatch.edge.a.x = bestIntersection.x;\n                bestMatch.edge.a.y = bestIntersection.y;\n            } else {\n                bestMatch.edge.b.x = bestIntersection.x;\n                bestMatch.edge.b.y = bestIntersection.y;\n            }\n\n            processed.add(orphan.key);\n            processed.add(bestMatch.key);\n            extensionsCount++;\n        }\n    }\n\n    console.log(`Edge cleanup: extended ${extensionsCount} pairs of edges to intersections`);\n\n    // Calculate average edge length for threshold\n    let totalLength = 0;\n    for (const edge of edges) {\n        const dx = edge.b.x - edge.a.x;\n        const dy = edge.b.y - edge.a.y;\n        totalLength += Math.sqrt(dx * dx + dy * dy);\n    }\n    const avgEdgeLength = totalLength / edges.length;\n    const snapThreshold = avgEdgeLength / 8;\n\n    console.log(`Edge cleanup: average edge length = ${avgEdgeLength.toFixed(2)}, snap threshold = ${snapThreshold.toFixed(2)}`);\n\n    // Rebuild orphan list after extensions\n    const finalVertices = new Map();\n    for (const edge of edges) {\n        for (const endpoint of /** @type {const} */ (['a', 'b'])) {\n            /** @type {Point2D} */\n            const p = endpoint === 'a' ? edge.a : edge.b;\n            const key = vertexKey(p);\n            if (!finalVertices.has(key)) {\n                finalVertices.set(key, { edges: [], point: p });\n            }\n            finalVertices.get(key).edges.push({ edge, endpoint });\n        }\n    }\n\n    // Find remaining orphans\n    const finalOrphans = [];\n    for (const [key, vertex] of finalVertices) {\n        if (vertex.edges.length === 1) {\n            finalOrphans.push({ key, ...vertex.edges[0], point: vertex.point });\n        }\n    }\n\n    console.log(`Edge cleanup: ${finalOrphans.length} orphaned endpoints before snap pass`);\n\n    // Snap nearby orphans together\n    let snapCount = 0;\n    const snapped = new Set();\n\n    for (let i = 0; i < finalOrphans.length; i++) {\n        const orphan = finalOrphans[i];\n        if (snapped.has(orphan.key)) continue;\n\n        let nearestOrphan = null;\n        let nearestDist = Infinity;\n\n        for (let j = 0; j < finalOrphans.length; j++) {\n            if (i === j) continue;\n            const candidate = finalOrphans[j];\n            if (snapped.has(candidate.key)) continue;\n\n            const dist = Math.sqrt(\n                (candidate.point.x - orphan.point.x) ** 2 +\n                (candidate.point.y - orphan.point.y) ** 2\n            );\n\n            if (dist < nearestDist) {\n                nearestDist = dist;\n                nearestOrphan = candidate;\n            }\n        }\n\n        if (nearestOrphan && nearestDist < snapThreshold) {\n            // Snap both to the midpoint\n            const midX = (orphan.point.x + nearestOrphan.point.x) / 2;\n            const midY = (orphan.point.y + nearestOrphan.point.y) / 2;\n\n            if (orphan.endpoint === 'a') {\n                orphan.edge.a.x = midX;\n                orphan.edge.a.y = midY;\n            } else {\n                orphan.edge.b.x = midX;\n                orphan.edge.b.y = midY;\n            }\n\n            if (nearestOrphan.endpoint === 'a') {\n                nearestOrphan.edge.a.x = midX;\n                nearestOrphan.edge.a.y = midY;\n            } else {\n                nearestOrphan.edge.b.x = midX;\n                nearestOrphan.edge.b.y = midY;\n            }\n\n            snapped.add(orphan.key);\n            snapped.add(nearestOrphan.key);\n            snapCount++;\n        }\n    }\n\n    console.log(`Edge cleanup: snapped ${snapCount} pairs of nearby orphans`);\n\n    // Final count\n    const remainingOrphans = finalOrphans.length - (snapCount * 2);\n    console.log(`Edge cleanup: ${remainingOrphans} orphaned endpoints remaining`);\n\n    return edges;\n}\n\n/**\n * Remove isolated edges where BOTH endpoints are orphaned (no connections to other edges)\n * These are floating edge fragments that don't connect to anything\n * @param {Edge2D[]} edges - Edges to filter\n * @param {number} tolerance - Distance tolerance for vertex matching\n * @returns {Edge2D[]} Filtered edges\n */\nexport function removeIsolatedEdges(edges, tolerance = 1.0) {\n\n    const vertexKey = (/** @type {Vector2} */ p) => `${Math.round(p.x / tolerance)},${Math.round(p.y / tolerance)}`;\n\n    // Count connections per vertex\n    const vertexConnections = new Map();\n\n    for (const edge of edges) {\n        const keyA = vertexKey(edge.a);\n        const keyB = vertexKey(edge.b);\n\n        vertexConnections.set(keyA, (vertexConnections.get(keyA) || 0) + 1);\n        vertexConnections.set(keyB, (vertexConnections.get(keyB) || 0) + 1);\n    }\n\n    // Filter out edges where both endpoints have only 1 connection (orphaned at both ends)\n    const filtered = edges.filter(edge => {\n        const keyA = vertexKey(edge.a);\n        const keyB = vertexKey(edge.b);\n        const connectionsA = vertexConnections.get(keyA) || 0;\n        const connectionsB = vertexConnections.get(keyB) || 0;\n\n        // Keep edge if at least one endpoint has 2+ connections\n        return connectionsA >= 2 || connectionsB >= 2;\n    });\n\n    const removed = edges.length - filtered.length;\n    if (removed > 0) {\n        console.log(`Edge cleanup: removed ${removed} isolated edges (orphaned at both ends)`);\n    }\n\n    return filtered;\n}\n\n/**\n * Check if a segment from p1 to p2 crosses any existing edge\n * @param {Point2D} p1 - Start point\n * @param {Point2D} p2 - End point\n * @param {Edge2D[]} edges - Existing edges to check against\n * @param {Edge2D} excludeEdge1 - Edge to exclude from check\n * @param {Edge2D} excludeEdge2 - Edge to exclude from check\n * @returns {boolean} True if segment crosses an edge\n */\nfunction segmentCrossesEdges(p1, p2, edges, excludeEdge1, excludeEdge2) {\n    const eps = 0.001;\n\n    for (const edge of edges) {\n        if (edge === excludeEdge1 || edge === excludeEdge2) continue;\n\n        // Check if segment p1->p2 intersects edge.a->edge.b\n        const d1x = p2.x - p1.x;\n        const d1y = p2.y - p1.y;\n        const d2x = edge.b.x - edge.a.x;\n        const d2y = edge.b.y - edge.a.y;\n\n        const cross = d1x * d2y - d1y * d2x;\n        if (Math.abs(cross) < eps) continue; // Parallel\n\n        const dx = edge.a.x - p1.x;\n        const dy = edge.a.y - p1.y;\n\n        const t1 = (dx * d2y - dy * d2x) / cross;\n        const t2 = (dx * d1y - dy * d1x) / cross;\n\n        // Check if intersection is within both segments (with small margin)\n        if (t1 > eps && t1 < 1 - eps && t2 > eps && t2 < 1 - eps) {\n            return true; // Crosses an edge\n        }\n    }\n\n    return false;\n}\n\n/**\n * Main hidden line removal function\n * @param {Mesh} mesh \n * @param {Camera} camera \n * @param {Scene} scene \n * @param {Object} options\n * @param {number} [options.smoothThreshold] - Threshold for smooth edge removal (default 0.99)\n * @param {number} [options.gridSize] - Spatial hash grid size (default 32)\n * @param {number} [options.occlusionEpsilon] - Occlusion test tolerance (relative to camera distance)\n * @param {boolean} [options.skipOcclusion] - Skip occlusion testing (debug mode)\n * @param {number} [options.width] - Viewport width\n * @param {number} [options.height] - Viewport height\n * @param {any} [options.renderer] - THREE.WebGLRenderer for depth buffer occlusion (fast)\n * @returns {{edges: Edge2D[], profiles: Edge2D[]}}\n */\nexport function computeHiddenLines(mesh, camera, scene, options = {}) {\n    const {\n        smoothThreshold = 0.99,\n        gridSize = 32,\n        occlusionEpsilon = 0.01, // 1% depth tolerance for depth buffer\n        skipOcclusion = false,\n        width = 800,\n        height = 600,\n        renderer = null\n    } = options;\n\n    console.time('extractEdges');\n    const edges3d = extractEdges(mesh, camera.position);\n    console.timeEnd('extractEdges');\n    console.log(`Extracted ${edges3d.length} edges`);\n\n    console.time('filterBackfacing');\n    const frontEdges = filterBackfacing(edges3d, camera.position);\n    console.timeEnd('filterBackfacing');\n    console.log(`After backface filter: ${frontEdges.length} edges`);\n\n    console.time('classifyEdges');\n    const { profiles, smoothFiltered } = classifyEdges(frontEdges, camera.position, smoothThreshold);\n    console.timeEnd('classifyEdges');\n    console.log(`Profiles: ${profiles.length}, Smooth edges: ${smoothFiltered.length}`);\n\n    // Combine profile and smooth edges for processing\n    const allEdges = [...profiles, ...smoothFiltered];\n\n    console.time('projectEdges');\n    let edges2d = projectEdges(allEdges, camera, width, height);\n    console.timeEnd('projectEdges');\n\n    // Mark profile edges\n    for (let i = 0; i < profiles.length; i++) {\n        edges2d[i].isProfile = true;\n    }\n\n    console.time('spatialHash');\n    const cellSize = Math.max(width, height) / gridSize;\n    const hash = new SpatialHash(cellSize);\n    for (const edge of edges2d) {\n        hash.insert(edge);\n    }\n    console.timeEnd('spatialHash');\n\n    console.time('splitIntersections');\n    // Process each cell\n    const processedEdges = new Set();\n    let splitEdges = [];\n\n    for (const cellKey of hash.getAllCells()) {\n        const cellEdges = hash.query(cellKey).filter(e => !processedEdges.has(e));\n        const split = splitAtIntersections(cellEdges);\n        splitEdges.push(...split);\n        for (const e of cellEdges) processedEdges.add(e);\n    }\n    console.timeEnd('splitIntersections');\n    console.log(`After splitting: ${splitEdges.length} edges`);\n\n    let visibleEdges;\n    if (skipOcclusion) {\n        console.log('Skipping occlusion test (debug mode)');\n        visibleEdges = splitEdges;\n    } else if (renderer) {\n        console.time('testOcclusion (face ID buffer)');\n        // Separate profile and non-profile edges\n        const profileEdges = splitEdges.filter(e => e.isProfile);\n        const otherEdges = splitEdges.filter(e => !e.isProfile);\n\n        // Profile edges are ALWAYS visible (silhouette edges)\n        profileEdges.forEach(e => e.visible = true);\n\n        // Test occlusion only for non-profile edges using face ID buffer\n        const visibleOtherEdges = testOcclusionFaceID(otherEdges, [mesh], camera, width, height, renderer, false);\n\n        visibleEdges = [...profileEdges, ...visibleOtherEdges];\n        console.timeEnd('testOcclusion (face ID buffer)');\n    } else {\n        console.time('testOcclusion (raycaster - slow)');\n        visibleEdges = testOcclusion(splitEdges, scene, camera, occlusionEpsilon);\n        console.timeEnd('testOcclusion (raycaster - slow)');\n    }\n    console.log(`Visible edges: ${visibleEdges.length}`);\n\n    console.time('optimize');\n    const optimizedEdges = optimizeEdges(visibleEdges);\n    console.timeEnd('optimize');\n\n    console.time('cleanup orphans');\n    const finalEdges = cleanupOrphanedEdges(optimizedEdges);\n    console.timeEnd('cleanup orphans');\n    console.log(`Final edges: ${finalEdges.length}`);\n\n    return {\n        edges: finalEdges,\n        profiles: finalEdges.filter(e => e.isProfile)\n    };\n}\n\n/**\n * Hidden line removal for multiple meshes with cross-object occlusion\n * All meshes are rendered to a single face ID buffer for correct occlusion\n * @param {Mesh[]} meshes \n * @param {Camera} camera \n * @param {Scene} scene \n * @param {Object} options\n * @param {number} [options.smoothThreshold]\n * @param {number} [options.gridSize]\n * @param {boolean} [options.skipOcclusion]\n * @param {number} [options.width]\n * @param {number} [options.height]\n * @param {any} [options.renderer]\n * @param {Edge3D[]} [options.hatchEdges] - Optional array of Edge3D objects for hatching\n * @param {number} [options.minHatchDotProduct] - Minimum dot product with view vector to keep hatch edges (0-1)\n * @param {number} [options.internalScale] - Internal scale factor (default: 4)\n * @param {number} [options.distanceThreshold] - Distance threshold for coplanar detection (default: 0.5)\n * @returns {{edges: Edge2D[], profiles: Edge2D[], allEdges: Edge2D[], projectedFaces: ProjectedFace[]}}\n */\nexport function computeHiddenLinesMultiple(meshes, camera, scene, options = {}) {\n    const {\n        smoothThreshold = 0.99,\n        gridSize = 32,\n        skipOcclusion = false,\n        width = 800,\n        height = 600,\n        renderer = null,\n        internalScale = 4,  // Scale up internally for better precision\n        distanceThreshold = 0.5 // Default plane distance threshold\n    } = options;\n\n    // Process each mesh to extract edges (keep local face indices with mesh reference)\n    let allEdges3d = [];\n\n    for (const mesh of meshes) {\n        mesh.updateMatrixWorld(true);\n        const edges3d = extractEdges(mesh, camera.position);\n        // Edges already have mesh reference and local faceIdx1/faceIdx2 from extractEdges\n        allEdges3d.push(...edges3d);\n    }\n\n    console.log(`Extracted ${allEdges3d.length} edges from ${meshes.length} meshes`);\n\n    // Classify edges: identify profiles and filter smooth edges\n    const { profiles, smoothFiltered } = classifyEdges(allEdges3d, camera.position, smoothThreshold);\n    console.log(`Profiles: ${profiles.length}, Crease edges: ${smoothFiltered.length}`);\n\n    const allEdges = [...profiles, ...smoothFiltered];\n    console.log(`After smooth filter: ${allEdges.length} edges`);\n\n    // Project to 2D (with internal scale for precision)\n    let edges2d = projectEdges(allEdges, camera, width, height, internalScale);\n\n    // Process additional hatch edges if provided\n    if (options.hatchEdges && options.hatchEdges.length > 0) {\n        console.log(`Processing ${options.hatchEdges.length} hatch edges...`);\n        // Filter backfacing hatch edges\n        let visibleHatch = filterBackfacing(options.hatchEdges, camera.position);\n\n        // Filter over-dense hatching based on view angle\n        if (options.minHatchDotProduct !== undefined) {\n            const threshold = options.minHatchDotProduct;\n            visibleHatch = visibleHatch.filter(edge => {\n                const edgeMidpoint = new Vector3().addVectors(edge.a, edge.b).multiplyScalar(0.5);\n                const viewDir = new Vector3().subVectors(camera.position, edgeMidpoint).normalize();\n                const dot = edge.normal1.dot(viewDir);\n                return Math.abs(dot) >= threshold;\n            });\n            console.log(`Density filter: kept ${visibleHatch.length} hatch edges (threshold ${threshold})`);\n        }\n\n        // Project\n        const hatch2d = projectEdges(visibleHatch, camera, width, height, internalScale);\n\n        // Mark explicitly (in case projectEdges didn't catch it from source)\n        hatch2d.forEach(e => e.isHatch = true);\n\n        // Add to main list\n        edges2d.push(...hatch2d);\n        console.log(`Added ${hatch2d.length} visible hatch edges`);\n    }\n\n    // Mark profile edges\n    // Split all edges at intersections (direct O(n) comparison - no spatial hash)\n    console.time('splitIntersections');\n    const splitEdges = splitAtIntersections(edges2d);\n    console.timeEnd('splitIntersections');\n    console.log(`After splitting: ${splitEdges.length} edges`);\n\n    // Build projected faces array for math occlusion\n    console.time('buildProjectedFaces');\n    /** @type {ProjectedFace[]} */\n    const projectedFaces = [];\n    const cameraPos = camera.position;\n    const halfWidth = width / 2;\n    const halfHeight = height / 2;\n\n    for (const mesh of meshes) {\n        const geom = mesh.geometry;\n        const position = geom.attributes.position;\n        const index = geom.index;\n        const numFaces = index ? index.count / 3 : position.count / 3;\n\n        for (let f = 0; f < numFaces; f++) {\n            let i0, i1, i2;\n            if (index) {\n                i0 = index.getX(f * 3);\n                i1 = index.getX(f * 3 + 1);\n                i2 = index.getX(f * 3 + 2);\n            } else {\n                i0 = f * 3;\n                i1 = f * 3 + 1;\n                i2 = f * 3 + 2;\n            }\n\n            // Get world-space vertices\n            const v0 = new Vector3(position.getX(i0), position.getY(i0), position.getZ(i0)).applyMatrix4(mesh.matrixWorld);\n            const v1 = new Vector3(position.getX(i1), position.getY(i1), position.getZ(i1)).applyMatrix4(mesh.matrixWorld);\n            const v2 = new Vector3(position.getX(i2), position.getY(i2), position.getZ(i2)).applyMatrix4(mesh.matrixWorld);\n\n            // Compute face normal and check if front-facing\n            const edge1 = new Vector3().subVectors(v1, v0);\n            const edge2 = new Vector3().subVectors(v2, v0);\n            const normal = new Vector3().crossVectors(edge1, edge2).normalize();\n            const faceMid = new Vector3().addVectors(v0, v1).add(v2).divideScalar(3);\n            const viewDir = new Vector3().subVectors(cameraPos, faceMid);\n\n            // Plane constant d for the plane equation ax + by + cz + d = 0\n            // d = -(n . p)\n            const constant = -normal.dot(v0);\n\n            // Only include front-facing faces (back-facing can't occlude)\n            if (normal.dot(viewDir) <= 0) continue;\n\n            // Project to 2D\n            const p0 = v0.clone().project(camera);\n            const p1 = v1.clone().project(camera);\n            const p2 = v2.clone().project(camera);\n\n            // Convert to screen coordinates (with same scale as edges)\n            const a2d = new Vector2(p0.x * halfWidth * internalScale, -p0.y * halfHeight * internalScale);\n            const b2d = new Vector2(p1.x * halfWidth * internalScale, -p1.y * halfHeight * internalScale);\n            const c2d = new Vector2(p2.x * halfWidth * internalScale, -p2.y * halfHeight * internalScale);\n\n            // Compute depths using view-space Z-coordinate (not Euclidean distance)\n            // This correctly handles perspective distortion for barycentric interpolation\n            const viewMatrix = camera.matrixWorldInverse;\n            const depthA = -v0.clone().applyMatrix4(viewMatrix).z;\n            const depthB = -v1.clone().applyMatrix4(viewMatrix).z;\n            const depthC = -v2.clone().applyMatrix4(viewMatrix).z;\n\n            projectedFaces.push({\n                a2d, b2d, c2d,\n                depthA, depthB, depthC,\n                mesh, faceIdx: f,\n                normal,  // Store normal for post-split smooth filter\n                constant // Store plane constant for coplanar detection\n            });\n        }\n    }\n    console.timeEnd('buildProjectedFaces');\n    console.log(`Built ${projectedFaces.length} projected faces for occlusion`);\n\n    // Classify silhouette edges (edges that border the void) - BEFORE cleanup/optimization\n    console.time('classifySilhouettes');\n    classifySilhouettes(splitEdges, projectedFaces);\n    console.timeEnd('classifySilhouettes');\n\n    // Geometric straggler filter: remove edges lying between coplanar faces\n    console.time('filterSmoothSplitEdges');\n    const smoothFilteredEdges = filterSmoothSplitEdges(splitEdges, projectedFaces, smoothThreshold, distanceThreshold);\n    console.timeEnd('filterSmoothSplitEdges');\n\n    // Occlusion using pure math\n    let visibleEdges;\n    if (skipOcclusion) {\n        visibleEdges = smoothFilteredEdges;\n    } else {\n        console.time('testOcclusion (math)');\n        // Test ALL edges through occlusion (no special treatment for profiles)\n        visibleEdges = testOcclusionMath(smoothFilteredEdges, projectedFaces, camera);\n        console.timeEnd('testOcclusion (math)');\n    }\n    console.log(`Visible edges: ${visibleEdges.length}`);\n\n    console.time('optimize');\n    const optimizedEdges = optimizeEdges(visibleEdges);\n    console.timeEnd('optimize');\n\n    console.time('cleanup orphans');\n    const cleanedEdges = cleanupOrphanedEdges(optimizedEdges);\n    console.timeEnd('cleanup orphans');\n\n    // Remove completely isolated edges (orphaned at both ends)\n    const filteredEdges = removeIsolatedEdges(cleanedEdges);\n    console.log(`Final edges before optimization: ${filteredEdges.length}`);\n\n    // Run through Optimize.js\n    let optimizedFinal = filteredEdges;\n    if (filteredEdges.length > 0) {\n        let totalLen = 0;\n        for (const e of filteredEdges) {\n            const dx = e.b.x - e.a.x;\n            const dy = e.b.y - e.a.y;\n            totalLen += Math.sqrt(dx * dx + dy * dy);\n        }\n        const avgLen = totalLen / filteredEdges.length;\n        const smallDist = avgLen / 10;\n        console.log(`Optimization: avgLen=${avgLen.toFixed(2)}, trim limit=${smallDist.toFixed(2)}`);\n\n        console.time('Optimize.segments');\n        // @ts-ignore - _segments is private but we need the raw objects to preserve metadata\n        optimizedFinal = Optimize.segments(filteredEdges, false, true, smallDist, false, false, false)._segments;\n        console.timeEnd('Optimize.segments');\n        console.log(`After optimization: ${optimizedFinal.length} edges`);\n    }\n\n\n\n    // Scale edges back down to original coordinate space\n    for (const edge of optimizedFinal) {\n        edge.a.x /= internalScale;\n        edge.a.y /= internalScale;\n        edge.b.x /= internalScale;\n        edge.b.y /= internalScale;\n    }\n    const finalEdges = optimizedFinal;\n\n    return {\n        edges: finalEdges,\n        profiles: finalEdges.filter(e => e.isProfile),\n        allEdges: splitEdges, // For debug visualization\n        projectedFaces: projectedFaces  // For face visualization\n    };\n}\n\n/**\n * Classify edges as silhouettes if they border the void (one side has no mesh)\n * Uses 2D ray casting from edge midpoint perpendicular to the edge\n * @param {Edge2D[]} edges - Edges to classify\n * @param {ProjectedFace[]} projectedFaces - Projected triangles for hit testing\n */\nfunction classifySilhouettes(edges, projectedFaces) {\n    const RAY_LENGTH = 1000; // Long ray to ensure we hit any face on that side\n\n    for (const edge of edges) {\n        // Hatches are never silhouettes\n        if (edge.isHatch) {\n            edge.isSilhouette = false;\n            continue;\n        }\n\n        // Calculate midpoint\n        const midX = (edge.a.x + edge.b.x) / 2;\n        const midY = (edge.a.y + edge.b.y) / 2;\n\n        // Calculate edge direction and perpendicular\n        const dx = edge.b.x - edge.a.x;\n        const dy = edge.b.y - edge.a.y;\n        const len = Math.sqrt(dx * dx + dy * dy);\n\n        if (len < 0.001) {\n            edge.isSilhouette = false;\n            continue;\n        }\n\n        // Perpendicular direction (normalized)\n        const perpX = -dy / len;\n        const perpY = dx / len;\n\n        // Raycast on each side - check if ray intersects any face edge\n        const leftHit = rayHitsAnyFace(midX, midY, perpX, perpY, RAY_LENGTH, projectedFaces);\n        const rightHit = rayHitsAnyFace(midX, midY, -perpX, -perpY, RAY_LENGTH, projectedFaces);\n\n        // Silhouette if one side has no intersection\n        edge.isSilhouette = !leftHit || !rightHit;\n    }\n\n    const silCount = edges.filter(e => e.isSilhouette).length;\n    console.log(`Classified ${silCount} silhouette edges out of ${edges.length}`);\n}\n\n/**\n * Check if a 2D ray from origin in direction (dx, dy) intersects any projected triangle\n * @param {number} ox - Ray origin X\n * @param {number} oy - Ray origin Y\n * @param {number} dx - Ray direction X\n * @param {number} dy - Ray direction Y\n * @param {number} maxDist - Maximum ray distance\n * @param {ProjectedFace[]} faces - Array of projected faces\n * @returns {boolean}\n */\nfunction rayHitsAnyFace(ox, oy, dx, dy, maxDist, faces) {\n    for (const face of faces) {\n        if (rayIntersectsTriangle(ox, oy, dx, dy, maxDist, face.a2d, face.b2d, face.c2d)) {\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * Check if 2D ray intersects a triangle (any of its 3 edges)\n * @param {number} ox - Ray origin X\n * @param {number} oy - Ray origin Y\n * @param {number} rdx - Ray direction X\n * @param {number} rdy - Ray direction Y\n * @param {number} maxDist\n * @param {Vector2} a - Triangle vertex A\n * @param {Vector2} b - Triangle vertex B\n * @param {Vector2} c - Triangle vertex C\n * @returns {boolean}\n */\nfunction rayIntersectsTriangle(ox, oy, rdx, rdy, maxDist, a, b, c) {\n    if (raySegmentIntersect(ox, oy, rdx, rdy, maxDist, a.x, a.y, b.x, b.y)) return true;\n    if (raySegmentIntersect(ox, oy, rdx, rdy, maxDist, b.x, b.y, c.x, c.y)) return true;\n    if (raySegmentIntersect(ox, oy, rdx, rdy, maxDist, c.x, c.y, a.x, a.y)) return true;\n    return false;\n}\n\n/**\n * Check if 2D ray (origin ox,oy, direction rdx,rdy) intersects line segment (x1,y1)-(x2,y2)\n * @param {number} ox\n * @param {number} oy\n * @param {number} rdx\n * @param {number} rdy\n * @param {number} maxDist\n * @param {number} x1\n * @param {number} y1\n * @param {number} x2\n * @param {number} y2\n * @returns {boolean}\n */\nfunction raySegmentIntersect(ox, oy, rdx, rdy, maxDist, x1, y1, x2, y2) {\n    const sdx = x2 - x1;\n    const sdy = y2 - y1;\n\n    const denom = rdx * sdy - rdy * sdx;\n    if (Math.abs(denom) < 1e-10) return false; // Parallel\n\n    const t = ((x1 - ox) * sdy - (y1 - oy) * sdx) / denom;\n    const u = ((x1 - ox) * rdy - (y1 - oy) * rdx) / denom;\n\n    // t > 0.1 (past origin, small epsilon), t <= maxDist, u in [0,1] (on segment)\n    return t > 0.1 && t <= maxDist && u >= 0 && u <= 1;\n}\n\n/**\n * Check if a 2D point is inside any projected triangle\n * @param {number} px \n * @param {number} py \n * @param {ProjectedFace[]} faces \n * @returns {boolean}\n */\nfunction pointInAnyFace(px, py, faces) {\n    for (const face of faces) {\n        if (pointInTriangle(px, py, face.a2d, face.b2d, face.c2d)) {\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * Check if point (px, py) is inside triangle (a, b, c) using barycentric coordinates\n * @param {number} px \n * @param {number} py \n * @param {Vector2} a \n * @param {Vector2} b \n * @param {Vector2} c \n * @returns {boolean}\n */\nfunction pointInTriangle(px, py, a, b, c) {\n    const v0x = c.x - a.x;\n    const v0y = c.y - a.y;\n    const v1x = b.x - a.x;\n    const v1y = b.y - a.y;\n    const v2x = px - a.x;\n    const v2y = py - a.y;\n\n    const dot00 = v0x * v0x + v0y * v0y;\n    const dot01 = v0x * v1x + v0y * v1y;\n    const dot02 = v0x * v2x + v0y * v2y;\n    const dot11 = v1x * v1x + v1y * v1y;\n    const dot12 = v1x * v2x + v1y * v2y;\n\n    const invDenom = 1 / (dot00 * dot11 - dot01 * dot01);\n    const u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n    const v = (dot00 * dot12 - dot01 * dot02) * invDenom;\n\n    return (u >= 0) && (v >= 0) && (u + v <= 1);\n}\n","/**\n * PlotterRenderer - GPU-based SVG renderer for Three.js\n * Based on SVGRenderer by @mrdoob / http://mrdoob.com/\n */\n\nimport { Camera, Color, Object3D, Vector3, DirectionalLight, PointLight, SpotLight } from \"three\";\nimport { extractNormalRegions } from \"./gpu-silhouette.js\";\nimport { generatePerspectiveHatches, clipLineOutsidePolygon } from \"./perspective-hatch.js\";\nimport { computeHiddenLinesMultiple } from \"./hidden-line.js\";\n\nvar lop = (n) => {\n  return Math.round(n * 100) / 100;\n};\n\nvar SVGObject = function (node) {\n  Object3D.call(this);\n  this.node = node;\n};\n\nSVGObject.prototype = Object.create(Object3D.prototype);\nSVGObject.prototype.constructor = SVGObject;\n\nvar PlotterRenderer = function () {\n  var _this = this,\n    _svg = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\"),\n    _silhouettes = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\"),\n    _edges = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\"),\n    _shading = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\"),\n    _svgWidth,\n    _svgHeight,\n    _svgWidthHalf,\n    _svgHeightHalf,\n    _clearColor = new Color();\n\n  // Add proper SVG namespace attributes for macOS and native rendering\n  _svg.setAttribute(\"xmlns\", \"http://www.w3.org/2000/svg\");\n  _svg.setAttribute(\"xmlns:inkscape\", \"http://www.inkscape.org/namespaces/inkscape\");\n  _svg.setAttribute(\"xmlns:xlink\", \"http://www.w3.org/1999/xlink\");\n  _svg.setAttribute(\"version\", \"1.1\");\n\n  // Setup SVG layers (order determines z-index: later = on top)\n  _silhouettes.setAttribute(\"inkscape:label\", \"Silhouettes\");\n  _silhouettes.setAttribute(\"inkscape:groupmode\", \"layer\");\n  _silhouettes.id = \"silhouettes_layer\";\n  _svg.appendChild(_silhouettes);\n\n  _shading.setAttribute(\"inkscape:label\", \"Shading\");\n  _shading.setAttribute(\"inkscape:groupmode\", \"layer\");\n  _shading.id = \"shading_layer\";\n  _svg.appendChild(_shading);\n\n  _edges.setAttribute(\"inkscape:label\", \"Edges\");\n  _edges.setAttribute(\"inkscape:groupmode\", \"layer\");\n  _edges.id = \"edges_layer\";\n  _svg.appendChild(_edges);\n\n  this.domElement = _svg;\n\n  // Layer toggles\n  this.showSilhouettes = true;\n  this.showEdges = true;\n  this.showHatches = true;\n\n  // Silhouette options (GPU normal regions)\n  this.silhouetteOptions = {\n    normalBuckets: 12,\n    simplifyTolerance: 2.0,\n    minArea: 100\n  };\n\n  // Hatch options (perspective hatching)\n  this.hatchOptions = {\n    baseSpacing: 8,\n    minSpacing: 3,\n    maxSpacing: 40,\n    depthFactor: 0.5,\n    insetPixels: 3,\n    stroke: 'black',\n    strokeWidth: '1px',\n    axisSettings: {\n      x: { rotation: 0, spacing: 8 },\n      y: { rotation: 0, spacing: 8 },\n      z: { rotation: 0, spacing: 8 }\n    },\n    // Brightness-based shading\n    brightnessShading: {\n      enabled: false,           // Enable lighting-based density\n      invert: false,            // True for white pen on black paper\n      lightDirection: null      // Override: Vector3 or null (auto from scene)\n    }\n  };\n\n  // Edge options (hidden line edges)\n  this.edgeOptions = {\n    stroke: 'white',\n    strokeWidth: '1px'\n  };\n\n  // Hidden-line options\n  this.hiddenLineOptions = {\n    smoothThreshold: 0.99\n  };\n\n  // WebGL renderer reference (needed for GPU operations)\n  this._glRenderer = null;\n\n  this.autoClear = true;\n\n  this.setClearColor = function (color) {\n    _clearColor.set(color);\n  };\n\n  this.setPixelRatio = function () { };\n\n  this.setSize = function (width, height) {\n    _svgWidth = width;\n    _svgHeight = height;\n    _svgWidthHalf = _svgWidth / 2;\n    _svgHeightHalf = _svgHeight / 2;\n\n    _svg.setAttribute(\"viewBox\", -_svgWidthHalf + \" \" + -_svgHeightHalf + \" \" + _svgWidth + \" \" + _svgHeight);\n    _svg.setAttribute(\"width\", _svgWidth);\n    _svg.setAttribute(\"height\", _svgHeight);\n  };\n\n  this.getSize = function () {\n    return {\n      width: _svgWidth,\n      height: _svgHeight,\n    };\n  };\n\n  this.setGLRenderer = function (glRenderer) {\n    _this._glRenderer = glRenderer;\n  };\n\n  function removeChildNodes() {\n    while (_silhouettes.childNodes.length > 0) {\n      _silhouettes.removeChild(_silhouettes.childNodes[0]);\n    }\n    while (_edges.childNodes.length > 0) {\n      _edges.removeChild(_edges.childNodes[0]);\n    }\n    while (_shading.childNodes.length > 0) {\n      _shading.removeChild(_shading.childNodes[0]);\n    }\n  }\n\n  this.clear = function () {\n    removeChildNodes();\n    _svg.style.backgroundColor = _clearColor.getStyle();\n  };\n\n  /**\n   * Render GPU-based layers (silhouettes and hatches)\n   * @param {Object} scene - Three.js scene\n   * @param {Object} camera - Three.js camera\n   */\n  this.renderGPULayers = function (scene, camera) {\n    if (!_this._glRenderer) {\n      console.warn(\"PlotterRenderer: WebGL renderer not set. Call setGLRenderer() first.\");\n      return;\n    }\n\n    const glRenderer = _this._glRenderer;\n\n    // GPU Silhouettes (region fills based on normal direction)\n    if (_this.showSilhouettes || _this.showHatches) {\n      const regions = extractNormalRegions(glRenderer, scene, camera, {\n        normalBuckets: _this.silhouetteOptions.normalBuckets,\n        simplifyTolerance: _this.silhouetteOptions.simplifyTolerance,\n        minArea: _this.silhouetteOptions.minArea,\n        insetPixels: _this.showHatches ? _this.hatchOptions.insetPixels : 0\n      });\n\n      // Draw silhouette fills\n      if (_this.showSilhouettes) {\n        regions.forEach(region => {\n          if (region.boundary.length < 3) return;\n\n          const path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n          let d = \"\";\n          region.boundary.forEach((pt, i) => {\n            const x = pt.x;\n            const y = -pt.y; // GPU regions use different Y convention\n            d += (i === 0 ? \"M\" : \"L\") + lop(x) + \",\" + lop(y);\n          });\n          d += \"Z\";\n\n          // Color based on normal direction\n          const n = region.normal;\n          const r = Math.floor((n.x * 0.5 + 0.5) * 255);\n          const g = Math.floor((n.y * 0.5 + 0.5) * 255);\n          const b = Math.floor((n.z * 0.5 + 0.5) * 255);\n\n          path.setAttribute(\"d\", d);\n          path.setAttribute(\"fill\", `rgba(${r},${g},${b},0.3)`);\n          path.setAttribute(\"stroke\", \"none\");\n          _silhouettes.appendChild(path);\n        });\n      }\n\n      // GPU Perspective Hatches (render before edges so edges appear on top)\n      if (_this.showHatches) {\n        // Sort by depth (front first) for occlusion\n        regions.sort((a, b) => a.depth - b.depth);\n        const allRegionBounds = regions.map(r => r.boundary);\n\n        // Compute light direction for brightness shading\n        let lightDir = null;\n        const shadingOpts = _this.hatchOptions.brightnessShading || {};\n        if (shadingOpts.enabled) {\n          if (shadingOpts.lightDirection) {\n            lightDir = shadingOpts.lightDirection.clone().normalize();\n          } else {\n            // Auto-detect from scene: find first directional/point/spot light\n            scene.traverse((obj) => {\n              if (lightDir) return; // Already found one\n              if (obj instanceof DirectionalLight) {\n                // Directional light points from position toward target\n                lightDir = new Vector3().subVectors(obj.position, obj.target.position).normalize();\n              } else if (obj instanceof PointLight || obj instanceof SpotLight) {\n                // Use light position as direction from origin\n                lightDir = obj.position.clone().normalize();\n              }\n            });\n            // Fallback: front-top-right\n            if (!lightDir) {\n              lightDir = new Vector3(1, 1, 1).normalize();\n            }\n          }\n        }\n\n        regions.forEach((region, idx) => {\n          // Compute brightness for this region (Lambertian)\n          let brightness = null;\n          if (lightDir && shadingOpts.enabled) {\n            brightness = Math.max(0, region.normal.dot(lightDir));\n          }\n\n          let hatches = generatePerspectiveHatches(region, camera, {\n            baseSpacing: _this.hatchOptions.baseSpacing,\n            minSpacing: _this.hatchOptions.minSpacing,\n            maxSpacing: _this.hatchOptions.maxSpacing,\n            depthFactor: _this.hatchOptions.depthFactor,\n            insetPixels: _this.hatchOptions.insetPixels,\n            screenWidth: _svgWidth,\n            screenHeight: _svgHeight,\n            axisSettings: _this.hatchOptions.axisSettings,\n            brightness: brightness,\n            invertBrightness: shadingOpts.invert || false\n          });\n\n          // Clip against front regions\n          for (let frontIdx = 0; frontIdx < idx; frontIdx++) {\n            hatches = hatches.flatMap(hatch =>\n              clipLineOutsidePolygon(hatch, allRegionBounds[frontIdx])\n            );\n          }\n\n          // Draw hatches\n          hatches.forEach(hatch => {\n            const path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n            const d = `M${lop(hatch.start.x)},${lop(-hatch.start.y)}L${lop(hatch.end.x)},${lop(-hatch.end.y)}`;\n            path.setAttribute(\"d\", d);\n            path.setAttribute(\"fill\", \"none\");\n            path.setAttribute(\"stroke\", _this.hatchOptions.stroke);\n            path.setAttribute(\"stroke-width\", _this.hatchOptions.strokeWidth);\n            _shading.appendChild(path);\n          });\n        });\n      }\n\n      // Hidden Line Edges (render last so they appear on top)\n      if (_this.showEdges) {\n        // Collect all meshes from scene\n        const meshes = [];\n        scene.traverse((obj) => {\n          if (obj.isMesh && obj.geometry) {\n            meshes.push(obj);\n          }\n        });\n\n        if (meshes.length > 0) {\n          const result = computeHiddenLinesMultiple(meshes, camera, scene, {\n            smoothThreshold: _this.hiddenLineOptions.smoothThreshold,\n            width: _svgWidth,\n            height: _svgHeight\n          });\n          const edges = result.edges || [];\n\n          edges.forEach(edge => {\n            const line = document.createElementNS(\"http://www.w3.org/2000/svg\", \"line\");\n            line.setAttribute(\"x1\", lop(edge.a.x));\n            line.setAttribute(\"y1\", lop(edge.a.y));\n            line.setAttribute(\"x2\", lop(edge.b.x));\n            line.setAttribute(\"y2\", lop(edge.b.y));\n            line.setAttribute(\"stroke\", _this.edgeOptions.stroke);\n            line.setAttribute(\"stroke-width\", _this.edgeOptions.strokeWidth);\n            _edges.appendChild(line);\n          });\n        }\n      }\n    }\n  };\n\n  /**\n   * Legacy render method - renders wireframe preview during camera movement\n   * For final output, use clear() + renderGPULayers()\n   * @param {Object} scene - Three.js scene\n   * @param {Object} camera - Three.js camera\n   */\n  this.render = function (scene, camera) {\n    if (camera instanceof Camera === false) {\n      console.error(\"PlotterRenderer.render: camera is not an instance of Camera.\");\n      return;\n    }\n\n    // For now, render is a no-op. Use renderGPULayers() for output.\n    // This maintains API compatibility with Three.js SVGRenderer\n  };\n\n};\n\nexport { SVGObject, PlotterRenderer };\n"],"names":["extractNormalRegions","renderer","scene","camera","options","resolution","normalBuckets","minArea","simplifyTolerance","insetPixels","size","Vector2","width","height","insetAmount","normalPixels","renderNormals","depthPixels","renderDepth","regionMap","normalLookup","quantizeNormals","labels","regionCount","connectedComponents","erodeRegionMap","regions","regionId","boundary","traceBoundary","simplified","rdpSimplify","area","polygonArea","normal","findRegionNormal","depth","sampleRegionDepth","p","target","WebGLRenderTarget","NearestFilter","normalMaterial","MeshNormalMaterial","originalMaterials","hiddenObjects","obj","pixels","depthMaterial","MeshDepthMaterial","RGBADepthPacking","targetLabel","sum","count","y","x","idx","g","b","a","iterations","current","iter","next","i","left","right","up","down","buckets","nextId","normalToId","nx","ny","nz","tolerance","qr","qg","qb","key","Vector3","parent","nextLabel","find","union","px","py","region","neighbors","minLabel","n","labelRemap","finalLabel","root","startX","startY","outer","dx","dy","dir","maxIter","found","checkDir","sumX","sumY","cx","normalId","points","epsilon","maxDist","maxIdx","first","last","dist","perpendicularDistance","point","lineStart","lineEnd","lenSq","t","projX","projY","j","computeHatchDirection","screenWidth","screenHeight","halfW","halfH","worldUp","worldForward","faceAxis","origin","farPoint","originScreen","farScreen","screenOrigin","direction","vpProjected","vanishingPoint","generatePerspectiveHatches","baseSpacing","minSpacing","maxSpacing","depthFactor","axisSettings","brightness","invertBrightness","ax","ay","az","axis","settings","rotationDeg","spacingOverride","finalDirection","rad","cos","sin","perpDir","spacing","brightnessMultiplier","minX","maxX","minY","maxY","pt","centerX","centerY","center","diag","hatches","vpDist","numLines","angleStep","centerAngle","angle","clipped","clipLineToPolygon","offset","lineCenter","line","polygon","intersections","p1","p2","intersection","lineIntersection","result","midX","midY","pointInPolygon","clipLineOutsidePolygon","startInside","endInside","lineIntersectionFull","filtered","midT","x1","y1","x2","y2","x3","y3","x4","y4","denom","u","inside","xi","yi","xj","yj","EPSILON","Point","BoundingBox","BoundingCircle","r","Segment","segA","segB","GeomUtil","seg","SegmentCollection","pts","rot","ptA","segs","ptB","local","bb","bc","Segments","segments","arr","sA","sB","d","aA","aB","deg","oldY","oldX","rA","rB","angle1","angle2","scale","numSegs","perc","deltaX","deltaY","targetPt","sourcePt","delta","numFit","remain","travel","bbs","ab","p3","fn","ignoreTouching","s1_x","s1_y","s2_x","s2_y","s","atX","atY","intPt","ca","boundingBox","polySegs","startPt","aTouching","bTouching","aWithin","bWithin","v1","v2","v3","d1","d2","d3","has_neg","has_pos","out","polySegsA","polySegsB","ptC","divide","spts","Analyzer","splitTeeIntersections","splitCrossIntersections","cxs","originalPts","token","allPts","crossPts","da","db","newSegs","k","ta","tb","res","nekot","str","byNumConnections","oppIdx","endTokens","ang","searchMultiplier","cenTokens","pointGroups","minDx","minDy","ptArray","hDx","hDy","rayPts","rayPt","nearPts","nPt","nPtA","tokenA","ok","nPtB","tokenB","npA","npB","polyPts","cen","cenToken","Optimize","segCols","noSplit","trimSmall","smallDist","optimizePathOrder","allsegs","sc","noSplitColinear","sb","sn","aa","ba","heading","same","isRev","extractEdges","mesh","cameraPosition","geometry","position","index","edgeMap","SNAP","getEdgeKey","va","vb","bx","by","bz","keyA","keyB","getVertex","getFaceNormal","v0","edge1","edge2","numFaces","f","i0","i1","i2","faceMid","viewDir","edges","existing","filterBackfacing","edge","edgeMidpoint","facing1","facing2","classifyEdges","smoothThreshold","profiles","smoothFiltered","projectEdges","halfWidth","halfHeight","projectPoint","p3d","projected","SpatialHash","cellSize","cy","cells","steps","_a","findIntersection","e1","e2","t1","t2","eps","splitAtIntersections","splits","pointOnEdgeInterior","potentialStragglers","_b","tAonJ","_c","tBonJ","_d","tAonI","_e","tBonI","_f","edgeSplits","isStraggler","prevPoint","prevPoint3d","split","point3d","testOcclusionFaceID","meshes","isProfile","e","visibleEdges","renderTarget","RGBAFormat","UnsignedByteType","faceIdMaterial","ShaderMaterial","DoubleSide","faceIdMeshes","globalFaceOffset","geom","newPositions","faceColors","globalFaceId","newGeom","BufferGeometry","BufferAttribute","faceIdMesh","Mesh","tempScene","Scene","faceIdData","sx","sy","sampledFaceId","parentMeshOffset","parentFaceId","parentFaceId2","m","pointInTriangle2D","c","sign","hasNeg","hasPos","edgeLiesAlongFaceEdge","edgeA","edgeB","faceEdgeA","faceEdgeB","projectAndCheck","findAdjacentFaces","projectedFaces","results","face","faceEdges","fe","barycentricDepth","depthA","depthB","depthC","dot00","dot01","dot02","dot11","dot12","v","filterSmoothSplitEdges","coplanarThreshold","distanceThreshold","filteredEdges","removedCount","adjacentFaces","shouldRemove","f1","f2","fn1","fn2","dot","similarity","distDiff","faces","af","allCoplanar","minSimilarity","sim","testOcclusionMath","cameraPos","viewMatrix","testOcclusionMathJS","debugHitCount","debugOccludedCount","mid2d","mid3d","edgeDepth","occluded","testOcclusion","raycaster","Raycaster","toMidpoint","expectedDist","relEps","intersects","hit","optimizeEdges","unique","hashPoint","hashEdge","h1","h2","cleanupOrphanedEdges","maxExtension","vertexKey","vertices","endpoint","orphans","vertex","orphanPoint","otherPoint","len","cross","extensionsCount","processed","orphan","bestMatch","bestIntersection","bestDist","candidate","ix","iy","intersectDist","crosses1","segmentCrossesEdges","crosses2","totalLength","avgEdgeLength","snapThreshold","finalVertices","finalOrphans","snapCount","snapped","nearestOrphan","nearestDist","remainingOrphans","removeIsolatedEdges","vertexConnections","connectionsA","connectionsB","removed","excludeEdge1","excludeEdge2","d1x","d1y","d2x","d2y","computeHiddenLines","gridSize","occlusionEpsilon","skipOcclusion","edges3d","frontEdges","allEdges","edges2d","hash","processedEdges","splitEdges","cellKey","cellEdges","profileEdges","otherEdges","visibleOtherEdges","optimizedEdges","finalEdges","computeHiddenLinesMultiple","internalScale","allEdges3d","visibleHatch","threshold","hatch2d","constant","p0","a2d","b2d","c2d","classifySilhouettes","smoothFilteredEdges","cleanedEdges","optimizedFinal","totalLen","avgLen","perpX","perpY","leftHit","rayHitsAnyFace","rightHit","silCount","ox","oy","rayIntersectsTriangle","rdx","rdy","raySegmentIntersect","sdx","sdy","lop","SVGObject","node","Object3D","PlotterRenderer","_this","_svg","_silhouettes","_edges","_shading","_svgWidth","_svgHeight","_svgWidthHalf","_svgHeightHalf","_clearColor","Color","color","glRenderer","removeChildNodes","path","allRegionBounds","lightDir","shadingOpts","DirectionalLight","PointLight","SpotLight","frontIdx","hatch","Camera"],"mappings":"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"}