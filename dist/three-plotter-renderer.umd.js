(function(X,M){typeof exports=="object"&&typeof module<"u"?M(exports,require("three")):typeof define=="function"&&define.amd?define(["exports","three"],M):(X=typeof globalThis<"u"?globalThis:X||self,M(X.ThreePlotterRenderer={},X.THREE))})(this,function(X,M){"use strict";function dt(i,t,e,n={}){const{resolution:o=2,normalBuckets:s=12,minArea:c=100,simplifyTolerance:a=2,insetPixels:l=0}=n,u=i.getSize(new M.Vector2),r=Math.floor(u.x*o),d=Math.floor(u.y*o),f=Math.round(l*o),h=kt(i,t,e,r,d),x=It(i,t,e,r,d),{regionMap:m,normalLookup:b}=Ot(h,r,d),{labels:p,regionCount:g}=Ft(m,r,d);f>0&&Vt(m,r,d,f);const y=[];for(let w=1;w<=g;w++){const P=Ct(p,r,d,w);if(P.length<3)continue;const S=et(P,a),E=Math.abs(Yt(S));if(E<c)continue;const k=Tt(p,m,b,r,d,w),I=$t(p,x,r,d,w);y.push({boundary:S.map(O=>new M.Vector2(O.x/o-u.x/2,O.y/o-u.y/2)),normal:k,depth:I,area:E/(o*o),regionId:w})}return y}function kt(i,t,e,n,o){const s=new M.WebGLRenderTarget(n,o,{minFilter:M.NearestFilter,magFilter:M.NearestFilter}),c=new M.MeshNormalMaterial({flatShading:!0}),a=new Map,l=[];t.traverse(r=>{r.isMesh?(a.set(r,r.material),r.material=c):(r.isLineSegments||r.isLine||r.isPoints)&&r.visible&&(l.push(r),r.visible=!1)}),i.setRenderTarget(s),i.render(t,e),t.traverse(r=>{r.isMesh&&a.has(r)&&(r.material=a.get(r))});for(const r of l)r.visible=!0;i.setRenderTarget(null);const u=new Uint8Array(n*o*4);return i.readRenderTargetPixels(s,0,0,n,o,u),s.dispose(),c.dispose(),u}function It(i,t,e,n,o){const s=new M.WebGLRenderTarget(n,o,{minFilter:M.NearestFilter,magFilter:M.NearestFilter}),c=new M.MeshDepthMaterial({depthPacking:M.RGBADepthPacking}),a=new Map,l=[];t.traverse(r=>{r.isMesh?(a.set(r,r.material),r.material=c):(r.isLineSegments||r.isLine||r.isPoints)&&r.visible&&(l.push(r),r.visible=!1)}),i.setRenderTarget(s),i.render(t,e),t.traverse(r=>{r.isMesh&&a.has(r)&&(r.material=a.get(r))});for(const r of l)r.visible=!0;i.setRenderTarget(null);const u=new Uint8Array(n*o*4);return i.readRenderTargetPixels(s,0,0,n,o,u),s.dispose(),c.dispose(),u}function $t(i,t,e,n,o){let s=0,c=0;for(let a=0;a<n;a++)for(let l=0;l<e;l++)if(i[a*e+l]===o){const u=(a*e+l)*4,r=t[u]/255,d=t[u+1]/255,f=t[u+2]/255,h=t[u+3]/255,x=r+d/256+f/65536+h/16777216;s+=x,c++}return c>0?s/c:.5}function Vt(i,t,e,n){let o=i;for(let s=0;s<n;s++){const c=new Uint16Array(o);for(let a=1;a<e-1;a++)for(let l=1;l<t-1;l++){const u=a*t+l;if(o[u]===0)continue;const d=o[u-1],f=o[u+1],h=o[u-t],x=o[u+t];(d===0||f===0||h===0||x===0)&&(c[u]=0)}o=c}return o}function Ot(i,t,e,n){const o=new Uint16Array(t*e),s={};let c=1;const a={};for(let l=0;l<t*e;l++){const u=l*4,r=i[u],d=i[u+1],f=i[u+2];if(r<5&&d<5&&f<5){o[l]=0;continue}const h=r/255*2-1,x=d/255*2-1,m=f/255*2-1,b=4,p=Math.round(r/b)*b,g=Math.round(d/b)*b,y=Math.round(f/b)*b,w=`${p}|${g}|${y}`;a[w]||(a[w]=c,s[c]=new M.Vector3(h,x,m).normalize(),c++),o[l]=a[w]}return{regionMap:o,normalLookup:s}}function Ft(i,t,e){const n=new Uint32Array(t*e),o=[];let s=1;function c(r){return o[r]!==r&&(o[r]=c(o[r])),o[r]}function a(r,d){const f=c(r),h=c(d);f!==h&&(o[h]=f)}for(let r=0;r<e;r++)for(let d=0;d<t;d++){const f=r*t+d,h=i[f];if(h===0)continue;const x=[];if(d>0&&i[f-1]===h&&n[f-1]>0&&x.push(n[f-1]),r>0&&i[f-t]===h&&n[f-t]>0&&x.push(n[f-t]),x.length===0)n[f]=s,o[s]=s,s++;else{const m=Math.min(...x);n[f]=m;for(const b of x)a(m,b)}}const l={};let u=0;for(let r=0;r<t*e;r++){if(n[r]===0)continue;const d=c(n[r]);l[d]===void 0&&(u++,l[d]=u),n[r]=l[d]}return{labels:n,regionCount:u}}function Ct(i,t,e,n){const o=[];let s=-1,c=-1;t:for(let x=0;x<e;x++)for(let m=0;m<t;m++)if(i[x*t+m]===n&&(m===0||i[x*t+m-1]!==n||x===0||i[(x-1)*t+m]!==n)){s=m,c=x;break t}if(s===-1)return o;const a=[1,1,0,-1,-1,-1,0,1],l=[0,1,1,1,0,-1,-1,-1];let u=s,r=c,d=7;const f=t*e*2;let h=0;do{o.push({x:u,y:r});let x=!1;for(let m=0;m<8;m++){const b=(d+6+m)%8,p=u+a[b],g=r+l[b];if(p>=0&&p<t&&g>=0&&g<e&&i[g*t+p]===n){u=p,r=g,d=b,x=!0;break}}if(!x)break;h++}while((u!==s||r!==c)&&h<f);return o}function Tt(i,t,e,n,o,s){let c=0,a=0,l=0;for(let h=0;h<o;h++)for(let x=0;x<n;x++)i[h*n+x]===s&&(c+=x,a+=h,l++);if(l===0)return new M.Vector3(0,0,1);const u=Math.round(c/l),d=Math.round(a/l)*n+u,f=t[d];return e[f]||new M.Vector3(0,0,1)}function et(i,t){if(i.length<3)return i;let e=0,n=0;const o=i[0],s=i[i.length-1];for(let c=1;c<i.length-1;c++){const a=Xt(i[c],o,s);a>e&&(e=a,n=c)}if(e>t){const c=et(i.slice(0,n+1),t),a=et(i.slice(n),t);return c.slice(0,-1).concat(a)}else return[o,s]}function Xt(i,t,e){const n=e.x-t.x,o=e.y-t.y,s=n*n+o*o;if(s<1e-10)return Math.sqrt((i.x-t.x)**2+(i.y-t.y)**2);let c=((i.x-t.x)*n+(i.y-t.y)*o)/s;c=Math.max(0,Math.min(1,c));const a=t.x+c*n,l=t.y+c*o;return Math.sqrt((i.x-a)**2+(i.y-l)**2)}function Yt(i){let t=0;for(let e=0;e<i.length;e++){const n=(e+1)%i.length;t+=i[e].x*i[n].y,t-=i[n].x*i[e].y}return t/2}function zt(i,t,e,n){const o=e/2,s=n/2,c=new M.Vector3(0,1,0),a=new M.Vector3(0,0,1);let l;Math.abs(i.y)>.9?l=a.clone():(l=new M.Vector3().crossVectors(c,i).normalize(),l.lengthSq()<.01&&(l=a.clone()));const u=new M.Vector3(0,0,0),r=l.clone().multiplyScalar(100),d=u.clone().project(t),f=r.clone().project(t),h=new M.Vector2(d.x*o,-d.y*s),m=new M.Vector2(f.x*o,-f.y*s).clone().sub(h).normalize(),p=l.clone().multiplyScalar(1e5).clone().project(t);let g=null;return Math.abs(p.x)<100&&Math.abs(p.y)<100&&p.z<1&&(g=new M.Vector2(p.x*o,-p.y*s)),{direction:m,vanishingPoint:g}}function ht(i,t,e={}){const{baseSpacing:n=8,minSpacing:o=3,maxSpacing:s=20,depthFactor:c=.5,screenWidth:a=1200,screenHeight:l=800,axisSettings:u={}}=e,{boundary:r,normal:d,depth:f=.5}=i;if(r.length<3)return[];const h=Math.abs(d.x),x=Math.abs(d.y),m=Math.abs(d.z);let b="y";h>=x&&h>=m?b="x":m>=x&&m>=h&&(b="z");const p=u[b]||{},g=p.rotation||0,y=p.spacing;console.log(`[Hatch] normal=(${d.x.toFixed(2)}, ${d.y.toFixed(2)}, ${d.z.toFixed(2)}) => axis=${b}, rotation=${g}, spacing=${y}`);const{direction:w,vanishingPoint:P}=zt(d,t,a,l);let S=w;if(g!==0){const Y=g*(Math.PI/180),W=Math.cos(Y),R=Math.sin(Y);S=new M.Vector2(w.x*W-w.y*R,w.x*R+w.y*W)}const E=new M.Vector2(-S.y,S.x),I=Math.max(o,Math.min(s,(y!==void 0?y:n)+f*c*(s-o)));let O=1/0,F=-1/0,H=1/0,V=-1/0;for(const Y of r)O=Math.min(O,Y.x),F=Math.max(F,Y.x),H=Math.min(H,Y.y),V=Math.max(V,Y.y);const q=(O+F)/2,C=(H+V)/2,T=new M.Vector2(q,C),D=Math.sqrt((F-O)**2+(V-H)**2),A=[];if(P&&Math.abs(g)<5&&P.distanceTo(T)<D*5){const Y=P.distanceTo(T),W=Math.ceil(D/I)*2,L=Math.atan2(D,Y)*2/W,j=Math.atan2(C-P.y,q-P.x);for(let Z=-W;Z<=W;Z++){const Q=j+Z*L,G=new M.Vector2(Math.cos(Q),Math.sin(Q)),at=P.clone(),lt=P.clone().add(G.clone().multiplyScalar(Y*10)),ut=nt({start:at,end:lt},r);A.push(...ut)}}else{const Y=Math.ceil(D/I)+2;for(let W=-Y;W<=Y;W++){const R=E.clone().multiplyScalar(W*I),L=T.clone().add(R),j=L.clone().add(S.clone().multiplyScalar(-D)),Z=L.clone().add(S.clone().multiplyScalar(D)),Q=nt({start:j,end:Z},r);A.push(...Q)}}return A}function nt(i,t){const e=[],n=t.length;for(let s=0;s<n;s++){const c=t[s],a=t[(s+1)%n],l=At(i.start.x,i.start.y,i.end.x,i.end.y,c.x,c.y,a.x,a.y);l&&e.push({point:new M.Vector2(l.x,l.y),t:l.t})}if(e.length<2)return[];e.sort((s,c)=>s.t-c.t);const o=[];for(let s=0;s<e.length-1;s++){const c=(e[s].point.x+e[s+1].point.x)/2,a=(e[s].point.y+e[s+1].point.y)/2;U(c,a,t)&&o.push({start:e[s].point,end:e[s+1].point})}return o}function gt(i,t){const e=[],n=t.length,o=U(i.start.x,i.start.y,t),s=U(i.end.x,i.end.y,t);e.push({point:i.start.clone(),t:0,inside:o});for(let l=0;l<n;l++){const u=t[l],r=t[(l+1)%n],d=qt(i.start.x,i.start.y,i.end.x,i.end.y,u.x,u.y,r.x,r.y);d&&d.t>0&&d.t<1&&e.push({point:new M.Vector2(d.x,d.y),t:d.t,inside:null})}e.push({point:i.end.clone(),t:1,inside:s}),e.sort((l,u)=>l.t-u.t);const c=[e[0]];for(let l=1;l<e.length;l++)e[l].t-c[c.length-1].t>1e-4&&c.push(e[l]);if(c.length<2)return[i];const a=[];for(let l=0;l<c.length-1;l++){const u=(c[l].t+c[l+1].t)/2,r=i.start.x+u*(i.end.x-i.start.x),d=i.start.y+u*(i.end.y-i.start.y);U(r,d,t)||a.push({start:c[l].point.clone(),end:c[l+1].point.clone()})}return a}function qt(i,t,e,n,o,s,c,a){const l=(i-e)*(s-a)-(t-n)*(o-c);if(Math.abs(l)<1e-10)return null;const u=((i-o)*(s-a)-(t-s)*(o-c))/l,r=-((i-e)*(t-s)-(t-n)*(i-o))/l;return u>=0&&u<=1&&r>=0&&r<=1?{x:i+u*(e-i),y:t+u*(n-t),t:u}:null}function At(i,t,e,n,o,s,c,a){const l=(i-e)*(s-a)-(t-n)*(o-c);if(Math.abs(l)<1e-10)return null;const u=((i-o)*(s-a)-(t-s)*(o-c))/l,r=-((i-e)*(t-s)-(t-n)*(i-o))/l;return r>=0&&r<=1?{x:i+u*(e-i),y:t+u*(n-t),t:u}:null}function U(i,t,e){let n=!1;const o=e.length;for(let s=0,c=o-1;s<o;c=s++){const a=e[s].x,l=e[s].y,u=e[c].x,r=e[c].y;l>t!=r>t&&i<(u-a)*(t-l)/(r-l)+a&&(n=!n)}return n}const xt=.001;class ${constructor(t,e){this.x=t,this.y=e}static clone(t){return new $(t.x,t.y)}}class ot{constructor(t,e,n,o){this.minX=t,this.minY=e,this.maxX=n,this.maxY=o}width(){return Math.abs(this.maxX-this.minX)}height(){return Math.abs(this.maxY-this.minY)}}class Dt{constructor(t=0){this.r=t}}class z{constructor(t,e){this.a=t,this.b=e,this.tags={}}static isEqual(t,e){return v.pointsEqual(t.a,e.a)&&v.pointsEqual(t.b,e.b)||v.pointsEqual(t.b,e.a)&&v.pointsEqual(t.a,e.b)}static clone(t){return new z(new $(t.a.x,t.a.y),new $(t.b.x,t.b.y))}}class Wt{constructor(){this.pivot={x:0,y:0},this.rotation=0,this.isOpen=!0,this.isGroup=!1,this.isStrong=!1,this._makeAbsolute=t=>{let e=this.rotation*Math.PI/180;t.forEach((n,o)=>{const s={x:n.x,y:n.y};v.rotatePoint(s,e),s.x+=this.pivot.x,s.y+=this.pivot.y,t[o]=s})},this._makeSegsAbsolute=t=>{let e=this.rotation*Math.PI/180;t.forEach(n=>{const o={x:n.a.x,y:n.a.y},s={x:n.b.x,y:n.b.y};v.rotatePoint(o,e),v.rotatePoint(s,e),v.addToPoint(o,this.pivot),v.addToPoint(s,this.pivot),n.a=o,n.b=s})}}toPoints(t=!1){throw"not implemented"}toSegments(t=!1){throw"not implemented"}getBoundingBox(t=!1){const e=new ot(1e6,1e6,-1e6,-1e6);return this.toPoints(t).forEach(o=>{e.minX=Math.min(e.minX,o.x),e.minY=Math.min(e.minY,o.y),e.maxX=Math.max(e.maxX,o.x),e.maxY=Math.max(e.maxY,o.y)}),e}getBoundingCircle(){const t=new Dt;return this.toPoints(!0).forEach(n=>{t.r=Math.max(t.r,Math.sqrt(n.x*n.x+n.y*n.y))}),t}}class K extends Wt{constructor(t){super(),this._segments=t}add(...t){this._segments=this._segments.concat(t)}toPoints(t=!1){return this.toSegments(t).reduce((e,n)=>n?e.concat([n.a,n.b]):e,[])}toSegments(t=!1){let e=this._segments.reduce((n,o)=>o?n.concat(z.clone(o)):n,[]);return t||this._makeSegsAbsolute(e),e}bake(){}result(){return K.clone(this)}static clone(t){let e=t._segments,n=[],o=e.length;for(;o--;)n.unshift(z.clone(e[o]));let s=new K(n);return s.pivot.x=t.pivot.x,s.pivot.y=t.pivot.y,s.rotation=t.rotation,s}}class v{static lerp(t,e,n){return(1-n)*t+n*e}static angleBetween(t,e){return Math.atan2(e.y-t.y,e.x-t.x)}static sameAngle(t,e){let n=v.angleBetween(t.a,t.b),o=v.angleBetween(e.a,e.b);return Math.abs(n-o)<xt}static sameAngleRev(t,e){let n=v.angleBetween(t.a,t.b),o=v.angleBetween(e.b,e.a);return Math.abs(n-o)<xt}static lerpPoints(t,e,n){return{x:v.lerp(t.x,e.x,n),y:v.lerp(t.y,e.y,n)}}static rotatePointDeg(t,e){v.rotatePoint(t,e*Math.PI/180)}static rotatePoint(t,e){const n=Math.cos(e),o=Math.sin(e),s=t.y,c=t.x;t.y=n*s-o*c,t.x=o*s+n*c}static rotatePoints(t,...e){e.forEach(n=>{v.rotatePoint(n,t)})}static rotatePointsDeg(t,...e){let n=t*Math.PI/180;e.forEach(o=>{v.rotatePoint(o,n)})}static outerTangents(t,e,n,o){var s=n.x-t.x,c=n.y-t.y,a=Math.sqrt(s*s+c*c);if(a<=Math.abs(o-e))return[];var l=Math.atan2(c,s),u=Math.acos((e-o)/a);return[new z({x:t.x+e*Math.cos(l+u),y:t.y+e*Math.sin(l+u)},{x:n.x+o*Math.cos(l+u),y:n.y+o*Math.sin(l+u)}),new z({x:t.x+e*Math.cos(l-u),y:t.y+e*Math.sin(l-u)},{x:n.x+o*Math.cos(l-u),y:n.y+o*Math.sin(l-u)})]}static cartesian2Polar(t){const e=Math.sqrt(t.x*t.x+t.y*t.y),n=Math.atan2(t.y,t.x);t.x=e,t.y=n}static pointsEqual(t,e,n=1){return Math.round(t.x*1e4/n)==Math.round(e.x*1e4/n)&&Math.round(t.y*1e4/n)==Math.round(e.y*1e4/n)}static distanceBetween(t,e){const n=e.x-t.x,o=e.y-t.y;return Math.sqrt(n*n+o*o)}static distanceBetweenSquared(t,e){const n=e.x-t.x,o=e.y-t.y;return n*n+o*o}static interpolatePoints(t,e,n){let o=[{x:t.x,y:t.y}],s=1/n,c=(e.x-t.x)*s,a=(e.y-t.y)*s;for(var l=1;l<n;l++)o.push(new $(t.x+c*l,t.y+a*l));return o.push({x:e.x,y:e.y}),o}static averagePoints(...t){let e=new $(0,0);return t.forEach(n=>{e.x+=n.x,e.y+=n.y}),e.x/=t.length,e.y/=t.length,e}static addToPoint(t,e){t.x+=e.x,t.y+=e.y}static subFromPoint(t,e){t.x-=e.x,t.y-=e.y}static subdivideByDistance(t,e,n){if(n===0)return[t,e];let o=[{x:t.x,y:t.y}],s=v.distanceBetween(t,e),c=n/s,a=Math.floor(1/c),l=s%n;n+=l/a,c=n/s;let u=c,r=1,d=(e.x-t.x)*c,f=(e.y-t.y)*c;for(;u<1;)o.push(new $(t.x+d*r,t.y+f*r)),u+=c,r++;return o.push({x:e.x,y:e.y}),o}static segmentsConnected(t,e,n=1){return v.pointsEqual(t.b,e.a,n)||v.pointsEqual(t.a,e.b,n)}static segmentsToPoints(t){let e=t.reduce((o,s)=>o.concat(s.a,s.b),[]),n=e.length;for(;n--;){let o=e[n];n>0&&v.pointsEqual(o,e[n-1])&&e.splice(n,1)}return e}static polygonArea(t){let e=0,n=t.length-1;for(var o=0;o<t.length;o++)e+=t[o].x*t[n].y,e-=t[n].x*t[o].y,n=o;return e/2}static pointsBoundingBox(t){const e=new ot(1e6,1e6,-1e6,-1e6);return t.forEach(n=>{e.minX=Math.min(e.minX,n.x),e.minY=Math.min(e.minY,n.y),e.maxX=Math.max(e.maxX,n.x),e.maxY=Math.max(e.maxY,n.y)}),e}static boundingBoxesBoundingBox(t){const e=new ot(1e6,1e6,-1e6,-1e6);return t.forEach(n=>{e.minX=Math.min(e.minX,n.minX),e.minY=Math.min(e.minY,n.minY),e.maxX=Math.max(e.maxX,n.maxX),e.maxY=Math.max(e.maxY,n.maxY)}),e}static segmentsBoundingBox(t){const e=[];return t.forEach(n=>{e.push(n.a),e.push(n.b)}),v.pointsBoundingBox(e)}static boundingBoxesIntersect(t,e){return t.maxX>=e.minX&&t.maxY>=e.minY&&t.minX<=e.maxX&&t.minY<=e.maxY}static polygonIsClockwise(t){return v.polygonArea(t)>0}static ccw(t,e,n){return(n.y-t.y)*(e.x-t.x)>(e.y-t.y)*(n.x-t.x)}static segmentsIntersect(t,e){const n=v.ccw;return n(t.a,e.a,e.b)!=n(t.b,e.a,e.b)&&n(t.a,t.b,e.a)!=n(t.a,t.b,e.b)}static segmentSegmentIntersect(t,e,n=!1){const o=t.a.x,s=t.a.y,c=t.b.x,a=t.b.y,l=e.a.x,u=e.a.y,r=e.b.x,d=e.b.y,f=c-o,h=a-s,x=r-l,m=d-u,b=(-h*(o-l)+f*(s-u))/(-x*h+f*m),p=(x*(s-u)-m*(o-l))/(-x*h+f*m);if(b>=0&&b<=1&&p>=0&&p<=1){const g=o+p*f,y=s+p*h;let w={x:g,y};return n&&(v.pointsEqual(w,e.a)||v.pointsEqual(w,e.b)||v.pointsEqual(w,t.a)||v.pointsEqual(w,t.b))?void 0:w}return null}static segmentSegmentsIntersections(t,e,n=!1){let o=[];return e.forEach(s=>{if(s==t)return;let c=v.segmentSegmentIntersect(t,s,n);c&&o.push(c)}),o}static dot(t,e){return t.x*e.x+t.y*e.y}static cross(t,e){return t.x*e.y-t.y*e.x}static lineSide(t,e,n){return Math.round(((n.x-e.x)*(t.y-e.y)-(n.y-e.y)*(t.x-e.x))*100)/100}static sub(t,e){return new $(t.x-e.x,t.y-e.y)}static add(t,e){return new $(t.x+e.x,t.y+e.y)}static closestPtPointSegment(t,e){var n=v.sub(e.b,e.a),o=v.sub(t,e.a),s=v.dot(o,n);if(s<0)t=e.a;else{var c=v.dot(n,n);s>=c?t=e.b:(s/=c,o.x=e.a.x+s*n.x,o.y=e.a.y+s*n.y,t=o)}return $.clone(t)}static distancePointSegment(t,e){return v.distanceBetween(t,v.closestPtPointSegment(t,e))}static pointWithinBoundingBox(t,e){return t.x>=e.minX&&t.y>=e.minY&&t.x<=e.maxX&&t.y<=e.maxY}static pointWithinPolygon(t,e,n){const o=v.segmentsBoundingBox(e);if(!this.pointWithinBoundingBox(t,o))return!1;let s=new $(1e5,1e5),c=new z(s,t),a=v.segmentSegmentsIntersections(c,e);return a.length%2!=0&&n&&v.pointsEqual(t,a[0])?!1:a.length%2!=0}static segmentWithinPolygon(t,e){let n=this.pointWithinPolygon(t.a,e,!1),o=this.pointWithinPolygon(t.b,e,!1),s=this.pointWithinPolygon(t.a,e,!0),c=this.pointWithinPolygon(t.b,e,!0);return s&&c||s&&o||c&&n}static sign(t,e,n){return(t.x-n.x)*(e.y-n.y)-(e.x-n.x)*(t.y-n.y)}static pointWithinTriangle(t,e,n,o,s){const c=v.sign(t,e,n),a=v.sign(t,n,o),l=v.sign(t,o,e),u=c<0||a<0||l<0,r=c>0||a>0||l>0;if(!(u&&r)&&s){let d={a:e,b:n,tags:null};if(v.distancePointSegment(t,d)<1||(d.a=n,d.b=o,v.distancePointSegment(t,d)<1)||(d.a=o,d.b=e,v.distancePointSegment(t,d)<1))return!1}return!(u&&r)}static segmentWithinTriangle(t,e,n,o){let s=this.pointWithinTriangle(t.a,e,n,o,!1),c=this.pointWithinTriangle(t.b,e,n,o,!1),a=this.pointWithinTriangle(t.a,e,n,o,!0),l=this.pointWithinTriangle(t.b,e,n,o,!0);return v.averagePoints(t.a,t.b),a&&l||a&&c||l&&s||s&&c}static pointsToClosedPolySegments(...t){let e=[];for(let n=0;n<t.length;n++)e.push(new z(t[n],n<t.length-1?t[n+1]:t[0]));return e}static polygonWithinPolygon(t,e){const n=v.segmentsBoundingBox(t),o=v.segmentsBoundingBox(e);if(!v.boundingBoxesIntersect(n,o))return!1;new $(o.minX-100,o.minY-100);for(let s=0;s<t.length;s++){let c=t[s];if(v.segmentSegmentsIntersections(c,e).length%2==0)return!1}return!0}static splinePoints(t,e,n,o=0){let s=a=>{let l=[a[0]];for(let u=0;u<a.length-1;u++){let r=new $(0,0);u+1<a.length*.4?(r.x=(a[u].x*40+a[u+1].x*60)*.01,r.y=(a[u].y*40+a[u+1].y*60)*.01):u+1>a.length*.6?(r.x=(a[u].x*60+a[u+1].x*40)*.01,r.y=(a[u].y*60+a[u+1].y*40)*.01):(r.x=(a[u].x+a[u+1].x)*.5,r.y=(a[u].y+a[u+1].y)*.5),l.push(r)}return l.push(a[a.length-1]),l},c=[t,e,n];for(let a=0;a<o;a++)c=s(c);return c}}class J{static getSegsAndConnections(t,e=!1,n=!1){let o={},s=[],c={},a=l=>{let u=`${Math.round(l.x*1)}|${Math.round(l.y*1)}`;return c[u]=l,u};if(e){let l=t.reduce((d,f)=>d.concat(f.a,f.b),[]),u=l.length;for(;u--;){let d=l[u],f=u;for(;f--;){let h=l[f];if(v.pointsEqual(d,h)){l.splice(u,1);break}}}let r=t.length;for(;r--;){let d=t[r],f=[];if(l.forEach(h=>{v.distancePointSegment(h,d)<.1&&!v.pointsEqual(h,d.a)&&!v.pointsEqual(h,d.b)&&f.push(h)}),f.length){f.sort((m,b)=>{const p=v.distanceBetweenSquared(m,d.a),g=v.distanceBetweenSquared(b,d.a);return p<g?-1:p>g?1:0});const h=[];let x=d.a;for(let m=0;m<f.length;m++){let b=f[m];h.push(new z(x,b)),x=b}h.push(new z(x,d.b)),t.splice(r,1,...h)}}}if(n){let l=t.length;for(;l--;){let u=l,r=!1;for(;u--;){let d=t[l],f=t[u],h=v.segmentSegmentIntersect(d,f,!0);h&&(r=!0,t.splice(l,1,new z($.clone(d.a),$.clone(h)),new z($.clone(h),$.clone(d.b))),t.splice(u,1,new z($.clone(f.a),$.clone(h)),new z($.clone(h),$.clone(f.b))))}r&&(l=t.length)}}return t.forEach(l=>{let u=a(l.a),r=a(l.b);o[u]||(o[u]=[]),o[r]||(o[r]=[]),o[u].indexOf(r)===-1&&o[u].push(r),o[r].indexOf(u)===-1&&o[r].push(u),s.indexOf(u)===-1&&s.push(u),s.indexOf(r)===-1&&s.push(r)}),{originalPts:c,pts:s,cxs:o}}static pathOrder(t,e=!1,n=!1){let o=[],{originalPts:s,pts:c,cxs:a}=J.getSegsAndConnections(t,e,n),l=r=>s[r],u=(r,d)=>a[r].length>a[d].length?1:a[r].length<a[d].length?-1:0;for(c.sort(u);c.length;){c.sort(u);let r=c.shift();for(;r;)if(a[r].length){a[r].sort(u);let d=a[r].shift(),f=a[d].indexOf(r);f!==-1&&a[d].splice(f,1),o.push(new z(l(r),l(d))),a[r].length&&c.unshift(r),r=d}else r=null}return o}static getEndingSegmentPoints(t,e=0){t=t.concat(),t=J.pathOrder(t,!0,!0);let{originalPts:n,pts:o,cxs:s}=J.getSegsAndConnections(t,!0),c=u=>n[u];const a=o.filter(u=>s[u].length===1),l=[];return a.forEach(u=>{const r=$.clone(c(u));if(e===0){l.push(r);return}const d=c(s[u]),f=v.angleBetween(d,r),h=new $(0,e);v.rotatePoint(h,Math.PI*.5-f),v.addToPoint(r,h),l.push(r)}),l}static getFills(t,e=5){t=t.concat();let{originalPts:n,cxs:o}=J.getSegsAndConnections(t,!0,!0),s=g=>{let y=`${Math.round(g.x*1)}|${Math.round(g.y*1)}`;return n[y]=g,y},c=[],a=[],l=1e5,u=1e5,r=-1e5,d=-1e5,f=1e5,h=1e5,x=[];for(let g in n){let y=n[g];x.push(y),l=Math.min(l,y.x),u=Math.min(u,y.y),r=Math.max(r,y.x),d=Math.max(d,y.y)}x.sort((g,y)=>g.x<y.x?-1:g.x>y.x?1:0),x.forEach((g,y)=>{if(y>0){let w=x[y-1],P=Math.round(Math.abs(g.x-w.x));P>1&&(f=Math.min(f,P))}}),x.sort((g,y)=>g.y<y.y?-1:g.y>y.y?1:0),x.forEach((g,y)=>{if(y>0){let w=x[y-1],P=Math.round(Math.abs(g.y-w.y));P>1&&(h=Math.min(h,P))}});let m=f*.5,b=h*.5,p=[];for(let g=u;g<d;g+=h)for(let y=l;y<r;y+=f)p.push(new $(y+m,g+b));return p.forEach(g=>{let y=[];if(x.forEach(S=>{let E=v.distanceBetween(S,g);if(E<Math.max(f,h)*e){let k=v.angleBetween(S,g);y.push({pt:S,dist:E,ang:k})}}),y.length<4)return;let w=y.length;for(;w--;){let S=y[w].pt,E=new z(g,S);v.segmentSegmentsIntersections(E,t,!0).length>0&&y.splice(w,1)}for(y.sort((S,E)=>S.ang<E.ang?-1:S.ang>E.ang?1:0),w=y.length;w--;){let S=y[w].pt,E=s(S),k=y.length,I=!1;for(;k--;){if(w===k)continue;let O=y[k].pt,F=s(O);if(o[E].indexOf(F)===-1){I=!0;break}}I||y.splice(w,1)}let P=!0;if(y.forEach((S,E)=>{let k=y[(E+1)%y.length],I=s(S.pt),O=s(k.pt);o[I].indexOf(O)===-1&&(P=!1)}),P){let S=y.map(I=>I.pt),E=v.averagePoints(...S),k=s(E);c.indexOf(k)===-1&&(c.push(k),a.push(S))}}),a}}class _{static segmentCollections(t,e=!1,n=!0,o=1,s=!1,c=!1,a=!1){let l=t.reduce((u,r)=>u.concat(r.toSegments()),[]);return _.segments(l,e,n,o,s,c,a)}static segmentCollectionsPathOrder(t,e=!1,n=!1){let o=t.reduce((s,c)=>s.concat(c.toSegments()),[]);return new K(J.pathOrder(o,e,n))}static segments(t,e=!1,n=!0,o=1,s=!1,c=!1,a=!1){return t=_._segments(t,e,n,o),s&&(t=J.pathOrder(t,c,a)),new K(t)}static _segments(t,e,n,o){const s=t;for(t=[];s.length;){let a=s.shift(),l=t.length,u=!1;for(;l--;){const r=t[l];if(z.isEqual(a,r)){u=!0;break}}u||t.push(a)}if(!e)for(let a=0;a<3;a++){let l=t.length;for(;l--;){let u=t[l],r,d,f,h,x;for(let m=l-1;m>=0;m--){let b=t[m],p=!1,g=!1;if(v.sameAngle(u,b)?(p=!0,r=$.clone(u.a),d=$.clone(u.b),f=$.clone(b.a),h=$.clone(b.b)):v.sameAngleRev(u,b)&&(p=g=!0,r=$.clone(u.b),d=$.clone(u.a),f=$.clone(b.a),h=$.clone(b.b)),p&&(x=v.angleBetween(r,d),v.rotatePoints(x,r,d,f,h),Math.abs(r.y-f.y)<.1&&d.x>=f.x-1e-4&&r.x<=h.x+1e-4)){r.x<f.x&&(g?b.a=u.b:b.a=u.a),d.x>h.x&&(g?b.b=u.a:b.b=u.b),t.splice(l,1);break}}}}let c=t.length;for(;c--;){let a=t[c];if(!a){t.splice(c,1);continue}if(n&&v.distanceBetween(a.a,a.b)<o){t.splice(c,1);continue}}return console.log(`[JS] Optimize: ${s.length+t.length} -> ${t.length} segments`),t}}function yt(i,t){const e=i.geometry,n=e.attributes.position,o=e.index;if(!n)return[];const s=new Map,c=1e3,a=(d,f)=>{const h=Math.round(d.x*c),x=Math.round(d.y*c),m=Math.round(d.z*c),b=Math.round(f.x*c),p=Math.round(f.y*c),g=Math.round(f.z*c),y=`${h},${x},${m}`,w=`${b},${p},${g}`;return y<w?`${y}|${w}`:`${w}|${y}`},l=d=>new M.Vector3(n.getX(d),n.getY(d),n.getZ(d)).applyMatrix4(i.matrixWorld),u=(d,f,h)=>{const x=new M.Vector3().subVectors(f,d),m=new M.Vector3().subVectors(h,d);return new M.Vector3().crossVectors(x,m).normalize()},r=o?o.count/3:n.count/3;for(let d=0;d<r;d++){let f,h,x;o?(f=o.getX(d*3),h=o.getX(d*3+1),x=o.getX(d*3+2)):(f=d*3,h=d*3+1,x=d*3+2);const m=l(f),b=l(h),p=l(x),g=u(m,b,p),y=new M.Vector3().addVectors(m,b).add(p).divideScalar(3),w=new M.Vector3().subVectors(t,y);if(g.dot(w)<=0)continue;const P=[[m,b],[b,p],[p,m]];for(const[S,E]of P){const k=a(S,E);if(s.has(k)){const I=s.get(k);I&&!I.normal2&&(I.normal2=g.clone(),I.faceIdx2=d)}else s.set(k,{a:S.clone(),b:E.clone(),normal1:g.clone(),faceIdx1:d,mesh:i})}}return Array.from(s.values())}function pt(i,t){return i.filter(e=>{const n=new M.Vector3().addVectors(e.a,e.b).multiplyScalar(.5),o=new M.Vector3().subVectors(t,n).normalize(),s=e.normal1.dot(o)>0;if(!e.normal2)return!0;const c=e.normal2.dot(o)>0;return s||c})}function mt(i,t,e=.99){const n=[],o=[];for(const s of i){const c=new M.Vector3().addVectors(s.a,s.b).multiplyScalar(.5),a=new M.Vector3().subVectors(t,c).normalize(),l=s.normal1.dot(a)>0,u=s.normal2?s.normal2.dot(a)>0:!0;if(l!==u||!s.normal2){n.push(s);continue}s.normal2&&s.normal1.dot(s.normal2)<e&&o.push(s)}return console.log(`classifyEdges: ${n.length} profiles, ${o.length} smooth/crease edges`),{profiles:n,smoothFiltered:o}}function st(i,t,e,n,o=1){const s=e/2,c=n/2,a=l=>{const u=l.clone().project(t);return new M.Vector2(u.x*s*o,-u.y*c*o)};return i.map(l=>({a:a(l.a),b:a(l.b),a3d:l.a.clone(),b3d:l.b.clone(),midpoint3d:new M.Vector3().addVectors(l.a,l.b).multiplyScalar(.5),isProfile:!1,visible:!0,faceIdx:l.faceIdx1,faceIdx2:l.faceIdx2,mesh:l.mesh,isHatch:l.isHatch,normal1:l.normal1,normal2:l.normal2}))}class Ht{constructor(t){this.cellSize=t,this.cells=new Map}getCellKey(t,e){const n=Math.floor(t/this.cellSize),o=Math.floor(e/this.cellSize);return`${n},${o}`}getCellsCrossed(t){const e=new Set,n=Math.abs(t.b.x-t.a.x),o=Math.abs(t.b.y-t.a.y),s=Math.max(n,o)/this.cellSize+1;for(let c=0;c<=s;c++){const a=c/s,l=t.a.x+a*(t.b.x-t.a.x),u=t.a.y+a*(t.b.y-t.a.y);e.add(this.getCellKey(l,u))}return Array.from(e)}insert(t){var n;const e=this.getCellsCrossed(t);for(const o of e)this.cells.has(o)||this.cells.set(o,[]),(n=this.cells.get(o))==null||n.push(t)}query(t){return this.cells.get(t)||[]}getAllCells(){return Array.from(this.cells.keys())}clear(){this.cells.clear()}}function Rt(i,t){const e=i.a.x,n=i.a.y,o=i.b.x,s=i.b.y,c=t.a.x,a=t.a.y,l=t.b.x,u=t.b.y,r=(e-o)*(a-u)-(n-s)*(c-l);if(Math.abs(r)<1e-10)return null;const d=((e-c)*(a-u)-(n-a)*(c-l))/r,f=-((e-o)*(n-a)-(n-s)*(e-c))/r,h=.001;return d>h&&d<1-h&&f>h&&f<1-h?{t1:d,t2:f,point:new M.Vector2(e+d*(o-e),n+d*(s-n))}:null}function bt(i){var c,a,l,u,r,d;const t=new Map,e=.01,n=(f,h)=>{const x=h.b.x-h.a.x,m=h.b.y-h.a.y,b=x*x+m*m;if(b<1e-10)return null;const p=((f.x-h.a.x)*x+(f.y-h.a.y)*m)/b;if(p<=e||p>=1-e)return null;const g=h.a.x+p*x,y=h.a.y+p*m;return(f.x-g)*(f.x-g)+(f.y-y)*(f.y-y)<1?p:null},o=new Set;for(let f=0;f<i.length;f++)for(let h=f+1;h<i.length;h++){const x=Rt(i[f],i[h]);if(x)t.has(i[f])||t.set(i[f],[]),t.has(i[h])||t.set(i[h],[]),(c=t.get(i[f]))==null||c.push({t:x.t1,point:x.point}),(a=t.get(i[h]))==null||a.push({t:x.t2,point:x.point});else{const m=n(i[f].a,i[h]);m!==null&&(t.has(i[h])||t.set(i[h],[]),(l=t.get(i[h]))==null||l.push({t:m,point:i[f].a.clone()}),o.add(i[f]),o.add(i[h]));const b=n(i[f].b,i[h]);b!==null&&(t.has(i[h])||t.set(i[h],[]),(u=t.get(i[h]))==null||u.push({t:b,point:i[f].b.clone()}),o.add(i[f]),o.add(i[h]));const p=n(i[h].a,i[f]);p!==null&&(t.has(i[f])||t.set(i[f],[]),(r=t.get(i[f]))==null||r.push({t:p,point:i[h].a.clone()}),o.add(i[f]),o.add(i[h]));const g=n(i[h].b,i[f]);g!==null&&(t.has(i[f])||t.set(i[f],[]),(d=t.get(i[f]))==null||d.push({t:g,point:i[h].b.clone()}),o.add(i[f]),o.add(i[h]))}}console.log(`T-junction detection: ${o.size} potential straggler edges`);const s=[];for(const f of i){const h=t.get(f),x=o.has(f);if(!h||h.length===0){f.isTJunctionStraggler=x,s.push(f);continue}h.sort((p,g)=>p.t-g.t);let m=f.a,b=f.a3d;for(const p of h){const g=new M.Vector3().lerpVectors(f.a3d,f.b3d,p.t);s.push({a:m.clone(),b:p.point.clone(),a3d:b.clone(),b3d:g.clone(),midpoint3d:new M.Vector3().addVectors(b,g).multiplyScalar(.5),isProfile:f.isProfile,visible:f.visible,faceIdx:f.faceIdx,mesh:f.mesh,isHatch:f.isHatch,normal1:f.normal1,isTJunctionStraggler:x}),p.t,m=p.point,b=g}s.push({a:m.clone(),b:f.b.clone(),a3d:b.clone(),b3d:f.b3d.clone(),midpoint3d:new M.Vector3().addVectors(b,f.b3d).multiplyScalar(.5),isProfile:f.isProfile,visible:f.visible,faceIdx:f.faceIdx,mesh:f.mesh,isHatch:f.isHatch,normal1:f.normal1,isTJunctionStraggler:x})}return s}function Bt(i,t,e,n,o,s,c=!1){if(c)return i.forEach(x=>x.visible=!0),i;const a=[];if(!s)return console.warn("No renderer provided, skipping occlusion test"),i;const l=new M.WebGLRenderTarget(n,o,{minFilter:M.NearestFilter,magFilter:M.NearestFilter,format:M.RGBAFormat,type:M.UnsignedByteType}),u=new M.ShaderMaterial({vertexShader:`
            attribute vec3 faceColor;
            varying vec3 vFaceColor;
            void main() {
                vFaceColor = faceColor;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `,fragmentShader:`
            varying vec3 vFaceColor;
            void main() {
                gl_FragColor = vec4(vFaceColor, 1.0);
            }
        `,side:M.DoubleSide}),r=[];let d=0;for(const x of t){x.__globalFaceOffset=d;const m=x.geometry,b=m.attributes.position,p=m.index,g=p?p.count/3:b.count/3,y=[],w=[];for(let E=0;E<g;E++){let k,I,O;p?(k=p.getX(E*3),I=p.getX(E*3+1),O=p.getX(E*3+2)):(k=E*3,I=E*3+1,O=E*3+2);const F=new M.Vector3(b.getX(k),b.getY(k),b.getZ(k)),H=new M.Vector3(b.getX(I),b.getY(I),b.getZ(I)),V=new M.Vector3(b.getX(O),b.getY(O),b.getZ(O));F.applyMatrix4(x.matrixWorld),H.applyMatrix4(x.matrixWorld),V.applyMatrix4(x.matrixWorld),y.push(F.x,F.y,F.z,H.x,H.y,H.z,V.x,V.y,V.z);const q=d+E+1,C=(q&255)/255,T=(q>>8&255)/255,D=(q>>16&255)/255;w.push(C,T,D,C,T,D,C,T,D)}const P=new M.BufferGeometry;P.setAttribute("position",new M.BufferAttribute(new Float32Array(y),3)),P.setAttribute("faceColor",new M.BufferAttribute(new Float32Array(w),3));const S=new M.Mesh(P,u);r.push(S),d+=g}const f=new M.Scene;for(const x of r)f.add(x);s.setRenderTarget(l),s.setClearColor(0,1),s.clear(),s.render(f,e);const h=new Uint8Array(n*o*4);s.readRenderTargetPixels(l,0,0,n,o,h),s.setRenderTarget(null);for(const x of i){const m=(x.a.x+x.b.x)/2,b=(x.a.y+x.b.y)/2,p=Math.round(m+n/2),g=Math.round(o/2+b);if(p<0||p>=n||g<0||g>=o){x.visible=!0,a.push(x);continue}const y=((o-1-g)*n+p)*4,w=h[y],P=h[y+1],S=h[y+2],E=w+(P<<8)+(S<<16);if(E===0){x.visible=!0,a.push(x);continue}const k=x.mesh.__globalFaceOffset||0,I=k+x.faceIdx+1;if(E===I)x.visible=!0,a.push(x);else{if(x.faceIdx2!==void 0){const O=k+x.faceIdx2+1;if(E===O){x.visible=!0,a.push(x);continue}}x.visible=!1}}l.dispose(),u.dispose();for(const x of r)x.geometry.dispose();return a}function Lt(i,t,e,n){const o=(r,d,f)=>(r.x-f.x)*(d.y-f.y)-(d.x-f.x)*(r.y-f.y),s=o(i,t,e),c=o(i,e,n),a=o(i,n,t),l=s<0||c<0||a<0,u=s>0||c>0||a>0;return!(l&&u)}function Nt(i,t,e,n,o=2){const s=n.x-e.x,c=n.y-e.y,a=s*s+c*c;if(a<1e-10)return!1;const l=u=>{const r=((u.x-e.x)*s+(u.y-e.y)*c)/a,d=e.x+r*s,f=e.y+r*c;return(u.x-d)*(u.x-d)+(u.y-f)*(u.y-f)<o*o&&r>=-.01&&r<=1.01};return l(i)&&l(t)}function jt(i,t){const e=[];for(const n of t){const o=[{a:n.a2d,b:n.b2d,name:"AB"},{a:n.b2d,b:n.c2d,name:"BC"},{a:n.c2d,b:n.a2d,name:"CA"}];for(const s of o)if(Nt(i.a,i.b,s.a,s.b)){e.push({face:n,matchedEdge:s.name,matchType:"collinear"});break}}return e}function Jt(i,t,e,n,o,s,c){const a={x:n.x-t.x,y:n.y-t.y},l={x:e.x-t.x,y:e.y-t.y},u={x:i.x-t.x,y:i.y-t.y},r=a.x*a.x+a.y*a.y,d=a.x*l.x+a.y*l.y,f=a.x*u.x+a.y*u.y,h=l.x*l.x+l.y*l.y,x=l.x*u.x+l.y*u.y,m=r*h-d*d;if(Math.abs(m)<1e-10)return 1/0;const b=(h*f-d*x)/m,p=(r*x-d*f)/m;return(1-b-p)*o+p*s+b*c}function Zt(i,t,e=.99,n=.5){const o=[];let s=0;for(const c of i){const a=jt(c,t);c.adjacentFaceCount=a.length;let l=!1;if(a.length===2){const u=a[0].face,r=a[1].face,d=u.normal,f=r.normal;if(d&&f){const h=d.dot(f),x=Math.abs(h);c.faceSimilarity=x;let m;h>0?m=Math.abs(u.constant-r.constant):m=Math.abs(u.constant+r.constant),x>=e&&m<n&&(l=!0,s++)}}else if(a.length>2){const u=a.map(r=>r.face).filter(r=>r.normal);if(u.length>=2){let r=!0,d=1;for(let f=1;f<u.length;f++){const h=u[0].normal.dot(u[f].normal),x=Math.abs(h);let m;if(h>0?m=Math.abs(u[0].constant-u[f].constant):m=Math.abs(u[0].constant+u[f].constant),d=Math.min(d,x),x<e||m>=n){r=!1;break}}c.faceSimilarity=d,r&&(l=!0,s++)}}l||o.push(c)}return console.log(`Geometric straggler filter: removed ${s} coplanar edges`),o}function Kt(i,t,e){const n=e.position,o=e.matrixWorldInverse;return Qt(i,t,n,o)}function Qt(i,t,e,n){const o=[];let s=0,c=0;for(const a of i){const l=new M.Vector2((a.a.x+a.b.x)/2,(a.a.y+a.b.y)/2),u=a.midpoint3d;let r;n?r=-u.clone().applyMatrix4(n).z:r=e.distanceTo(u);let d=!1;for(const f of t){if(f.mesh===a.mesh&&(f.faceIdx===a.faceIdx||f.faceIdx===a.faceIdx2)||!Lt(l,f.a2d,f.b2d,f.c2d))continue;if(Jt(l,f.a2d,f.b2d,f.c2d,f.depthA,f.depthB,f.depthC)<r-.001){d=!0,c++;break}s++}d?a.visible=!1:(a.visible=!0,o.push(a))}return console.log(`[JS] Occlusion debug: ${s} point-in-triangle hits, ${c} occluded`),o}function _t(i,t,e,n=.05){const o=new M.Raycaster,s=[],c=[];t.traverse(a=>{a.isMesh&&c.push(a)});for(const a of i){const l=new M.Vector3().subVectors(a.midpoint3d,e.position),u=l.clone().normalize(),r=l.length(),d=r*n;o.set(e.position.clone(),u);const f=o.intersectObjects(c,!0);if(f.length===0)a.visible=!0,s.push(a);else{let h=!1;for(const x of f)if(!(x.distance>=r-d)&&!(x.object===a.mesh&&x.faceIndex===a.faceIdx)){h=!0;break}h?a.visible=!1:(a.visible=!0,s.push(a))}}return s}function it(i,t=.5){const e=new Map,n=s=>`${Math.round(s.x/t)},${Math.round(s.y/t)}`,o=s=>{const c=n(s.a),a=n(s.b);return c<a?`${c}-${a}`:`${a}-${c}`};for(const s of i){const c=o(s);e.has(c)||e.set(c,s)}return Array.from(e.values())}function ct(i,t=1,e=50){const n=p=>`${Math.round(p.x/t)},${Math.round(p.y/t)}`,o=new Map;for(const p of i)for(const g of["a","b"]){const y=g==="a"?p.a:p.b,w=n(y);o.has(w)||o.set(w,{edges:[],point:{x:y.x,y:y.y}}),o.get(w).edges.push({edge:p,endpoint:g})}const s=[];for(const[p,g]of o)if(g.edges.length===1){const{edge:y,endpoint:w}=g.edges[0],P=g.point,S=w==="a"?y.b:y.a,E=P.x-S.x,k=P.y-S.y,I=Math.sqrt(E*E+k*k);if(I<.001)continue;s.push({key:p,edge:y,endpoint:w,point:P,otherPoint:S,dirX:E/I,dirY:k/I,len:I})}if(console.log(`Edge cleanup: found ${s.length} orphaned endpoints`),s.length===0)return i;const c=(p,g,y,w)=>{const P=g.x*w.y-g.y*w.x;if(Math.abs(P)<1e-4)return null;const S=y.x-p.x,E=y.y-p.y,k=(S*w.y-E*w.x)/P,I=(S*g.y-E*g.x)/P;return{t1:k,t2:I}};let a=0;const l=new Set;for(let p=0;p<s.length;p++){const g=s[p];if(l.has(g.key))continue;let y=null,w=null,P=1/0;for(let S=0;S<s.length;S++){if(p===S)continue;const E=s[S];if(l.has(E.key)||Math.sqrt((E.point.x-g.point.x)**2+(E.point.y-g.point.y)**2)>e*2)continue;const I=c({x:g.point.x,y:g.point.y},{x:g.dirX,y:g.dirY},{x:E.point.x,y:E.point.y},{x:E.dirX,y:E.dirY});if(!I||I.t1<-.1||I.t2<-.1||I.t1>e||I.t2>e)continue;const O=g.point.x+I.t1*g.dirX,F=g.point.y+I.t1*g.dirY,H=I.t1+I.t2;H<P&&(P=H,y=E,w={x:O,y:F})}if(y&&w){const S=wt(g.point,w,i,g.edge,y.edge),E=wt(y.point,w,i,g.edge,y.edge);if(S||E)continue;g.endpoint==="a"?(g.edge.a.x=w.x,g.edge.a.y=w.y):(g.edge.b.x=w.x,g.edge.b.y=w.y),y.endpoint==="a"?(y.edge.a.x=w.x,y.edge.a.y=w.y):(y.edge.b.x=w.x,y.edge.b.y=w.y),l.add(g.key),l.add(y.key),a++}}console.log(`Edge cleanup: extended ${a} pairs of edges to intersections`);let u=0;for(const p of i){const g=p.b.x-p.a.x,y=p.b.y-p.a.y;u+=Math.sqrt(g*g+y*y)}const r=u/i.length,d=r/8;console.log(`Edge cleanup: average edge length = ${r.toFixed(2)}, snap threshold = ${d.toFixed(2)}`);const f=new Map;for(const p of i)for(const g of["a","b"]){const y=g==="a"?p.a:p.b,w=n(y);f.has(w)||f.set(w,{edges:[],point:y}),f.get(w).edges.push({edge:p,endpoint:g})}const h=[];for(const[p,g]of f)g.edges.length===1&&h.push({key:p,...g.edges[0],point:g.point});console.log(`Edge cleanup: ${h.length} orphaned endpoints before snap pass`);let x=0;const m=new Set;for(let p=0;p<h.length;p++){const g=h[p];if(m.has(g.key))continue;let y=null,w=1/0;for(let P=0;P<h.length;P++){if(p===P)continue;const S=h[P];if(m.has(S.key))continue;const E=Math.sqrt((S.point.x-g.point.x)**2+(S.point.y-g.point.y)**2);E<w&&(w=E,y=S)}if(y&&w<d){const P=(g.point.x+y.point.x)/2,S=(g.point.y+y.point.y)/2;g.endpoint==="a"?(g.edge.a.x=P,g.edge.a.y=S):(g.edge.b.x=P,g.edge.b.y=S),y.endpoint==="a"?(y.edge.a.x=P,y.edge.a.y=S):(y.edge.b.x=P,y.edge.b.y=S),m.add(g.key),m.add(y.key),x++}}console.log(`Edge cleanup: snapped ${x} pairs of nearby orphans`);const b=h.length-x*2;return console.log(`Edge cleanup: ${b} orphaned endpoints remaining`),i}function Gt(i,t=1){const e=c=>`${Math.round(c.x/t)},${Math.round(c.y/t)}`,n=new Map;for(const c of i){const a=e(c.a),l=e(c.b);n.set(a,(n.get(a)||0)+1),n.set(l,(n.get(l)||0)+1)}const o=i.filter(c=>{const a=e(c.a),l=e(c.b),u=n.get(a)||0,r=n.get(l)||0;return u>=2||r>=2}),s=i.length-o.length;return s>0&&console.log(`Edge cleanup: removed ${s} isolated edges (orphaned at both ends)`),o}function wt(i,t,e,n,o){for(const c of e){if(c===n||c===o)continue;const a=t.x-i.x,l=t.y-i.y,u=c.b.x-c.a.x,r=c.b.y-c.a.y,d=a*r-l*u;if(Math.abs(d)<.001)continue;const f=c.a.x-i.x,h=c.a.y-i.y,x=(f*r-h*u)/d,m=(f*l-h*a)/d;if(x>.001&&x<1-.001&&m>.001&&m<1-.001)return!0}return!1}function Ut(i,t,e,n={}){const{smoothThreshold:o=.99,gridSize:s=32,occlusionEpsilon:c=.01,skipOcclusion:a=!1,width:l=800,height:u=600,renderer:r=null}=n;console.time("extractEdges");const d=yt(i,t.position);console.timeEnd("extractEdges"),console.log(`Extracted ${d.length} edges`),console.time("filterBackfacing");const f=pt(d,t.position);console.timeEnd("filterBackfacing"),console.log(`After backface filter: ${f.length} edges`),console.time("classifyEdges");const{profiles:h,smoothFiltered:x}=mt(f,t.position,o);console.timeEnd("classifyEdges"),console.log(`Profiles: ${h.length}, Smooth edges: ${x.length}`);const m=[...h,...x];console.time("projectEdges");let b=st(m,t,l,u);console.timeEnd("projectEdges");for(let k=0;k<h.length;k++)b[k].isProfile=!0;console.time("spatialHash");const p=Math.max(l,u)/s,g=new Ht(p);for(const k of b)g.insert(k);console.timeEnd("spatialHash"),console.time("splitIntersections");const y=new Set;let w=[];for(const k of g.getAllCells()){const I=g.query(k).filter(F=>!y.has(F)),O=bt(I);w.push(...O);for(const F of I)y.add(F)}console.timeEnd("splitIntersections"),console.log(`After splitting: ${w.length} edges`);let P;if(a)console.log("Skipping occlusion test (debug mode)"),P=w;else if(r){console.time("testOcclusion (face ID buffer)");const k=w.filter(F=>F.isProfile),I=w.filter(F=>!F.isProfile);k.forEach(F=>F.visible=!0);const O=Bt(I,[i],t,l,u,r,!1);P=[...k,...O],console.timeEnd("testOcclusion (face ID buffer)")}else console.time("testOcclusion (raycaster - slow)"),P=_t(w,e,t,c),console.timeEnd("testOcclusion (raycaster - slow)");console.log(`Visible edges: ${P.length}`),console.time("optimize");const S=it(P);console.timeEnd("optimize"),console.time("cleanup orphans");const E=ct(S);return console.timeEnd("cleanup orphans"),console.log(`Final edges: ${E.length}`),{edges:E,profiles:E.filter(k=>k.isProfile)}}function Mt(i,t,e,n={}){const{smoothThreshold:o=.99,gridSize:s=32,skipOcclusion:c=!1,width:a=800,height:l=600,renderer:u=null,internalScale:r=4,distanceThreshold:d=.5}=n;let f=[];for(const V of i){V.updateMatrixWorld(!0);const q=yt(V,t.position);f.push(...q)}console.log(`Extracted ${f.length} edges from ${i.length} meshes`);const{profiles:h,smoothFiltered:x}=mt(f,t.position,o);console.log(`Profiles: ${h.length}, Crease edges: ${x.length}`);const m=[...h,...x];console.log(`After smooth filter: ${m.length} edges`);let b=st(m,t,a,l,r);if(n.hatchEdges&&n.hatchEdges.length>0){console.log(`Processing ${n.hatchEdges.length} hatch edges...`);let V=pt(n.hatchEdges,t.position);if(n.minHatchDotProduct!==void 0){const C=n.minHatchDotProduct;V=V.filter(T=>{const D=new M.Vector3().addVectors(T.a,T.b).multiplyScalar(.5),A=new M.Vector3().subVectors(t.position,D).normalize(),N=T.normal1.dot(A);return Math.abs(N)>=C}),console.log(`Density filter: kept ${V.length} hatch edges (threshold ${C})`)}const q=st(V,t,a,l,r);q.forEach(C=>C.isHatch=!0),b.push(...q),console.log(`Added ${q.length} visible hatch edges`)}console.time("splitIntersections");const p=bt(b);console.timeEnd("splitIntersections"),console.log(`After splitting: ${p.length} edges`),console.time("buildProjectedFaces");const g=[],y=t.position,w=a/2,P=l/2;for(const V of i){const q=V.geometry,C=q.attributes.position,T=q.index,D=T?T.count/3:C.count/3;for(let A=0;A<D;A++){let N,Y,W;T?(N=T.getX(A*3),Y=T.getX(A*3+1),W=T.getX(A*3+2)):(N=A*3,Y=A*3+1,W=A*3+2);const R=new M.Vector3(C.getX(N),C.getY(N),C.getZ(N)).applyMatrix4(V.matrixWorld),L=new M.Vector3(C.getX(Y),C.getY(Y),C.getZ(Y)).applyMatrix4(V.matrixWorld),j=new M.Vector3(C.getX(W),C.getY(W),C.getZ(W)).applyMatrix4(V.matrixWorld),Z=new M.Vector3().subVectors(L,R),Q=new M.Vector3().subVectors(j,R),G=new M.Vector3().crossVectors(Z,Q).normalize(),at=new M.Vector3().addVectors(R,L).add(j).divideScalar(3),lt=new M.Vector3().subVectors(y,at),ut=-G.dot(R);if(G.dot(lt)<=0)continue;const Et=R.clone().project(t),St=L.clone().project(t),Pt=j.clone().project(t),oe=new M.Vector2(Et.x*w*r,-Et.y*P*r),se=new M.Vector2(St.x*w*r,-St.y*P*r),ie=new M.Vector2(Pt.x*w*r,-Pt.y*P*r),ft=t.matrixWorldInverse,ce=-R.clone().applyMatrix4(ft).z,re=-L.clone().applyMatrix4(ft).z,ae=-j.clone().applyMatrix4(ft).z;g.push({a2d:oe,b2d:se,c2d:ie,depthA:ce,depthB:re,depthC:ae,mesh:V,faceIdx:A,normal:G,constant:ut})}}console.timeEnd("buildProjectedFaces"),console.log(`Built ${g.length} projected faces for occlusion`),console.time("classifySilhouettes"),te(p,g),console.timeEnd("classifySilhouettes"),console.time("filterSmoothSplitEdges");const S=Zt(p,g,o,d);console.timeEnd("filterSmoothSplitEdges");let E;c?E=S:(console.time("testOcclusion (math)"),E=Kt(S,g,t),console.timeEnd("testOcclusion (math)")),console.log(`Visible edges: ${E.length}`),console.time("optimize");const k=it(E);console.timeEnd("optimize"),console.time("cleanup orphans");const I=ct(k);console.timeEnd("cleanup orphans");const O=Gt(I);console.log(`Final edges before optimization: ${O.length}`);let F=O;if(O.length>0){let V=0;for(const T of O){const D=T.b.x-T.a.x,A=T.b.y-T.a.y;V+=Math.sqrt(D*D+A*A)}const q=V/O.length,C=q/10;console.log(`Optimization: avgLen=${q.toFixed(2)}, trim limit=${C.toFixed(2)}`),console.time("Optimize.segments"),F=_.segments(O,!1,!0,C,!1,!1,!1)._segments,console.timeEnd("Optimize.segments"),console.log(`After optimization: ${F.length} edges`)}for(const V of F)V.a.x/=r,V.a.y/=r,V.b.x/=r,V.b.y/=r;const H=F;return{edges:H,profiles:H.filter(V=>V.isProfile),allEdges:p,projectedFaces:g}}function te(i,t){for(const o of i){if(o.isHatch){o.isSilhouette=!1;continue}const s=(o.a.x+o.b.x)/2,c=(o.a.y+o.b.y)/2,a=o.b.x-o.a.x,l=o.b.y-o.a.y,u=Math.sqrt(a*a+l*l);if(u<.001){o.isSilhouette=!1;continue}const r=-l/u,d=a/u,f=vt(s,c,r,d,1e3,t),h=vt(s,c,-r,-d,1e3,t);o.isSilhouette=!f||!h}const n=i.filter(o=>o.isSilhouette).length;console.log(`Classified ${n} silhouette edges out of ${i.length}`)}function vt(i,t,e,n,o,s){for(const c of s)if(ee(i,t,e,n,o,c.a2d,c.b2d,c.c2d))return!0;return!1}function ee(i,t,e,n,o,s,c,a){return!!(rt(i,t,e,n,o,s.x,s.y,c.x,c.y)||rt(i,t,e,n,o,c.x,c.y,a.x,a.y)||rt(i,t,e,n,o,a.x,a.y,s.x,s.y))}function rt(i,t,e,n,o,s,c,a,l){const u=a-s,r=l-c,d=e*r-n*u;if(Math.abs(d)<1e-10)return!1;const f=((s-i)*r-(c-t)*u)/d,h=((s-i)*n-(c-t)*e)/d;return f>.1&&f<=o&&h>=0&&h<=1}var B=i=>Math.round(i*100)/100,tt=function(i){M.Object3D.call(this),this.node=i};tt.prototype=Object.create(M.Object3D.prototype),tt.prototype.constructor=tt;var ne=function(){var i=this,t=document.createElementNS("http://www.w3.org/2000/svg","svg"),e=document.createElementNS("http://www.w3.org/2000/svg","g"),n=document.createElementNS("http://www.w3.org/2000/svg","g"),o=document.createElementNS("http://www.w3.org/2000/svg","g"),s,c,a,l,u=new M.Color;t.setAttribute("xmlns","http://www.w3.org/2000/svg"),t.setAttribute("xmlns:inkscape","http://www.inkscape.org/namespaces/inkscape"),t.setAttribute("xmlns:xlink","http://www.w3.org/1999/xlink"),t.setAttribute("version","1.1"),e.setAttribute("inkscape:label","Silhouettes"),e.setAttribute("inkscape:groupmode","layer"),e.id="silhouettes_layer",t.appendChild(e),o.setAttribute("inkscape:label","Shading"),o.setAttribute("inkscape:groupmode","layer"),o.id="shading_layer",t.appendChild(o),n.setAttribute("inkscape:label","Edges"),n.setAttribute("inkscape:groupmode","layer"),n.id="edges_layer",t.appendChild(n),this.domElement=t,this.showSilhouettes=!0,this.showEdges=!0,this.showHatches=!0,this.silhouetteOptions={normalBuckets:12,simplifyTolerance:2,minArea:100},this.hatchOptions={baseSpacing:8,minSpacing:3,maxSpacing:40,depthFactor:.5,insetPixels:3,stroke:"black",strokeWidth:"1px",axisSettings:{x:{rotation:0,spacing:8},y:{rotation:0,spacing:8},z:{rotation:0,spacing:8}}},this.edgeOptions={stroke:"white",strokeWidth:"1px"},this.hiddenLineOptions={smoothThreshold:.99},this._glRenderer=null,this.autoClear=!0,this.setClearColor=function(d){u.set(d)},this.setPixelRatio=function(){},this.setSize=function(d,f){s=d,c=f,a=s/2,l=c/2,t.setAttribute("viewBox",-a+" "+-l+" "+s+" "+c),t.setAttribute("width",s),t.setAttribute("height",c)},this.getSize=function(){return{width:s,height:c}},this.setGLRenderer=function(d){i._glRenderer=d};function r(){for(;e.childNodes.length>0;)e.removeChild(e.childNodes[0]);for(;n.childNodes.length>0;)n.removeChild(n.childNodes[0]);for(;o.childNodes.length>0;)o.removeChild(o.childNodes[0])}this.clear=function(){r(),t.style.backgroundColor=u.getStyle()},this.renderGPULayers=function(d,f){if(!i._glRenderer){console.warn("PlotterRenderer: WebGL renderer not set. Call setGLRenderer() first.");return}const h=i._glRenderer;if(i.showSilhouettes||i.showHatches){const x=dt(h,d,f,{normalBuckets:i.silhouetteOptions.normalBuckets,simplifyTolerance:i.silhouetteOptions.simplifyTolerance,minArea:i.silhouetteOptions.minArea,insetPixels:i.showHatches?i.hatchOptions.insetPixels:0});if(i.showSilhouettes&&x.forEach(m=>{if(m.boundary.length<3)return;const b=document.createElementNS("http://www.w3.org/2000/svg","path");let p="";m.boundary.forEach((S,E)=>{const k=S.x,I=-S.y;p+=(E===0?"M":"L")+B(k)+","+B(I)}),p+="Z";const g=m.normal,y=Math.floor((g.x*.5+.5)*255),w=Math.floor((g.y*.5+.5)*255),P=Math.floor((g.z*.5+.5)*255);b.setAttribute("d",p),b.setAttribute("fill",`rgba(${y},${w},${P},0.3)`),b.setAttribute("stroke","none"),e.appendChild(b)}),i.showHatches){x.sort((b,p)=>b.depth-p.depth);const m=x.map(b=>b.boundary);x.forEach((b,p)=>{let g=ht(b,f,{baseSpacing:i.hatchOptions.baseSpacing,minSpacing:i.hatchOptions.minSpacing,maxSpacing:i.hatchOptions.maxSpacing,depthFactor:i.hatchOptions.depthFactor,insetPixels:i.hatchOptions.insetPixels,screenWidth:s,screenHeight:c,axisSettings:i.hatchOptions.axisSettings});for(let y=0;y<p;y++)g=g.flatMap(w=>gt(w,m[y]));g.forEach(y=>{const w=document.createElementNS("http://www.w3.org/2000/svg","path"),P=`M${B(y.start.x)},${B(-y.start.y)}L${B(y.end.x)},${B(-y.end.y)}`;w.setAttribute("d",P),w.setAttribute("fill","none"),w.setAttribute("stroke",i.hatchOptions.stroke),w.setAttribute("stroke-width",i.hatchOptions.strokeWidth),o.appendChild(w)})})}if(i.showEdges){const m=[];d.traverse(b=>{b.isMesh&&b.geometry&&m.push(b)}),m.length>0&&(Mt(m,f,d,{smoothThreshold:i.hiddenLineOptions.smoothThreshold,width:s,height:c}).edges||[]).forEach(g=>{const y=document.createElementNS("http://www.w3.org/2000/svg","line");y.setAttribute("x1",B(g.a.x)),y.setAttribute("y1",B(g.a.y)),y.setAttribute("x2",B(g.b.x)),y.setAttribute("y2",B(g.b.y)),y.setAttribute("stroke",i.edgeOptions.stroke),y.setAttribute("stroke-width",i.edgeOptions.strokeWidth),n.appendChild(y)})}}},this.render=function(d,f){if(!(f instanceof M.Camera)){console.error("PlotterRenderer.render: camera is not an instance of Camera.");return}}};X.GeomUtil=v,X.Optimize=_,X.PlotterRenderer=ne,X.Point=$,X.SVGObject=tt,X.Segment=z,X.Segments=K,X.cleanupOrphanedEdges=ct,X.clipLineOutsidePolygon=gt,X.clipLineToPolygon=nt,X.computeHiddenLines=Ut,X.computeHiddenLinesMultiple=Mt,X.extractNormalRegions=dt,X.generatePerspectiveHatches=ht,X.optimizeEdges=it,Object.defineProperty(X,Symbol.toStringTag,{value:"Module"})});
//# sourceMappingURL=three-plotter-renderer.umd.js.map
