(function(L,P){typeof exports=="object"&&typeof module<"u"?P(exports,require("three")):typeof define=="function"&&define.amd?define(["exports","three"],P):(L=typeof globalThis<"u"?globalThis:L||self,P(L.ThreePlotterRenderer={},L.THREE))})(this,function(L,P){"use strict";function gt(i,t,n,e={}){const{resolution:o=2,normalBuckets:s=12,minArea:c=100,simplifyTolerance:u=2,insetPixels:a=0}=e,l=i.getSize(new P.Vector2),r=Math.floor(l.x*o),h=Math.floor(l.y*o),f=Math.round(a*o),d=yt(i,t,n,r,h),m=mt(i,t,n,r,h);let{regionMap:p,normalLookup:w}=wt(d,r,h);f>0&&(p=bt(p,r,h,f));const{labels:y,regionCount:x}=Mt(p,r,h),g=[];for(let b=1;b<=x;b++){const v=Pt(y,r,h,b);if(v.length<3)continue;const S=nt(v,u),E=Math.abs(Et(S));if(E<c)continue;const $=St(y,p,w,r,h,b),k=pt(y,m,r,h,b);g.push({boundary:S.map(T=>new P.Vector2(T.x/o-l.x/2,T.y/o-l.y/2)),normal:$,depth:k,area:E/(o*o),regionId:b})}return g}function yt(i,t,n,e,o){const s=new P.WebGLRenderTarget(e,o,{minFilter:P.NearestFilter,magFilter:P.NearestFilter}),c=new P.MeshNormalMaterial({flatShading:!0}),u=new Map,a=[];t.traverse(r=>{r.isMesh?(u.set(r,r.material),r.material=c):(r.isLineSegments||r.isLine||r.isPoints)&&r.visible&&(a.push(r),r.visible=!1)}),i.setRenderTarget(s),i.render(t,n),t.traverse(r=>{r.isMesh&&u.has(r)&&(r.material=u.get(r))});for(const r of a)r.visible=!0;i.setRenderTarget(null);const l=new Uint8Array(e*o*4);return i.readRenderTargetPixels(s,0,0,e,o,l),s.dispose(),c.dispose(),l}function mt(i,t,n,e,o){const s=new P.WebGLRenderTarget(e,o,{minFilter:P.NearestFilter,magFilter:P.NearestFilter}),c=new P.MeshDepthMaterial({depthPacking:P.RGBADepthPacking}),u=new Map,a=[];t.traverse(r=>{r.isMesh?(u.set(r,r.material),r.material=c):(r.isLineSegments||r.isLine||r.isPoints)&&r.visible&&(a.push(r),r.visible=!1)}),i.setRenderTarget(s),i.render(t,n),t.traverse(r=>{r.isMesh&&u.has(r)&&(r.material=u.get(r))});for(const r of a)r.visible=!0;i.setRenderTarget(null);const l=new Uint8Array(e*o*4);return i.readRenderTargetPixels(s,0,0,e,o,l),s.dispose(),c.dispose(),l}function pt(i,t,n,e,o){let s=0,c=0;for(let u=0;u<e;u++)for(let a=0;a<n;a++)if(i[u*n+a]===o){const l=(u*n+a)*4,r=t[l]/255,h=t[l+1]/255,f=t[l+2]/255,d=t[l+3]/255,m=r+h/256+f/65536+d/16777216;s+=m,c++}return c>0?s/c:.5}function bt(i,t,n,e){let o=i;for(let s=0;s<e;s++){const c=new Uint16Array(o);for(let u=1;u<n-1;u++)for(let a=1;a<t-1;a++){const l=u*t+a;if(o[l]===0)continue;const h=o[l-1],f=o[l+1],d=o[l-t],m=o[l+t];(h===0||f===0||d===0||m===0)&&(c[l]=0)}o=c}return o}function wt(i,t,n,e){const o=new Uint16Array(t*n),s={};let c=1;const u={};for(let a=0;a<t*n;a++){const l=a*4,r=i[l],h=i[l+1],f=i[l+2];if(r<5&&h<5&&f<5){o[a]=0;continue}const d=r/255*2-1,m=h/255*2-1,p=f/255*2-1,w=4,y=Math.round(r/w)*w,x=Math.round(h/w)*w,g=Math.round(f/w)*w,b=`${y}|${x}|${g}`;u[b]||(u[b]=c,s[c]=new P.Vector3(d,m,p).normalize(),c++),o[a]=u[b]}return{regionMap:o,normalLookup:s}}function Mt(i,t,n){const e=new Uint32Array(t*n),o=[];let s=1;function c(r){return o[r]!==r&&(o[r]=c(o[r])),o[r]}function u(r,h){const f=c(r),d=c(h);f!==d&&(o[d]=f)}for(let r=0;r<n;r++)for(let h=0;h<t;h++){const f=r*t+h,d=i[f];if(d===0)continue;const m=[];if(h>0&&i[f-1]===d&&e[f-1]>0&&m.push(e[f-1]),r>0&&i[f-t]===d&&e[f-t]>0&&m.push(e[f-t]),m.length===0)e[f]=s,o[s]=s,s++;else{const p=Math.min(...m);e[f]=p;for(const w of m)u(p,w)}}const a={};let l=0;for(let r=0;r<t*n;r++){if(e[r]===0)continue;const h=c(e[r]);a[h]===void 0&&(l++,a[h]=l),e[r]=a[h]}return{labels:e,regionCount:l}}function Pt(i,t,n,e){const o=[];let s=-1,c=-1;t:for(let m=0;m<n;m++)for(let p=0;p<t;p++)if(i[m*t+p]===e&&(p===0||i[m*t+p-1]!==e||m===0||i[(m-1)*t+p]!==e)){s=p,c=m;break t}if(s===-1)return o;const u=[1,1,0,-1,-1,-1,0,1],a=[0,1,1,1,0,-1,-1,-1];let l=s,r=c,h=7;const f=t*n*2;let d=0;do{o.push({x:l,y:r});let m=!1;for(let p=0;p<8;p++){const w=(h+6+p)%8,y=l+u[w],x=r+a[w];if(y>=0&&y<t&&x>=0&&x<n&&i[x*t+y]===e){l=y,r=x,h=w,m=!0;break}}if(!m)break;d++}while((l!==s||r!==c)&&d<f);return o}function St(i,t,n,e,o,s){let c=0,u=0,a=0;for(let d=0;d<o;d++)for(let m=0;m<e;m++)i[d*e+m]===s&&(c+=m,u+=d,a++);if(a===0)return new P.Vector3(0,0,1);const l=Math.round(c/a),h=Math.round(u/a)*e+l,f=t[h];return n[f]||new P.Vector3(0,0,1)}function nt(i,t){if(i.length<3)return i;let n=0,e=0;const o=i[0],s=i[i.length-1];for(let c=1;c<i.length-1;c++){const u=vt(i[c],o,s);u>n&&(n=u,e=c)}if(n>t){const c=nt(i.slice(0,e+1),t),u=nt(i.slice(e),t);return c.slice(0,-1).concat(u)}else return[o,s]}function vt(i,t,n){const e=n.x-t.x,o=n.y-t.y,s=e*e+o*o;if(s<1e-10)return Math.sqrt((i.x-t.x)**2+(i.y-t.y)**2);const c=((i.x-t.x)*e+(i.y-t.y)*o)/s,u=t.x+c*e,a=t.y+c*o;return Math.sqrt((i.x-u)**2+(i.y-a)**2)}function Et(i){let t=0;for(let n=0;n<i.length;n++){const e=(n+1)%i.length;t+=i[n].x*i[e].y,t-=i[e].x*i[n].y}return t/2}function kt(i,t,n,e){const o=n/2,s=e/2,c=new P.Vector3(0,1,0),u=new P.Vector3(0,0,1);let a;Math.abs(i.y)>.9?a=u.clone():(a=new P.Vector3().crossVectors(c,i).normalize(),a.lengthSq()<.01&&(a=u.clone()));const l=new P.Vector3(0,0,0),r=a.clone().multiplyScalar(100),h=l.clone().project(t),f=r.clone().project(t),d=new P.Vector2(h.x*o,-h.y*s),p=new P.Vector2(f.x*o,-f.y*s).clone().sub(d).normalize(),y=a.clone().multiplyScalar(1e5).clone().project(t);let x=null;return Math.abs(y.x)<100&&Math.abs(y.y)<100&&y.z<1&&(x=new P.Vector2(y.x*o,-y.y*s)),{direction:p,vanishingPoint:x}}function Vt(i,t,n={}){const{baseSpacing:e=8,minSpacing:o=3,maxSpacing:s=20,depthFactor:c=.5,screenWidth:u=1200,screenHeight:a=800,axisSettings:l={}}=n,{boundary:r,normal:h,depth:f=.5}=i;if(r.length<3)return[];const d=Math.abs(h.x),m=Math.abs(h.y),p=Math.abs(h.z);let w="y";d>=m&&d>=p?w="x":p>=m&&p>=d&&(w="z");const y=l[w]||{},x=y.rotation||0,g=y.spacing;console.log(`[Hatch] normal=(${h.x.toFixed(2)}, ${h.y.toFixed(2)}, ${h.z.toFixed(2)}) => axis=${w}, rotation=${x}, spacing=${g}`);const{direction:b,vanishingPoint:v}=kt(h,t,u,a);let S=b;if(x!==0){const Y=x*(Math.PI/180),F=Math.cos(Y),R=Math.sin(Y);S=new P.Vector2(b.x*F-b.y*R,b.x*R+b.y*F)}const E=new P.Vector2(-S.y,S.x),k=Math.max(o,Math.min(s,(g!==void 0?g:e)+f*c*(s-o)));let T=1/0,W=-1/0,A=1/0,I=-1/0;for(const Y of r)T=Math.min(T,Y.x),W=Math.max(W,Y.x),A=Math.min(A,Y.y),I=Math.max(I,Y.y);const D=(T+W)/2,O=(A+I)/2,X=new P.Vector2(D,O),H=Math.sqrt((W-T)**2+(I-A)**2),C=[];if(v&&Math.abs(x)<5&&v.distanceTo(X)<H*5){const Y=v.distanceTo(X),F=Math.ceil(H/k)*2,B=Math.atan2(H,Y)*2/F,j=Math.atan2(O-v.y,D-v.x);for(let Z=-F;Z<=F;Z++){const K=j+Z*B,_=new P.Vector2(Math.cos(K),Math.sin(K)),st=v.clone(),it=v.clone().add(_.clone().multiplyScalar(Y*10)),ct=rt({start:st,end:it},r);C.push(...ct)}}else{const Y=Math.ceil(H/k)+2;for(let F=-Y;F<=Y;F++){const R=E.clone().multiplyScalar(F*k),B=X.clone().add(R),j=B.clone().add(S.clone().multiplyScalar(-H)),Z=B.clone().add(S.clone().multiplyScalar(H)),K=rt({start:j,end:Z},r);C.push(...K)}}return C}function rt(i,t){const n=[],e=t.length;for(let s=0;s<e;s++){const c=t[s],u=t[(s+1)%e],a=Ot(i.start.x,i.start.y,i.end.x,i.end.y,c.x,c.y,u.x,u.y);a&&n.push({point:new P.Vector2(a.x,a.y),t:a.t})}if(n.length<2)return[];n.sort((s,c)=>s.t-c.t);const o=[];for(let s=0;s<n.length-1;s++){const c=(n[s].point.x+n[s+1].point.x)/2,u=(n[s].point.y+n[s+1].point.y)/2;G(c,u,t)&&o.push({start:n[s].point,end:n[s+1].point})}return o}function $t(i,t){const n=[],e=t.length,o=G(i.start.x,i.start.y,t),s=G(i.end.x,i.end.y,t);n.push({point:i.start.clone(),t:0,inside:o});for(let a=0;a<e;a++){const l=t[a],r=t[(a+1)%e],h=It(i.start.x,i.start.y,i.end.x,i.end.y,l.x,l.y,r.x,r.y);h&&h.t>0&&h.t<1&&n.push({point:new P.Vector2(h.x,h.y),t:h.t,inside:null})}n.push({point:i.end.clone(),t:1,inside:s}),n.sort((a,l)=>a.t-l.t);const c=[n[0]];for(let a=1;a<n.length;a++)n[a].t-c[c.length-1].t>1e-4&&c.push(n[a]);if(c.length<2)return[i];const u=[];for(let a=0;a<c.length-1;a++){const l=(c[a].t+c[a+1].t)/2,r=i.start.x+l*(i.end.x-i.start.x),h=i.start.y+l*(i.end.y-i.start.y);G(r,h,t)||u.push({start:c[a].point.clone(),end:c[a+1].point.clone()})}return u}function It(i,t,n,e,o,s,c,u){const a=(i-n)*(s-u)-(t-e)*(o-c);if(Math.abs(a)<1e-10)return null;const l=((i-o)*(s-u)-(t-s)*(o-c))/a,r=-((i-n)*(t-s)-(t-e)*(i-o))/a;return l>=0&&l<=1&&r>=0&&r<=1?{x:i+l*(n-i),y:t+l*(e-t),t:l}:null}function Ot(i,t,n,e,o,s,c,u){const a=(i-n)*(s-u)-(t-e)*(o-c);if(Math.abs(a)<1e-10)return null;const l=((i-o)*(s-u)-(t-s)*(o-c))/a,r=-((i-n)*(t-s)-(t-e)*(i-o))/a;return r>=0&&r<=1?{x:i+l*(n-i),y:t+l*(e-t),t:l}:null}function G(i,t,n){let e=!1;const o=n.length;for(let s=0,c=o-1;s<o;c=s++){const u=n[s].x,a=n[s].y,l=n[c].x,r=n[c].y;a>t!=r>t&&i<(l-u)*(t-a)/(r-a)+u&&(e=!e)}return e}const at=.001;class V{constructor(t,n){this.x=t,this.y=n}static clone(t){return new V(t.x,t.y)}}class et{constructor(t,n,e,o){this.minX=t,this.minY=n,this.maxX=e,this.maxY=o}width(){return Math.abs(this.maxX-this.minX)}height(){return Math.abs(this.maxY-this.minY)}}class Tt{constructor(t=0){this.r=t}}class q{constructor(t,n){this.a=t,this.b=n,this.tags={}}static isEqual(t,n){return M.pointsEqual(t.a,n.a)&&M.pointsEqual(t.b,n.b)||M.pointsEqual(t.b,n.a)&&M.pointsEqual(t.a,n.b)}static clone(t){return new q(new V(t.a.x,t.a.y),new V(t.b.x,t.b.y))}}class Xt{constructor(){this.pivot={x:0,y:0},this.rotation=0,this.isOpen=!0,this.isGroup=!1,this.isStrong=!1,this._makeAbsolute=t=>{let n=this.rotation*Math.PI/180;t.forEach((e,o)=>{const s={x:e.x,y:e.y};M.rotatePoint(s,n),s.x+=this.pivot.x,s.y+=this.pivot.y,t[o]=s})},this._makeSegsAbsolute=t=>{let n=this.rotation*Math.PI/180;t.forEach(e=>{const o={x:e.a.x,y:e.a.y},s={x:e.b.x,y:e.b.y};M.rotatePoint(o,n),M.rotatePoint(s,n),M.addToPoint(o,this.pivot),M.addToPoint(s,this.pivot),e.a=o,e.b=s})}}toPoints(t=!1){throw"not implemented"}toSegments(t=!1){throw"not implemented"}getBoundingBox(t=!1){const n=new et(1e6,1e6,-1e6,-1e6);return this.toPoints(t).forEach(o=>{n.minX=Math.min(n.minX,o.x),n.minY=Math.min(n.minY,o.y),n.maxX=Math.max(n.maxX,o.x),n.maxY=Math.max(n.maxY,o.y)}),n}getBoundingCircle(){const t=new Tt;return this.toPoints(!0).forEach(e=>{t.r=Math.max(t.r,Math.sqrt(e.x*e.x+e.y*e.y))}),t}}class Q extends Xt{constructor(t){super(),this._segments=t}add(...t){this._segments=this._segments.concat(t)}toPoints(t=!1){return this.toSegments(t).reduce((n,e)=>e?n.concat([e.a,e.b]):n,[])}toSegments(t=!1){let n=this._segments.reduce((e,o)=>o?e.concat(q.clone(o)):e,[]);return t||this._makeSegsAbsolute(n),n}bake(){}result(){return Q.clone(this)}static clone(t){let n=t._segments,e=[],o=n.length;for(;o--;)e.unshift(q.clone(n[o]));let s=new Q(e);return s.pivot.x=t.pivot.x,s.pivot.y=t.pivot.y,s.rotation=t.rotation,s}}class M{static lerp(t,n,e){return(1-e)*t+e*n}static angleBetween(t,n){return Math.atan2(n.y-t.y,n.x-t.x)}static sameAngle(t,n){let e=M.angleBetween(t.a,t.b),o=M.angleBetween(n.a,n.b);return Math.abs(e-o)<at}static sameAngleRev(t,n){let e=M.angleBetween(t.a,t.b),o=M.angleBetween(n.b,n.a);return Math.abs(e-o)<at}static lerpPoints(t,n,e){return{x:M.lerp(t.x,n.x,e),y:M.lerp(t.y,n.y,e)}}static rotatePointDeg(t,n){M.rotatePoint(t,n*Math.PI/180)}static rotatePoint(t,n){const e=Math.cos(n),o=Math.sin(n),s=t.y,c=t.x;t.y=e*s-o*c,t.x=o*s+e*c}static rotatePoints(t,...n){n.forEach(e=>{M.rotatePoint(e,t)})}static rotatePointsDeg(t,...n){let e=t*Math.PI/180;n.forEach(o=>{M.rotatePoint(o,e)})}static outerTangents(t,n,e,o){var s=e.x-t.x,c=e.y-t.y,u=Math.sqrt(s*s+c*c);if(u<=Math.abs(o-n))return[];var a=Math.atan2(c,s),l=Math.acos((n-o)/u);return[new q({x:t.x+n*Math.cos(a+l),y:t.y+n*Math.sin(a+l)},{x:e.x+o*Math.cos(a+l),y:e.y+o*Math.sin(a+l)}),new q({x:t.x+n*Math.cos(a-l),y:t.y+n*Math.sin(a-l)},{x:e.x+o*Math.cos(a-l),y:e.y+o*Math.sin(a-l)})]}static cartesian2Polar(t){const n=Math.sqrt(t.x*t.x+t.y*t.y),e=Math.atan2(t.y,t.x);t.x=n,t.y=e}static pointsEqual(t,n,e=1){return Math.round(t.x*1e4/e)==Math.round(n.x*1e4/e)&&Math.round(t.y*1e4/e)==Math.round(n.y*1e4/e)}static distanceBetween(t,n){const e=n.x-t.x,o=n.y-t.y;return Math.sqrt(e*e+o*o)}static distanceBetweenSquared(t,n){const e=n.x-t.x,o=n.y-t.y;return e*e+o*o}static interpolatePoints(t,n,e){let o=[{x:t.x,y:t.y}],s=1/e,c=(n.x-t.x)*s,u=(n.y-t.y)*s;for(var a=1;a<e;a++)o.push(new V(t.x+c*a,t.y+u*a));return o.push({x:n.x,y:n.y}),o}static averagePoints(...t){let n=new V(0,0);return t.forEach(e=>{n.x+=e.x,n.y+=e.y}),n.x/=t.length,n.y/=t.length,n}static addToPoint(t,n){t.x+=n.x,t.y+=n.y}static subFromPoint(t,n){t.x-=n.x,t.y-=n.y}static subdivideByDistance(t,n,e){if(e===0)return[t,n];let o=[{x:t.x,y:t.y}],s=M.distanceBetween(t,n),c=e/s,u=Math.floor(1/c),a=s%e;e+=a/u,c=e/s;let l=c,r=1,h=(n.x-t.x)*c,f=(n.y-t.y)*c;for(;l<1;)o.push(new V(t.x+h*r,t.y+f*r)),l+=c,r++;return o.push({x:n.x,y:n.y}),o}static segmentsConnected(t,n,e=1){return M.pointsEqual(t.b,n.a,e)||M.pointsEqual(t.a,n.b,e)}static segmentsToPoints(t){let n=t.reduce((o,s)=>o.concat(s.a,s.b),[]),e=n.length;for(;e--;){let o=n[e];e>0&&M.pointsEqual(o,n[e-1])&&n.splice(e,1)}return n}static polygonArea(t){let n=0,e=t.length-1;for(var o=0;o<t.length;o++)n+=t[o].x*t[e].y,n-=t[e].x*t[o].y,e=o;return n/2}static pointsBoundingBox(t){const n=new et(1e6,1e6,-1e6,-1e6);return t.forEach(e=>{n.minX=Math.min(n.minX,e.x),n.minY=Math.min(n.minY,e.y),n.maxX=Math.max(n.maxX,e.x),n.maxY=Math.max(n.maxY,e.y)}),n}static boundingBoxesBoundingBox(t){const n=new et(1e6,1e6,-1e6,-1e6);return t.forEach(e=>{n.minX=Math.min(n.minX,e.minX),n.minY=Math.min(n.minY,e.minY),n.maxX=Math.max(n.maxX,e.maxX),n.maxY=Math.max(n.maxY,e.maxY)}),n}static segmentsBoundingBox(t){const n=[];return t.forEach(e=>{n.push(e.a),n.push(e.b)}),M.pointsBoundingBox(n)}static boundingBoxesIntersect(t,n){return t.maxX>=n.minX&&t.maxY>=n.minY&&t.minX<=n.maxX&&t.minY<=n.maxY}static polygonIsClockwise(t){return M.polygonArea(t)>0}static ccw(t,n,e){return(e.y-t.y)*(n.x-t.x)>(n.y-t.y)*(e.x-t.x)}static segmentsIntersect(t,n){const e=M.ccw;return e(t.a,n.a,n.b)!=e(t.b,n.a,n.b)&&e(t.a,t.b,n.a)!=e(t.a,t.b,n.b)}static segmentSegmentIntersect(t,n,e=!1){const o=t.a.x,s=t.a.y,c=t.b.x,u=t.b.y,a=n.a.x,l=n.a.y,r=n.b.x,h=n.b.y,f=c-o,d=u-s,m=r-a,p=h-l,w=(-d*(o-a)+f*(s-l))/(-m*d+f*p),y=(m*(s-l)-p*(o-a))/(-m*d+f*p);if(w>=0&&w<=1&&y>=0&&y<=1){const x=o+y*f,g=s+y*d;let b={x,y:g};return e&&(M.pointsEqual(b,n.a)||M.pointsEqual(b,n.b)||M.pointsEqual(b,t.a)||M.pointsEqual(b,t.b))?void 0:b}return null}static segmentSegmentsIntersections(t,n,e=!1){let o=[];return n.forEach(s=>{if(s==t)return;let c=M.segmentSegmentIntersect(t,s,e);c&&o.push(c)}),o}static dot(t,n){return t.x*n.x+t.y*n.y}static cross(t,n){return t.x*n.y-t.y*n.x}static lineSide(t,n,e){return Math.round(((e.x-n.x)*(t.y-n.y)-(e.y-n.y)*(t.x-n.x))*100)/100}static sub(t,n){return new V(t.x-n.x,t.y-n.y)}static add(t,n){return new V(t.x+n.x,t.y+n.y)}static closestPtPointSegment(t,n){var e=M.sub(n.b,n.a),o=M.sub(t,n.a),s=M.dot(o,e);if(s<0)t=n.a;else{var c=M.dot(e,e);s>=c?t=n.b:(s/=c,o.x=n.a.x+s*e.x,o.y=n.a.y+s*e.y,t=o)}return V.clone(t)}static distancePointSegment(t,n){return M.distanceBetween(t,M.closestPtPointSegment(t,n))}static pointWithinBoundingBox(t,n){return t.x>=n.minX&&t.y>=n.minY&&t.x<=n.maxX&&t.y<=n.maxY}static pointWithinPolygon(t,n,e){const o=M.segmentsBoundingBox(n);if(!this.pointWithinBoundingBox(t,o))return!1;let s=new V(1e5,1e5),c=new q(s,t),u=M.segmentSegmentsIntersections(c,n);return u.length%2!=0&&e&&M.pointsEqual(t,u[0])?!1:u.length%2!=0}static segmentWithinPolygon(t,n){let e=this.pointWithinPolygon(t.a,n,!1),o=this.pointWithinPolygon(t.b,n,!1),s=this.pointWithinPolygon(t.a,n,!0),c=this.pointWithinPolygon(t.b,n,!0);return s&&c||s&&o||c&&e}static sign(t,n,e){return(t.x-e.x)*(n.y-e.y)-(n.x-e.x)*(t.y-e.y)}static pointWithinTriangle(t,n,e,o,s){const c=M.sign(t,n,e),u=M.sign(t,e,o),a=M.sign(t,o,n),l=c<0||u<0||a<0,r=c>0||u>0||a>0;if(!(l&&r)&&s){let h={a:n,b:e,tags:null};if(M.distancePointSegment(t,h)<1||(h.a=e,h.b=o,M.distancePointSegment(t,h)<1)||(h.a=o,h.b=n,M.distancePointSegment(t,h)<1))return!1}return!(l&&r)}static segmentWithinTriangle(t,n,e,o){let s=this.pointWithinTriangle(t.a,n,e,o,!1),c=this.pointWithinTriangle(t.b,n,e,o,!1),u=this.pointWithinTriangle(t.a,n,e,o,!0),a=this.pointWithinTriangle(t.b,n,e,o,!0);return M.averagePoints(t.a,t.b),u&&a||u&&c||a&&s||s&&c}static pointsToClosedPolySegments(...t){let n=[];for(let e=0;e<t.length;e++)n.push(new q(t[e],e<t.length-1?t[e+1]:t[0]));return n}static polygonWithinPolygon(t,n){const e=M.segmentsBoundingBox(t),o=M.segmentsBoundingBox(n);if(!M.boundingBoxesIntersect(e,o))return!1;new V(o.minX-100,o.minY-100);for(let s=0;s<t.length;s++){let c=t[s];if(M.segmentSegmentsIntersections(c,n).length%2==0)return!1}return!0}static splinePoints(t,n,e,o=0){let s=u=>{let a=[u[0]];for(let l=0;l<u.length-1;l++){let r=new V(0,0);l+1<u.length*.4?(r.x=(u[l].x*40+u[l+1].x*60)*.01,r.y=(u[l].y*40+u[l+1].y*60)*.01):l+1>u.length*.6?(r.x=(u[l].x*60+u[l+1].x*40)*.01,r.y=(u[l].y*60+u[l+1].y*40)*.01):(r.x=(u[l].x+u[l+1].x)*.5,r.y=(u[l].y+u[l+1].y)*.5),a.push(r)}return a.push(u[u.length-1]),a},c=[t,n,e];for(let u=0;u<o;u++)c=s(c);return c}}class J{static getSegsAndConnections(t,n=!1,e=!1){let o={},s=[],c={},u=a=>{let l=`${Math.round(a.x*1)}|${Math.round(a.y*1)}`;return c[l]=a,l};if(n){let a=t.reduce((h,f)=>h.concat(f.a,f.b),[]),l=a.length;for(;l--;){let h=a[l],f=l;for(;f--;){let d=a[f];if(M.pointsEqual(h,d)){a.splice(l,1);break}}}let r=t.length;for(;r--;){let h=t[r],f=[];if(a.forEach(d=>{M.distancePointSegment(d,h)<.1&&!M.pointsEqual(d,h.a)&&!M.pointsEqual(d,h.b)&&f.push(d)}),f.length){f.sort((p,w)=>{const y=M.distanceBetweenSquared(p,h.a),x=M.distanceBetweenSquared(w,h.a);return y<x?-1:y>x?1:0});const d=[];let m=h.a;for(let p=0;p<f.length;p++){let w=f[p];d.push(new q(m,w)),m=w}d.push(new q(m,h.b)),t.splice(r,1,...d)}}}if(e){let a=t.length;for(;a--;){let l=a,r=!1;for(;l--;){let h=t[a],f=t[l],d=M.segmentSegmentIntersect(h,f,!0);d&&(r=!0,t.splice(a,1,new q(V.clone(h.a),V.clone(d)),new q(V.clone(d),V.clone(h.b))),t.splice(l,1,new q(V.clone(f.a),V.clone(d)),new q(V.clone(d),V.clone(f.b))))}r&&(a=t.length)}}return t.forEach(a=>{let l=u(a.a),r=u(a.b);o[l]||(o[l]=[]),o[r]||(o[r]=[]),o[l].indexOf(r)===-1&&o[l].push(r),o[r].indexOf(l)===-1&&o[r].push(l),s.indexOf(l)===-1&&s.push(l),s.indexOf(r)===-1&&s.push(r)}),{originalPts:c,pts:s,cxs:o}}static pathOrder(t,n=!1,e=!1){let o=[],{originalPts:s,pts:c,cxs:u}=J.getSegsAndConnections(t,n,e),a=r=>s[r],l=(r,h)=>u[r].length>u[h].length?1:u[r].length<u[h].length?-1:0;for(c.sort(l);c.length;){c.sort(l);let r=c.shift();for(;r;)if(u[r].length){u[r].sort(l);let h=u[r].shift(),f=u[h].indexOf(r);f!==-1&&u[h].splice(f,1),o.push(new q(a(r),a(h))),u[r].length&&c.unshift(r),r=h}else r=null}return o}static getEndingSegmentPoints(t,n=0){t=t.concat(),t=J.pathOrder(t,!0,!0);let{originalPts:e,pts:o,cxs:s}=J.getSegsAndConnections(t,!0),c=l=>e[l];const u=o.filter(l=>s[l].length===1),a=[];return u.forEach(l=>{const r=V.clone(c(l));if(n===0){a.push(r);return}const h=c(s[l]),f=M.angleBetween(h,r),d=new V(0,n);M.rotatePoint(d,Math.PI*.5-f),M.addToPoint(r,d),a.push(r)}),a}static getFills(t,n=5){t=t.concat();let{originalPts:e,cxs:o}=J.getSegsAndConnections(t,!0,!0),s=x=>{let g=`${Math.round(x.x*1)}|${Math.round(x.y*1)}`;return e[g]=x,g},c=[],u=[],a=1e5,l=1e5,r=-1e5,h=-1e5,f=1e5,d=1e5,m=[];for(let x in e){let g=e[x];m.push(g),a=Math.min(a,g.x),l=Math.min(l,g.y),r=Math.max(r,g.x),h=Math.max(h,g.y)}m.sort((x,g)=>x.x<g.x?-1:x.x>g.x?1:0),m.forEach((x,g)=>{if(g>0){let b=m[g-1],v=Math.round(Math.abs(x.x-b.x));v>1&&(f=Math.min(f,v))}}),m.sort((x,g)=>x.y<g.y?-1:x.y>g.y?1:0),m.forEach((x,g)=>{if(g>0){let b=m[g-1],v=Math.round(Math.abs(x.y-b.y));v>1&&(d=Math.min(d,v))}});let p=f*.5,w=d*.5,y=[];for(let x=l;x<h;x+=d)for(let g=a;g<r;g+=f)y.push(new V(g+p,x+w));return y.forEach(x=>{let g=[];if(m.forEach(S=>{let E=M.distanceBetween(S,x);if(E<Math.max(f,d)*n){let $=M.angleBetween(S,x);g.push({pt:S,dist:E,ang:$})}}),g.length<4)return;let b=g.length;for(;b--;){let S=g[b].pt,E=new q(x,S);M.segmentSegmentsIntersections(E,t,!0).length>0&&g.splice(b,1)}for(g.sort((S,E)=>S.ang<E.ang?-1:S.ang>E.ang?1:0),b=g.length;b--;){let S=g[b].pt,E=s(S),$=g.length,k=!1;for(;$--;){if(b===$)continue;let T=g[$].pt,W=s(T);if(o[E].indexOf(W)===-1){k=!0;break}}k||g.splice(b,1)}let v=!0;if(g.forEach((S,E)=>{let $=g[(E+1)%g.length],k=s(S.pt),T=s($.pt);o[k].indexOf(T)===-1&&(v=!1)}),v){let S=g.map(k=>k.pt),E=M.averagePoints(...S),$=s(E);c.indexOf($)===-1&&(c.push($),u.push(S))}}),u}}class U{static segmentCollections(t,n=!1,e=!0,o=1,s=!1,c=!1,u=!1){let a=t.reduce((l,r)=>l.concat(r.toSegments()),[]);return U.segments(a,n,e,o,s,c,u)}static segmentCollectionsPathOrder(t,n=!1,e=!1){let o=t.reduce((s,c)=>s.concat(c.toSegments()),[]);return new Q(J.pathOrder(o,n,e))}static segments(t,n=!1,e=!0,o=1,s=!1,c=!1,u=!1){return t=U._segments(t,n,e,o),s&&(t=J.pathOrder(t,c,u)),new Q(t)}static _segments(t,n,e,o){const s=t;for(t=[];s.length;){let u=s.shift(),a=t.length,l=!1;for(;a--;){const r=t[a];if(q.isEqual(u,r)){l=!0;break}}l||t.push(u)}if(!n)for(let u=0;u<3;u++){let a=t.length;for(;a--;){let l=t[a],r,h,f,d,m;for(let p=a-1;p>=0;p--){let w=t[p],y=!1,x=!1;if(M.sameAngle(l,w)?(y=!0,r=V.clone(l.a),h=V.clone(l.b),f=V.clone(w.a),d=V.clone(w.b)):M.sameAngleRev(l,w)&&(y=x=!0,r=V.clone(l.b),h=V.clone(l.a),f=V.clone(w.a),d=V.clone(w.b)),y&&(m=M.angleBetween(r,h),M.rotatePoints(m,r,h,f,d),Math.abs(r.y-f.y)<.1&&h.x>=f.x-1e-4&&r.x<=d.x+1e-4)){r.x<f.x&&(x?w.a=l.b:w.a=l.a),h.x>d.x&&(x?w.b=l.a:w.b=l.b),t.splice(a,1);break}}}}let c=t.length;for(;c--;){let u=t[c];if(!u){t.splice(c,1);continue}if(e&&M.distanceBetween(u.a,u.b)<o){t.splice(c,1);continue}}return console.log(`[JS] Optimize: ${s.length+t.length} -> ${t.length} segments`),t}}function Yt(i,t){const n=i.geometry,e=n.attributes.position,o=n.index;if(!e)return[];const s=new Map,c=1e3,u=(h,f)=>{const d=Math.round(h.x*c),m=Math.round(h.y*c),p=Math.round(h.z*c),w=Math.round(f.x*c),y=Math.round(f.y*c),x=Math.round(f.z*c),g=`${d},${m},${p}`,b=`${w},${y},${x}`;return g<b?`${g}|${b}`:`${b}|${g}`},a=h=>new P.Vector3(e.getX(h),e.getY(h),e.getZ(h)).applyMatrix4(i.matrixWorld),l=(h,f,d)=>{const m=new P.Vector3().subVectors(f,h),p=new P.Vector3().subVectors(d,h);return new P.Vector3().crossVectors(m,p).normalize()},r=o?o.count/3:e.count/3;for(let h=0;h<r;h++){let f,d,m;o?(f=o.getX(h*3),d=o.getX(h*3+1),m=o.getX(h*3+2)):(f=h*3,d=h*3+1,m=h*3+2);const p=a(f),w=a(d),y=a(m),x=l(p,w,y),g=new P.Vector3().addVectors(p,w).add(y).divideScalar(3),b=new P.Vector3().subVectors(t,g);if(x.dot(b)<=0)continue;const v=[[p,w],[w,y],[y,p]];for(const[S,E]of v){const $=u(S,E);if(s.has($)){const k=s.get($);k&&!k.normal2&&(k.normal2=x.clone(),k.faceIdx2=h)}else s.set($,{a:S.clone(),b:E.clone(),normal1:x.clone(),faceIdx1:h,mesh:i})}}return Array.from(s.values())}function Ct(i,t){return i.filter(n=>{const e=new P.Vector3().addVectors(n.a,n.b).multiplyScalar(.5),o=new P.Vector3().subVectors(t,e).normalize(),s=n.normal1.dot(o)>0;if(!n.normal2)return!0;const c=n.normal2.dot(o)>0;return s||c})}function qt(i,t,n=.99){const e=[],o=[];for(const s of i){const c=new P.Vector3().addVectors(s.a,s.b).multiplyScalar(.5),u=new P.Vector3().subVectors(t,c).normalize(),a=s.normal1.dot(u)>0,l=s.normal2?s.normal2.dot(u)>0:!0;if(a!==l||!s.normal2){e.push(s);continue}s.normal2&&s.normal1.dot(s.normal2)<n&&o.push(s)}return console.log(`classifyEdges: ${e.length} profiles, ${o.length} smooth/crease edges`),{profiles:e,smoothFiltered:o}}function lt(i,t,n,e,o=1){const s=n/2,c=e/2,u=a=>{const l=a.clone().project(t);return new P.Vector2(l.x*s*o,-l.y*c*o)};return i.map(a=>({a:u(a.a),b:u(a.b),a3d:a.a.clone(),b3d:a.b.clone(),midpoint3d:new P.Vector3().addVectors(a.a,a.b).multiplyScalar(.5),isProfile:!1,visible:!0,faceIdx:a.faceIdx1,faceIdx2:a.faceIdx2,mesh:a.mesh,isHatch:a.isHatch,normal1:a.normal1,normal2:a.normal2}))}function Ft(i,t){const n=i.a.x,e=i.a.y,o=i.b.x,s=i.b.y,c=t.a.x,u=t.a.y,a=t.b.x,l=t.b.y,r=(n-o)*(u-l)-(e-s)*(c-a);if(Math.abs(r)<1e-10)return null;const h=((n-c)*(u-l)-(e-u)*(c-a))/r,f=-((n-o)*(e-u)-(e-s)*(n-c))/r,d=.001;return h>d&&h<1-d&&f>d&&f<1-d?{t1:h,t2:f,point:new P.Vector2(n+h*(o-n),e+h*(s-e))}:null}function Dt(i){var c,u,a,l,r,h;const t=new Map,n=.01,e=(f,d)=>{const m=d.b.x-d.a.x,p=d.b.y-d.a.y,w=m*m+p*p;if(w<1e-10)return null;const y=((f.x-d.a.x)*m+(f.y-d.a.y)*p)/w;if(y<=n||y>=1-n)return null;const x=d.a.x+y*m,g=d.a.y+y*p;return(f.x-x)*(f.x-x)+(f.y-g)*(f.y-g)<1?y:null},o=new Set;for(let f=0;f<i.length;f++)for(let d=f+1;d<i.length;d++){const m=Ft(i[f],i[d]);if(m)t.has(i[f])||t.set(i[f],[]),t.has(i[d])||t.set(i[d],[]),(c=t.get(i[f]))==null||c.push({t:m.t1,point:m.point}),(u=t.get(i[d]))==null||u.push({t:m.t2,point:m.point});else{const p=e(i[f].a,i[d]);p!==null&&(t.has(i[d])||t.set(i[d],[]),(a=t.get(i[d]))==null||a.push({t:p,point:i[f].a.clone()}),o.add(i[f]),o.add(i[d]));const w=e(i[f].b,i[d]);w!==null&&(t.has(i[d])||t.set(i[d],[]),(l=t.get(i[d]))==null||l.push({t:w,point:i[f].b.clone()}),o.add(i[f]),o.add(i[d]));const y=e(i[d].a,i[f]);y!==null&&(t.has(i[f])||t.set(i[f],[]),(r=t.get(i[f]))==null||r.push({t:y,point:i[d].a.clone()}),o.add(i[f]),o.add(i[d]));const x=e(i[d].b,i[f]);x!==null&&(t.has(i[f])||t.set(i[f],[]),(h=t.get(i[f]))==null||h.push({t:x,point:i[d].b.clone()}),o.add(i[f]),o.add(i[d]))}}console.log(`T-junction detection: ${o.size} potential straggler edges`);const s=[];for(const f of i){const d=t.get(f),m=o.has(f);if(!d||d.length===0){f.isTJunctionStraggler=m,s.push(f);continue}d.sort((y,x)=>y.t-x.t);let p=f.a,w=f.a3d;for(const y of d){const x=new P.Vector3().lerpVectors(f.a3d,f.b3d,y.t);s.push({a:p.clone(),b:y.point.clone(),a3d:w.clone(),b3d:x.clone(),midpoint3d:new P.Vector3().addVectors(w,x).multiplyScalar(.5),isProfile:f.isProfile,visible:f.visible,faceIdx:f.faceIdx,mesh:f.mesh,isHatch:f.isHatch,normal1:f.normal1,isTJunctionStraggler:m}),y.t,p=y.point,w=x}s.push({a:p.clone(),b:f.b.clone(),a3d:w.clone(),b3d:f.b3d.clone(),midpoint3d:new P.Vector3().addVectors(w,f.b3d).multiplyScalar(.5),isProfile:f.isProfile,visible:f.visible,faceIdx:f.faceIdx,mesh:f.mesh,isHatch:f.isHatch,normal1:f.normal1,isTJunctionStraggler:m})}return s}function Wt(i,t,n,e){const o=(r,h,f)=>(r.x-f.x)*(h.y-f.y)-(h.x-f.x)*(r.y-f.y),s=o(i,t,n),c=o(i,n,e),u=o(i,e,t),a=s<0||c<0||u<0,l=s>0||c>0||u>0;return!(a&&l)}function Ht(i,t,n,e,o=2){const s=e.x-n.x,c=e.y-n.y,u=s*s+c*c;if(u<1e-10)return!1;const a=l=>{const r=((l.x-n.x)*s+(l.y-n.y)*c)/u,h=n.x+r*s,f=n.y+r*c;return(l.x-h)*(l.x-h)+(l.y-f)*(l.y-f)<o*o&&r>=-.01&&r<=1.01};return a(i)&&a(t)}function Rt(i,t){const n=[];for(const e of t){const o=[{a:e.a2d,b:e.b2d,name:"AB"},{a:e.b2d,b:e.c2d,name:"BC"},{a:e.c2d,b:e.a2d,name:"CA"}];for(const s of o)if(Ht(i.a,i.b,s.a,s.b)){n.push({face:e,matchedEdge:s.name,matchType:"collinear"});break}}return n}function zt(i,t,n,e,o,s,c){const u={x:e.x-t.x,y:e.y-t.y},a={x:n.x-t.x,y:n.y-t.y},l={x:i.x-t.x,y:i.y-t.y},r=u.x*u.x+u.y*u.y,h=u.x*a.x+u.y*a.y,f=u.x*l.x+u.y*l.y,d=a.x*a.x+a.y*a.y,m=a.x*l.x+a.y*l.y,p=r*d-h*h;if(Math.abs(p)<1e-10)return 1/0;const w=(d*f-h*m)/p,y=(r*m-h*f)/p;return(1-w-y)*o+y*s+w*c}function At(i,t,n=.99,e=.5){const o=[];let s=0;for(const c of i){const u=Rt(c,t);c.adjacentFaceCount=u.length;let a=!1;if(u.length===2){const l=u[0].face,r=u[1].face,h=l.normal,f=r.normal;if(h&&f){const d=h.dot(f),m=Math.abs(d);c.faceSimilarity=m;let p;d>0?p=Math.abs(l.constant-r.constant):p=Math.abs(l.constant+r.constant),m>=n&&p<e&&(a=!0,s++)}}else if(u.length>2){const l=u.map(r=>r.face).filter(r=>r.normal);if(l.length>=2){let r=!0,h=1;for(let f=1;f<l.length;f++){const d=l[0].normal.dot(l[f].normal),m=Math.abs(d);let p;if(d>0?p=Math.abs(l[0].constant-l[f].constant):p=Math.abs(l[0].constant+l[f].constant),h=Math.min(h,m),m<n||p>=e){r=!1;break}}c.faceSimilarity=h,r&&(a=!0,s++)}}a||o.push(c)}return console.log(`Geometric straggler filter: removed ${s} coplanar edges`),o}function Bt(i,t,n){const e=n.position;return Lt(i,t,e)}function Lt(i,t,n){const e=[];let o=0,s=0;for(const c of i){const u=new P.Vector2((c.a.x+c.b.x)/2,(c.a.y+c.b.y)/2),a=c.midpoint3d,l=n.distanceTo(a);let r=!1;for(const h of t){if(h.mesh===c.mesh&&(h.faceIdx===c.faceIdx||h.faceIdx===c.faceIdx2)||!Wt(u,h.a2d,h.b2d,h.c2d))continue;if(zt(u,h.a2d,h.b2d,h.c2d,h.depthA,h.depthB,h.depthC)<l-.001){r=!0,s++;break}o++}r?c.visible=!1:(c.visible=!0,e.push(c))}return console.log(`[JS] Occlusion debug: ${o} point-in-triangle hits, ${s} occluded`),e}function Nt(i,t=.5){const n=new Map,e=s=>`${Math.round(s.x/t)},${Math.round(s.y/t)}`,o=s=>{const c=e(s.a),u=e(s.b);return c<u?`${c}-${u}`:`${u}-${c}`};for(const s of i){const c=o(s);n.has(c)||n.set(c,s)}return Array.from(n.values())}function jt(i,t=1,n=50){const e=y=>`${Math.round(y.x/t)},${Math.round(y.y/t)}`,o=new Map;for(const y of i)for(const x of["a","b"]){const g=y[x],b=e(g);o.has(b)||o.set(b,{edges:[],point:{x:g.x,y:g.y}}),o.get(b).edges.push({edge:y,endpoint:x})}const s=[];for(const[y,x]of o)if(x.edges.length===1){const{edge:g,endpoint:b}=x.edges[0],v=x.point,S=b==="a"?g.b:g.a,E=v.x-S.x,$=v.y-S.y,k=Math.sqrt(E*E+$*$);if(k<.001)continue;s.push({key:y,edge:g,endpoint:b,point:v,otherPoint:S,dirX:E/k,dirY:$/k,len:k})}if(console.log(`Edge cleanup: found ${s.length} orphaned endpoints`),s.length===0)return i;const c=(y,x,g,b)=>{const v=x.x*b.y-x.y*b.x;if(Math.abs(v)<1e-4)return null;const S=g.x-y.x,E=g.y-y.y,$=(S*b.y-E*b.x)/v,k=(S*x.y-E*x.x)/v;return{t1:$,t2:k}};let u=0;const a=new Set;for(let y=0;y<s.length;y++){const x=s[y];if(a.has(x.key))continue;let g=null,b=null,v=1/0;for(let S=0;S<s.length;S++){if(y===S)continue;const E=s[S];if(a.has(E.key)||Math.sqrt((E.point.x-x.point.x)**2+(E.point.y-x.point.y)**2)>n*2)continue;const k=c({x:x.point.x,y:x.point.y},{x:x.dirX,y:x.dirY},{x:E.point.x,y:E.point.y},{x:E.dirX,y:E.dirY});if(!k||k.t1<-.1||k.t2<-.1||k.t1>n||k.t2>n)continue;const T=x.point.x+k.t1*x.dirX,W=x.point.y+k.t1*x.dirY,A=k.t1+k.t2;A<v&&(v=A,g=E,b={x:T,y:W})}if(g&&b){const S=ut(x.point,b,i,x.edge,g.edge),E=ut(g.point,b,i,x.edge,g.edge);if(S||E)continue;x.endpoint==="a"?(x.edge.a.x=b.x,x.edge.a.y=b.y):(x.edge.b.x=b.x,x.edge.b.y=b.y),g.endpoint==="a"?(g.edge.a.x=b.x,g.edge.a.y=b.y):(g.edge.b.x=b.x,g.edge.b.y=b.y),a.add(x.key),a.add(g.key),u++}}console.log(`Edge cleanup: extended ${u} pairs of edges to intersections`);let l=0;for(const y of i){const x=y.b.x-y.a.x,g=y.b.y-y.a.y;l+=Math.sqrt(x*x+g*g)}const r=l/i.length,h=r/8;console.log(`Edge cleanup: average edge length = ${r.toFixed(2)}, snap threshold = ${h.toFixed(2)}`);const f=new Map;for(const y of i)for(const x of["a","b"]){const g=y[x],b=e(g);f.has(b)||f.set(b,{edges:[],point:g}),f.get(b).edges.push({edge:y,endpoint:x})}const d=[];for(const[y,x]of f)x.edges.length===1&&d.push({key:y,...x.edges[0],point:x.point});console.log(`Edge cleanup: ${d.length} orphaned endpoints before snap pass`);let m=0;const p=new Set;for(let y=0;y<d.length;y++){const x=d[y];if(p.has(x.key))continue;let g=null,b=1/0;for(let v=0;v<d.length;v++){if(y===v)continue;const S=d[v];if(p.has(S.key))continue;const E=Math.sqrt((S.point.x-x.point.x)**2+(S.point.y-x.point.y)**2);E<b&&(b=E,g=S)}if(g&&b<h){const v=(x.point.x+g.point.x)/2,S=(x.point.y+g.point.y)/2;x.endpoint==="a"?(x.edge.a.x=v,x.edge.a.y=S):(x.edge.b.x=v,x.edge.b.y=S),g.endpoint==="a"?(g.edge.a.x=v,g.edge.a.y=S):(g.edge.b.x=v,g.edge.b.y=S),p.add(x.key),p.add(g.key),m++}}console.log(`Edge cleanup: snapped ${m} pairs of nearby orphans`);const w=d.length-m*2;return console.log(`Edge cleanup: ${w} orphaned endpoints remaining`),i}function Jt(i,t=1){const n=c=>`${Math.round(c.x/t)},${Math.round(c.y/t)}`,e=new Map;for(const c of i){const u=n(c.a),a=n(c.b);e.set(u,(e.get(u)||0)+1),e.set(a,(e.get(a)||0)+1)}const o=i.filter(c=>{const u=n(c.a),a=n(c.b),l=e.get(u)||0,r=e.get(a)||0;return l>=2||r>=2}),s=i.length-o.length;return s>0&&console.log(`Edge cleanup: removed ${s} isolated edges (orphaned at both ends)`),o}function ut(i,t,n,e,o){for(const c of n){if(c===e||c===o)continue;const u=t.x-i.x,a=t.y-i.y,l=c.b.x-c.a.x,r=c.b.y-c.a.y,h=u*r-a*l;if(Math.abs(h)<.001)continue;const f=c.a.x-i.x,d=c.a.y-i.y,m=(f*r-d*l)/h,p=(f*a-d*u)/h;if(m>.001&&m<1-.001&&p>.001&&p<1-.001)return!0}return!1}function Zt(i,t,n,e={}){const{smoothThreshold:o=.99,gridSize:s=32,skipOcclusion:c=!1,width:u=800,height:a=600,renderer:l=null,internalScale:r=4,distanceThreshold:h=.5}=e;let f=[];for(const I of i){I.updateMatrixWorld(!0);const D=Yt(I,t.position);f.push(...D)}console.log(`Extracted ${f.length} edges from ${i.length} meshes`);const{profiles:d,smoothFiltered:m}=qt(f,t.position,o);console.log(`Profiles: ${d.length}, Crease edges: ${m.length}`);const p=[...d,...m];console.log(`After smooth filter: ${p.length} edges`);let w=lt(p,t,u,a,r);if(e.hatchEdges&&e.hatchEdges.length>0){console.log(`Processing ${e.hatchEdges.length} hatch edges...`);let I=Ct(e.hatchEdges,t.position);if(e.minHatchDotProduct!==void 0){const O=e.minHatchDotProduct;I=I.filter(X=>{const H=new P.Vector3().addVectors(X.a,X.b).multiplyScalar(.5),C=new P.Vector3().subVectors(t.position,H).normalize(),N=X.normal1.dot(C);return Math.abs(N)>=O}),console.log(`Density filter: kept ${I.length} hatch edges (threshold ${O})`)}const D=lt(I,t,u,a,r);D.forEach(O=>O.isHatch=!0),w.push(...D),console.log(`Added ${D.length} visible hatch edges`)}console.time("splitIntersections");const y=Dt(w);console.timeEnd("splitIntersections"),console.log(`After splitting: ${y.length} edges`),console.time("buildProjectedFaces");const x=[],g=t.position,b=u/2,v=a/2;for(const I of i){const D=I.geometry,O=D.attributes.position,X=D.index,H=X?X.count/3:O.count/3;for(let C=0;C<H;C++){let N,Y,F;X?(N=X.getX(C*3),Y=X.getX(C*3+1),F=X.getX(C*3+2)):(N=C*3,Y=C*3+1,F=C*3+2);const R=new P.Vector3(O.getX(N),O.getY(N),O.getZ(N)).applyMatrix4(I.matrixWorld),B=new P.Vector3(O.getX(Y),O.getY(Y),O.getZ(Y)).applyMatrix4(I.matrixWorld),j=new P.Vector3(O.getX(F),O.getY(F),O.getZ(F)).applyMatrix4(I.matrixWorld),Z=new P.Vector3().subVectors(B,R),K=new P.Vector3().subVectors(j,R),_=new P.Vector3().crossVectors(Z,K).normalize(),st=new P.Vector3().addVectors(R,B).add(j).divideScalar(3),it=new P.Vector3().subVectors(g,st),ct=-_.dot(R);if(_.dot(it)<=0)continue;const ft=R.clone().project(t),dt=B.clone().project(t),xt=j.clone().project(t),Gt=new P.Vector2(ft.x*b*r,-ft.y*v*r),Ut=new P.Vector2(dt.x*b*r,-dt.y*v*r),tn=new P.Vector2(xt.x*b*r,-xt.y*v*r),nn=g.distanceTo(R),en=g.distanceTo(B),on=g.distanceTo(j);x.push({a2d:Gt,b2d:Ut,c2d:tn,depthA:nn,depthB:en,depthC:on,mesh:I,faceIdx:C,normal:_,constant:ct})}}console.timeEnd("buildProjectedFaces"),console.log(`Built ${x.length} projected faces for occlusion`),console.time("classifySilhouettes"),Kt(y,x),console.timeEnd("classifySilhouettes"),console.time("filterSmoothSplitEdges");const S=At(y,x,o,h);console.timeEnd("filterSmoothSplitEdges");let E;c?E=S:(console.time("testOcclusion (math)"),E=Bt(S,x,t),console.timeEnd("testOcclusion (math)")),console.log(`Visible edges: ${E.length}`),console.time("optimize");const $=Nt(E);console.timeEnd("optimize"),console.time("cleanup orphans");const k=jt($);console.timeEnd("cleanup orphans");const T=Jt(k);console.log(`Final edges before optimization: ${T.length}`);let W=T;if(T.length>0){let I=0;for(const X of T){const H=X.b.x-X.a.x,C=X.b.y-X.a.y;I+=Math.sqrt(H*H+C*C)}const D=I/T.length,O=D/10;console.log(`Optimization: avgLen=${D.toFixed(2)}, trim limit=${O.toFixed(2)}`),console.time("Optimize.segments"),W=U.segments(T,!1,!0,O,!1,!1,!1)._segments,console.timeEnd("Optimize.segments"),console.log(`After optimization: ${W.length} edges`)}for(const I of W)I.a.x/=r,I.a.y/=r,I.b.x/=r,I.b.y/=r;const A=W;return{edges:A,profiles:A.filter(I=>I.isProfile),allEdges:y,projectedFaces:x}}function Kt(i,t){for(const o of i){if(o.isHatch){o.isSilhouette=!1;continue}const s=(o.a.x+o.b.x)/2,c=(o.a.y+o.b.y)/2,u=o.b.x-o.a.x,a=o.b.y-o.a.y,l=Math.sqrt(u*u+a*a);if(l<.001){o.isSilhouette=!1;continue}const r=-a/l,h=u/l,f=ht(s,c,r,h,1e3,t),d=ht(s,c,-r,-h,1e3,t);o.isSilhouette=!f||!d}const e=i.filter(o=>o.isSilhouette).length;console.log(`Classified ${e} silhouette edges out of ${i.length}`)}function ht(i,t,n,e,o,s){for(const c of s)if(Qt(i,t,n,e,o,c.a2d,c.b2d,c.c2d))return!0;return!1}function Qt(i,t,n,e,o,s,c,u){return!!(ot(i,t,n,e,o,s.x,s.y,c.x,c.y)||ot(i,t,n,e,o,c.x,c.y,u.x,u.y)||ot(i,t,n,e,o,u.x,u.y,s.x,s.y))}function ot(i,t,n,e,o,s,c,u,a){const l=u-s,r=a-c,h=n*r-e*l;if(Math.abs(h)<1e-10)return!1;const f=((s-i)*r-(c-t)*l)/h,d=((s-i)*e-(c-t)*n)/h;return f>.1&&f<=o&&d>=0&&d<=1}var z=i=>Math.round(i*100)/100,tt=function(i){P.Object3D.call(this),this.node=i};tt.prototype=Object.create(P.Object3D.prototype),tt.prototype.constructor=tt;var _t=function(){var i=this,t=document.createElementNS("http://www.w3.org/2000/svg","svg"),n=document.createElementNS("http://www.w3.org/2000/svg","g"),e=document.createElementNS("http://www.w3.org/2000/svg","g"),o=document.createElementNS("http://www.w3.org/2000/svg","g"),s,c,u,a,l=new P.Color;t.setAttribute("xmlns","http://www.w3.org/2000/svg"),t.setAttribute("xmlns:inkscape","http://www.inkscape.org/namespaces/inkscape"),t.setAttribute("xmlns:xlink","http://www.w3.org/1999/xlink"),t.setAttribute("version","1.1"),n.setAttribute("inkscape:label","Silhouettes"),n.setAttribute("inkscape:groupmode","layer"),n.id="silhouettes_layer",t.appendChild(n),o.setAttribute("inkscape:label","Shading"),o.setAttribute("inkscape:groupmode","layer"),o.id="shading_layer",t.appendChild(o),e.setAttribute("inkscape:label","Edges"),e.setAttribute("inkscape:groupmode","layer"),e.id="edges_layer",t.appendChild(e),this.domElement=t,this.showSilhouettes=!0,this.showEdges=!0,this.showHatches=!0,this.silhouetteOptions={normalBuckets:12,simplifyTolerance:2,minArea:100},this.hatchOptions={baseSpacing:8,minSpacing:3,maxSpacing:40,depthFactor:.5,insetPixels:3,stroke:"black",strokeWidth:"1px",axisSettings:{x:{rotation:0,spacing:8},y:{rotation:0,spacing:8},z:{rotation:0,spacing:8}}},this.edgeOptions={stroke:"white",strokeWidth:"1px"},this.hiddenLineOptions={smoothThreshold:.99},this._glRenderer=null,this.autoClear=!0,this.setClearColor=function(h){l.set(h)},this.setPixelRatio=function(){},this.setSize=function(h,f){s=h,c=f,u=s/2,a=c/2,t.setAttribute("viewBox",-u+" "+-a+" "+s+" "+c),t.setAttribute("width",s),t.setAttribute("height",c)},this.getSize=function(){return{width:s,height:c}},this.setGLRenderer=function(h){i._glRenderer=h};function r(){for(;n.childNodes.length>0;)n.removeChild(n.childNodes[0]);for(;e.childNodes.length>0;)e.removeChild(e.childNodes[0]);for(;o.childNodes.length>0;)o.removeChild(o.childNodes[0])}this.clear=function(){r(),t.style.backgroundColor=l.getStyle()},this.renderGPULayers=function(h,f){if(!i._glRenderer){console.warn("PlotterRenderer: WebGL renderer not set. Call setGLRenderer() first.");return}const d=i._glRenderer;if(i.showSilhouettes||i.showHatches){const m=gt(d,h,f,{normalBuckets:i.silhouetteOptions.normalBuckets,simplifyTolerance:i.silhouetteOptions.simplifyTolerance,minArea:i.silhouetteOptions.minArea,insetPixels:i.showHatches?i.hatchOptions.insetPixels:0});if(i.showSilhouettes&&m.forEach(p=>{if(p.boundary.length<3)return;const w=document.createElementNS("http://www.w3.org/2000/svg","path");let y="";p.boundary.forEach((S,E)=>{const $=S.x,k=-S.y;y+=(E===0?"M":"L")+z($)+","+z(k)}),y+="Z";const x=p.normal,g=Math.floor((x.x*.5+.5)*255),b=Math.floor((x.y*.5+.5)*255),v=Math.floor((x.z*.5+.5)*255);w.setAttribute("d",y),w.setAttribute("fill",`rgba(${g},${b},${v},0.3)`),w.setAttribute("stroke","none"),n.appendChild(w)}),i.showHatches){m.sort((w,y)=>w.depth-y.depth);const p=m.map(w=>w.boundary);m.forEach((w,y)=>{let x=Vt(w,f,{baseSpacing:i.hatchOptions.baseSpacing,minSpacing:i.hatchOptions.minSpacing,maxSpacing:i.hatchOptions.maxSpacing,depthFactor:i.hatchOptions.depthFactor,insetPixels:i.hatchOptions.insetPixels,screenWidth:s,screenHeight:c,axisSettings:i.hatchOptions.axisSettings});for(let g=0;g<y;g++)x=x.flatMap(b=>$t(b,p[g]));x.forEach(g=>{const b=document.createElementNS("http://www.w3.org/2000/svg","path"),v=`M${z(g.start.x)},${z(-g.start.y)}L${z(g.end.x)},${z(-g.end.y)}`;b.setAttribute("d",v),b.setAttribute("fill","none"),b.setAttribute("stroke",i.hatchOptions.stroke),b.setAttribute("stroke-width",i.hatchOptions.strokeWidth),o.appendChild(b)})})}if(i.showEdges){const p=[];h.traverse(w=>{w.isMesh&&w.geometry&&p.push(w)}),p.length>0&&(Zt(p,f,h,{smoothThreshold:i.hiddenLineOptions.smoothThreshold,width:s,height:c}).edges||[]).forEach(x=>{const g=document.createElementNS("http://www.w3.org/2000/svg","line");g.setAttribute("x1",z(x.a.x)),g.setAttribute("y1",z(x.a.y)),g.setAttribute("x2",z(x.b.x)),g.setAttribute("y2",z(x.b.y)),g.setAttribute("stroke",i.edgeOptions.stroke),g.setAttribute("stroke-width",i.edgeOptions.strokeWidth),e.appendChild(g)})}}},this.render=function(h,f){if(!(f instanceof P.Camera)){console.error("PlotterRenderer.render: camera is not an instance of Camera.");return}}};L.PlotterRenderer=_t,L.SVGObject=tt,Object.defineProperty(L,Symbol.toStringTag,{value:"Module"})});
