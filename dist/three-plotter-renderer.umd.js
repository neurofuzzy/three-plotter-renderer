(function(X,M){typeof exports=="object"&&typeof module<"u"?M(exports,require("three")):typeof define=="function"&&define.amd?define(["exports","three"],M):(X=typeof globalThis<"u"?globalThis:X||self,M(X.ThreePlotterRenderer={},X.THREE))})(this,function(X,M){"use strict";function ft(i,t,e,n={}){const{resolution:o=2,normalBuckets:s=12,minArea:c=100,simplifyTolerance:l=2,insetPixels:a=0}=n,u=i.getSize(new M.Vector2),r=Math.floor(u.x*o),f=Math.floor(u.y*o),d=Math.round(a*o),h=Pt(i,t,e,r,f),y=kt(i,t,e,r,f);let{regionMap:m,normalLookup:b}=Vt(h,r,f);d>0&&(m=It(m,r,f,d));const{labels:p,regionCount:g}=Ot(m,r,f),x=[];for(let w=1;w<=g;w++){const P=Ct(p,r,f,w);if(P.length<3)continue;const S=et(P,l),v=Math.abs(Xt(S));if(v<c)continue;const k=Ft(p,m,b,r,f,w),$=$t(p,y,r,f,w);x.push({boundary:S.map(O=>new M.Vector2(O.x/o-u.x/2,O.y/o-u.y/2)),normal:k,depth:$,area:v/(o*o),regionId:w})}return x}function Pt(i,t,e,n,o){const s=new M.WebGLRenderTarget(n,o,{minFilter:M.NearestFilter,magFilter:M.NearestFilter}),c=new M.MeshNormalMaterial({flatShading:!0}),l=new Map,a=[];t.traverse(r=>{r.isMesh?(l.set(r,r.material),r.material=c):(r.isLineSegments||r.isLine||r.isPoints)&&r.visible&&(a.push(r),r.visible=!1)}),i.setRenderTarget(s),i.render(t,e),t.traverse(r=>{r.isMesh&&l.has(r)&&(r.material=l.get(r))});for(const r of a)r.visible=!0;i.setRenderTarget(null);const u=new Uint8Array(n*o*4);return i.readRenderTargetPixels(s,0,0,n,o,u),s.dispose(),c.dispose(),u}function kt(i,t,e,n,o){const s=new M.WebGLRenderTarget(n,o,{minFilter:M.NearestFilter,magFilter:M.NearestFilter}),c=new M.MeshDepthMaterial({depthPacking:M.RGBADepthPacking}),l=new Map,a=[];t.traverse(r=>{r.isMesh?(l.set(r,r.material),r.material=c):(r.isLineSegments||r.isLine||r.isPoints)&&r.visible&&(a.push(r),r.visible=!1)}),i.setRenderTarget(s),i.render(t,e),t.traverse(r=>{r.isMesh&&l.has(r)&&(r.material=l.get(r))});for(const r of a)r.visible=!0;i.setRenderTarget(null);const u=new Uint8Array(n*o*4);return i.readRenderTargetPixels(s,0,0,n,o,u),s.dispose(),c.dispose(),u}function $t(i,t,e,n,o){let s=0,c=0;for(let l=0;l<n;l++)for(let a=0;a<e;a++)if(i[l*e+a]===o){const u=(l*e+a)*4,r=t[u]/255,f=t[u+1]/255,d=t[u+2]/255,h=t[u+3]/255,y=r+f/256+d/65536+h/16777216;s+=y,c++}return c>0?s/c:.5}function It(i,t,e,n){let o=i;for(let s=0;s<n;s++){const c=new Uint16Array(o);for(let l=1;l<e-1;l++)for(let a=1;a<t-1;a++){const u=l*t+a;if(o[u]===0)continue;const f=o[u-1],d=o[u+1],h=o[u-t],y=o[u+t];(f===0||d===0||h===0||y===0)&&(c[u]=0)}o=c}return o}function Vt(i,t,e,n){const o=new Uint16Array(t*e),s={};let c=1;const l={};for(let a=0;a<t*e;a++){const u=a*4,r=i[u],f=i[u+1],d=i[u+2];if(r<5&&f<5&&d<5){o[a]=0;continue}const h=r/255*2-1,y=f/255*2-1,m=d/255*2-1,b=4,p=Math.round(r/b)*b,g=Math.round(f/b)*b,x=Math.round(d/b)*b,w=`${p}|${g}|${x}`;l[w]||(l[w]=c,s[c]=new M.Vector3(h,y,m).normalize(),c++),o[a]=l[w]}return{regionMap:o,normalLookup:s}}function Ot(i,t,e){const n=new Uint32Array(t*e),o=[];let s=1;function c(r){return o[r]!==r&&(o[r]=c(o[r])),o[r]}function l(r,f){const d=c(r),h=c(f);d!==h&&(o[h]=d)}for(let r=0;r<e;r++)for(let f=0;f<t;f++){const d=r*t+f,h=i[d];if(h===0)continue;const y=[];if(f>0&&i[d-1]===h&&n[d-1]>0&&y.push(n[d-1]),r>0&&i[d-t]===h&&n[d-t]>0&&y.push(n[d-t]),y.length===0)n[d]=s,o[s]=s,s++;else{const m=Math.min(...y);n[d]=m;for(const b of y)l(m,b)}}const a={};let u=0;for(let r=0;r<t*e;r++){if(n[r]===0)continue;const f=c(n[r]);a[f]===void 0&&(u++,a[f]=u),n[r]=a[f]}return{labels:n,regionCount:u}}function Ct(i,t,e,n){const o=[];let s=-1,c=-1;t:for(let y=0;y<e;y++)for(let m=0;m<t;m++)if(i[y*t+m]===n&&(m===0||i[y*t+m-1]!==n||y===0||i[(y-1)*t+m]!==n)){s=m,c=y;break t}if(s===-1)return o;const l=[1,1,0,-1,-1,-1,0,1],a=[0,1,1,1,0,-1,-1,-1];let u=s,r=c,f=7;const d=t*e*2;let h=0;do{o.push({x:u,y:r});let y=!1;for(let m=0;m<8;m++){const b=(f+6+m)%8,p=u+l[b],g=r+a[b];if(p>=0&&p<t&&g>=0&&g<e&&i[g*t+p]===n){u=p,r=g,f=b,y=!0;break}}if(!y)break;h++}while((u!==s||r!==c)&&h<d);return o}function Ft(i,t,e,n,o,s){let c=0,l=0,a=0;for(let h=0;h<o;h++)for(let y=0;y<n;y++)i[h*n+y]===s&&(c+=y,l+=h,a++);if(a===0)return new M.Vector3(0,0,1);const u=Math.round(c/a),f=Math.round(l/a)*n+u,d=t[f];return e[d]||new M.Vector3(0,0,1)}function et(i,t){if(i.length<3)return i;let e=0,n=0;const o=i[0],s=i[i.length-1];for(let c=1;c<i.length-1;c++){const l=Tt(i[c],o,s);l>e&&(e=l,n=c)}if(e>t){const c=et(i.slice(0,n+1),t),l=et(i.slice(n),t);return c.slice(0,-1).concat(l)}else return[o,s]}function Tt(i,t,e){const n=e.x-t.x,o=e.y-t.y,s=n*n+o*o;if(s<1e-10)return Math.sqrt((i.x-t.x)**2+(i.y-t.y)**2);const c=((i.x-t.x)*n+(i.y-t.y)*o)/s,l=t.x+c*n,a=t.y+c*o;return Math.sqrt((i.x-l)**2+(i.y-a)**2)}function Xt(i){let t=0;for(let e=0;e<i.length;e++){const n=(e+1)%i.length;t+=i[e].x*i[n].y,t-=i[n].x*i[e].y}return t/2}function Yt(i,t,e,n){const o=e/2,s=n/2,c=new M.Vector3(0,1,0),l=new M.Vector3(0,0,1);let a;Math.abs(i.y)>.9?a=l.clone():(a=new M.Vector3().crossVectors(c,i).normalize(),a.lengthSq()<.01&&(a=l.clone()));const u=new M.Vector3(0,0,0),r=a.clone().multiplyScalar(100),f=u.clone().project(t),d=r.clone().project(t),h=new M.Vector2(f.x*o,-f.y*s),m=new M.Vector2(d.x*o,-d.y*s).clone().sub(h).normalize(),p=a.clone().multiplyScalar(1e5).clone().project(t);let g=null;return Math.abs(p.x)<100&&Math.abs(p.y)<100&&p.z<1&&(g=new M.Vector2(p.x*o,-p.y*s)),{direction:m,vanishingPoint:g}}function dt(i,t,e={}){const{baseSpacing:n=8,minSpacing:o=3,maxSpacing:s=20,depthFactor:c=.5,screenWidth:l=1200,screenHeight:a=800,axisSettings:u={}}=e,{boundary:r,normal:f,depth:d=.5}=i;if(r.length<3)return[];const h=Math.abs(f.x),y=Math.abs(f.y),m=Math.abs(f.z);let b="y";h>=y&&h>=m?b="x":m>=y&&m>=h&&(b="z");const p=u[b]||{},g=p.rotation||0,x=p.spacing;console.log(`[Hatch] normal=(${f.x.toFixed(2)}, ${f.y.toFixed(2)}, ${f.z.toFixed(2)}) => axis=${b}, rotation=${g}, spacing=${x}`);const{direction:w,vanishingPoint:P}=Yt(f,t,l,a);let S=w;if(g!==0){const Y=g*(Math.PI/180),H=Math.cos(Y),W=Math.sin(Y);S=new M.Vector2(w.x*H-w.y*W,w.x*W+w.y*H)}const v=new M.Vector2(-S.y,S.x),$=Math.max(o,Math.min(s,(x!==void 0?x:n)+d*c*(s-o)));let O=1/0,C=-1/0,R=1/0,V=-1/0;for(const Y of r)O=Math.min(O,Y.x),C=Math.max(C,Y.x),R=Math.min(R,Y.y),V=Math.max(V,Y.y);const z=(O+C)/2,F=(R+V)/2,T=new M.Vector2(z,F),D=Math.sqrt((C-O)**2+(V-R)**2),A=[];if(P&&Math.abs(g)<5&&P.distanceTo(T)<D*5){const Y=P.distanceTo(T),H=Math.ceil(D/$)*2,L=Math.atan2(D,Y)*2/H,j=Math.atan2(F-P.y,z-P.x);for(let Z=-H;Z<=H;Z++){const Q=j+Z*L,G=new M.Vector2(Math.cos(Q),Math.sin(Q)),at=P.clone(),lt=P.clone().add(G.clone().multiplyScalar(Y*10)),ut=nt({start:at,end:lt},r);A.push(...ut)}}else{const Y=Math.ceil(D/$)+2;for(let H=-Y;H<=Y;H++){const W=v.clone().multiplyScalar(H*$),L=T.clone().add(W),j=L.clone().add(S.clone().multiplyScalar(-D)),Z=L.clone().add(S.clone().multiplyScalar(D)),Q=nt({start:j,end:Z},r);A.push(...Q)}}return A}function nt(i,t){const e=[],n=t.length;for(let s=0;s<n;s++){const c=t[s],l=t[(s+1)%n],a=zt(i.start.x,i.start.y,i.end.x,i.end.y,c.x,c.y,l.x,l.y);a&&e.push({point:new M.Vector2(a.x,a.y),t:a.t})}if(e.length<2)return[];e.sort((s,c)=>s.t-c.t);const o=[];for(let s=0;s<e.length-1;s++){const c=(e[s].point.x+e[s+1].point.x)/2,l=(e[s].point.y+e[s+1].point.y)/2;U(c,l,t)&&o.push({start:e[s].point,end:e[s+1].point})}return o}function ht(i,t){const e=[],n=t.length,o=U(i.start.x,i.start.y,t),s=U(i.end.x,i.end.y,t);e.push({point:i.start.clone(),t:0,inside:o});for(let a=0;a<n;a++){const u=t[a],r=t[(a+1)%n],f=qt(i.start.x,i.start.y,i.end.x,i.end.y,u.x,u.y,r.x,r.y);f&&f.t>0&&f.t<1&&e.push({point:new M.Vector2(f.x,f.y),t:f.t,inside:null})}e.push({point:i.end.clone(),t:1,inside:s}),e.sort((a,u)=>a.t-u.t);const c=[e[0]];for(let a=1;a<e.length;a++)e[a].t-c[c.length-1].t>1e-4&&c.push(e[a]);if(c.length<2)return[i];const l=[];for(let a=0;a<c.length-1;a++){const u=(c[a].t+c[a+1].t)/2,r=i.start.x+u*(i.end.x-i.start.x),f=i.start.y+u*(i.end.y-i.start.y);U(r,f,t)||l.push({start:c[a].point.clone(),end:c[a+1].point.clone()})}return l}function qt(i,t,e,n,o,s,c,l){const a=(i-e)*(s-l)-(t-n)*(o-c);if(Math.abs(a)<1e-10)return null;const u=((i-o)*(s-l)-(t-s)*(o-c))/a,r=-((i-e)*(t-s)-(t-n)*(i-o))/a;return u>=0&&u<=1&&r>=0&&r<=1?{x:i+u*(e-i),y:t+u*(n-t),t:u}:null}function zt(i,t,e,n,o,s,c,l){const a=(i-e)*(s-l)-(t-n)*(o-c);if(Math.abs(a)<1e-10)return null;const u=((i-o)*(s-l)-(t-s)*(o-c))/a,r=-((i-e)*(t-s)-(t-n)*(i-o))/a;return r>=0&&r<=1?{x:i+u*(e-i),y:t+u*(n-t),t:u}:null}function U(i,t,e){let n=!1;const o=e.length;for(let s=0,c=o-1;s<o;c=s++){const l=e[s].x,a=e[s].y,u=e[c].x,r=e[c].y;a>t!=r>t&&i<(u-l)*(t-a)/(r-a)+l&&(n=!n)}return n}const gt=.001;class I{constructor(t,e){this.x=t,this.y=e}static clone(t){return new I(t.x,t.y)}}class ot{constructor(t,e,n,o){this.minX=t,this.minY=e,this.maxX=n,this.maxY=o}width(){return Math.abs(this.maxX-this.minX)}height(){return Math.abs(this.maxY-this.minY)}}class At{constructor(t=0){this.r=t}}class q{constructor(t,e){this.a=t,this.b=e,this.tags={}}static isEqual(t,e){return E.pointsEqual(t.a,e.a)&&E.pointsEqual(t.b,e.b)||E.pointsEqual(t.b,e.a)&&E.pointsEqual(t.a,e.b)}static clone(t){return new q(new I(t.a.x,t.a.y),new I(t.b.x,t.b.y))}}class Dt{constructor(){this.pivot={x:0,y:0},this.rotation=0,this.isOpen=!0,this.isGroup=!1,this.isStrong=!1,this._makeAbsolute=t=>{let e=this.rotation*Math.PI/180;t.forEach((n,o)=>{const s={x:n.x,y:n.y};E.rotatePoint(s,e),s.x+=this.pivot.x,s.y+=this.pivot.y,t[o]=s})},this._makeSegsAbsolute=t=>{let e=this.rotation*Math.PI/180;t.forEach(n=>{const o={x:n.a.x,y:n.a.y},s={x:n.b.x,y:n.b.y};E.rotatePoint(o,e),E.rotatePoint(s,e),E.addToPoint(o,this.pivot),E.addToPoint(s,this.pivot),n.a=o,n.b=s})}}toPoints(t=!1){throw"not implemented"}toSegments(t=!1){throw"not implemented"}getBoundingBox(t=!1){const e=new ot(1e6,1e6,-1e6,-1e6);return this.toPoints(t).forEach(o=>{e.minX=Math.min(e.minX,o.x),e.minY=Math.min(e.minY,o.y),e.maxX=Math.max(e.maxX,o.x),e.maxY=Math.max(e.maxY,o.y)}),e}getBoundingCircle(){const t=new At;return this.toPoints(!0).forEach(n=>{t.r=Math.max(t.r,Math.sqrt(n.x*n.x+n.y*n.y))}),t}}class K extends Dt{constructor(t){super(),this._segments=t}add(...t){this._segments=this._segments.concat(t)}toPoints(t=!1){return this.toSegments(t).reduce((e,n)=>n?e.concat([n.a,n.b]):e,[])}toSegments(t=!1){let e=this._segments.reduce((n,o)=>o?n.concat(q.clone(o)):n,[]);return t||this._makeSegsAbsolute(e),e}bake(){}result(){return K.clone(this)}static clone(t){let e=t._segments,n=[],o=e.length;for(;o--;)n.unshift(q.clone(e[o]));let s=new K(n);return s.pivot.x=t.pivot.x,s.pivot.y=t.pivot.y,s.rotation=t.rotation,s}}class E{static lerp(t,e,n){return(1-n)*t+n*e}static angleBetween(t,e){return Math.atan2(e.y-t.y,e.x-t.x)}static sameAngle(t,e){let n=E.angleBetween(t.a,t.b),o=E.angleBetween(e.a,e.b);return Math.abs(n-o)<gt}static sameAngleRev(t,e){let n=E.angleBetween(t.a,t.b),o=E.angleBetween(e.b,e.a);return Math.abs(n-o)<gt}static lerpPoints(t,e,n){return{x:E.lerp(t.x,e.x,n),y:E.lerp(t.y,e.y,n)}}static rotatePointDeg(t,e){E.rotatePoint(t,e*Math.PI/180)}static rotatePoint(t,e){const n=Math.cos(e),o=Math.sin(e),s=t.y,c=t.x;t.y=n*s-o*c,t.x=o*s+n*c}static rotatePoints(t,...e){e.forEach(n=>{E.rotatePoint(n,t)})}static rotatePointsDeg(t,...e){let n=t*Math.PI/180;e.forEach(o=>{E.rotatePoint(o,n)})}static outerTangents(t,e,n,o){var s=n.x-t.x,c=n.y-t.y,l=Math.sqrt(s*s+c*c);if(l<=Math.abs(o-e))return[];var a=Math.atan2(c,s),u=Math.acos((e-o)/l);return[new q({x:t.x+e*Math.cos(a+u),y:t.y+e*Math.sin(a+u)},{x:n.x+o*Math.cos(a+u),y:n.y+o*Math.sin(a+u)}),new q({x:t.x+e*Math.cos(a-u),y:t.y+e*Math.sin(a-u)},{x:n.x+o*Math.cos(a-u),y:n.y+o*Math.sin(a-u)})]}static cartesian2Polar(t){const e=Math.sqrt(t.x*t.x+t.y*t.y),n=Math.atan2(t.y,t.x);t.x=e,t.y=n}static pointsEqual(t,e,n=1){return Math.round(t.x*1e4/n)==Math.round(e.x*1e4/n)&&Math.round(t.y*1e4/n)==Math.round(e.y*1e4/n)}static distanceBetween(t,e){const n=e.x-t.x,o=e.y-t.y;return Math.sqrt(n*n+o*o)}static distanceBetweenSquared(t,e){const n=e.x-t.x,o=e.y-t.y;return n*n+o*o}static interpolatePoints(t,e,n){let o=[{x:t.x,y:t.y}],s=1/n,c=(e.x-t.x)*s,l=(e.y-t.y)*s;for(var a=1;a<n;a++)o.push(new I(t.x+c*a,t.y+l*a));return o.push({x:e.x,y:e.y}),o}static averagePoints(...t){let e=new I(0,0);return t.forEach(n=>{e.x+=n.x,e.y+=n.y}),e.x/=t.length,e.y/=t.length,e}static addToPoint(t,e){t.x+=e.x,t.y+=e.y}static subFromPoint(t,e){t.x-=e.x,t.y-=e.y}static subdivideByDistance(t,e,n){if(n===0)return[t,e];let o=[{x:t.x,y:t.y}],s=E.distanceBetween(t,e),c=n/s,l=Math.floor(1/c),a=s%n;n+=a/l,c=n/s;let u=c,r=1,f=(e.x-t.x)*c,d=(e.y-t.y)*c;for(;u<1;)o.push(new I(t.x+f*r,t.y+d*r)),u+=c,r++;return o.push({x:e.x,y:e.y}),o}static segmentsConnected(t,e,n=1){return E.pointsEqual(t.b,e.a,n)||E.pointsEqual(t.a,e.b,n)}static segmentsToPoints(t){let e=t.reduce((o,s)=>o.concat(s.a,s.b),[]),n=e.length;for(;n--;){let o=e[n];n>0&&E.pointsEqual(o,e[n-1])&&e.splice(n,1)}return e}static polygonArea(t){let e=0,n=t.length-1;for(var o=0;o<t.length;o++)e+=t[o].x*t[n].y,e-=t[n].x*t[o].y,n=o;return e/2}static pointsBoundingBox(t){const e=new ot(1e6,1e6,-1e6,-1e6);return t.forEach(n=>{e.minX=Math.min(e.minX,n.x),e.minY=Math.min(e.minY,n.y),e.maxX=Math.max(e.maxX,n.x),e.maxY=Math.max(e.maxY,n.y)}),e}static boundingBoxesBoundingBox(t){const e=new ot(1e6,1e6,-1e6,-1e6);return t.forEach(n=>{e.minX=Math.min(e.minX,n.minX),e.minY=Math.min(e.minY,n.minY),e.maxX=Math.max(e.maxX,n.maxX),e.maxY=Math.max(e.maxY,n.maxY)}),e}static segmentsBoundingBox(t){const e=[];return t.forEach(n=>{e.push(n.a),e.push(n.b)}),E.pointsBoundingBox(e)}static boundingBoxesIntersect(t,e){return t.maxX>=e.minX&&t.maxY>=e.minY&&t.minX<=e.maxX&&t.minY<=e.maxY}static polygonIsClockwise(t){return E.polygonArea(t)>0}static ccw(t,e,n){return(n.y-t.y)*(e.x-t.x)>(e.y-t.y)*(n.x-t.x)}static segmentsIntersect(t,e){const n=E.ccw;return n(t.a,e.a,e.b)!=n(t.b,e.a,e.b)&&n(t.a,t.b,e.a)!=n(t.a,t.b,e.b)}static segmentSegmentIntersect(t,e,n=!1){const o=t.a.x,s=t.a.y,c=t.b.x,l=t.b.y,a=e.a.x,u=e.a.y,r=e.b.x,f=e.b.y,d=c-o,h=l-s,y=r-a,m=f-u,b=(-h*(o-a)+d*(s-u))/(-y*h+d*m),p=(y*(s-u)-m*(o-a))/(-y*h+d*m);if(b>=0&&b<=1&&p>=0&&p<=1){const g=o+p*d,x=s+p*h;let w={x:g,y:x};return n&&(E.pointsEqual(w,e.a)||E.pointsEqual(w,e.b)||E.pointsEqual(w,t.a)||E.pointsEqual(w,t.b))?void 0:w}return null}static segmentSegmentsIntersections(t,e,n=!1){let o=[];return e.forEach(s=>{if(s==t)return;let c=E.segmentSegmentIntersect(t,s,n);c&&o.push(c)}),o}static dot(t,e){return t.x*e.x+t.y*e.y}static cross(t,e){return t.x*e.y-t.y*e.x}static lineSide(t,e,n){return Math.round(((n.x-e.x)*(t.y-e.y)-(n.y-e.y)*(t.x-e.x))*100)/100}static sub(t,e){return new I(t.x-e.x,t.y-e.y)}static add(t,e){return new I(t.x+e.x,t.y+e.y)}static closestPtPointSegment(t,e){var n=E.sub(e.b,e.a),o=E.sub(t,e.a),s=E.dot(o,n);if(s<0)t=e.a;else{var c=E.dot(n,n);s>=c?t=e.b:(s/=c,o.x=e.a.x+s*n.x,o.y=e.a.y+s*n.y,t=o)}return I.clone(t)}static distancePointSegment(t,e){return E.distanceBetween(t,E.closestPtPointSegment(t,e))}static pointWithinBoundingBox(t,e){return t.x>=e.minX&&t.y>=e.minY&&t.x<=e.maxX&&t.y<=e.maxY}static pointWithinPolygon(t,e,n){const o=E.segmentsBoundingBox(e);if(!this.pointWithinBoundingBox(t,o))return!1;let s=new I(1e5,1e5),c=new q(s,t),l=E.segmentSegmentsIntersections(c,e);return l.length%2!=0&&n&&E.pointsEqual(t,l[0])?!1:l.length%2!=0}static segmentWithinPolygon(t,e){let n=this.pointWithinPolygon(t.a,e,!1),o=this.pointWithinPolygon(t.b,e,!1),s=this.pointWithinPolygon(t.a,e,!0),c=this.pointWithinPolygon(t.b,e,!0);return s&&c||s&&o||c&&n}static sign(t,e,n){return(t.x-n.x)*(e.y-n.y)-(e.x-n.x)*(t.y-n.y)}static pointWithinTriangle(t,e,n,o,s){const c=E.sign(t,e,n),l=E.sign(t,n,o),a=E.sign(t,o,e),u=c<0||l<0||a<0,r=c>0||l>0||a>0;if(!(u&&r)&&s){let f={a:e,b:n,tags:null};if(E.distancePointSegment(t,f)<1||(f.a=n,f.b=o,E.distancePointSegment(t,f)<1)||(f.a=o,f.b=e,E.distancePointSegment(t,f)<1))return!1}return!(u&&r)}static segmentWithinTriangle(t,e,n,o){let s=this.pointWithinTriangle(t.a,e,n,o,!1),c=this.pointWithinTriangle(t.b,e,n,o,!1),l=this.pointWithinTriangle(t.a,e,n,o,!0),a=this.pointWithinTriangle(t.b,e,n,o,!0);return E.averagePoints(t.a,t.b),l&&a||l&&c||a&&s||s&&c}static pointsToClosedPolySegments(...t){let e=[];for(let n=0;n<t.length;n++)e.push(new q(t[n],n<t.length-1?t[n+1]:t[0]));return e}static polygonWithinPolygon(t,e){const n=E.segmentsBoundingBox(t),o=E.segmentsBoundingBox(e);if(!E.boundingBoxesIntersect(n,o))return!1;new I(o.minX-100,o.minY-100);for(let s=0;s<t.length;s++){let c=t[s];if(E.segmentSegmentsIntersections(c,e).length%2==0)return!1}return!0}static splinePoints(t,e,n,o=0){let s=l=>{let a=[l[0]];for(let u=0;u<l.length-1;u++){let r=new I(0,0);u+1<l.length*.4?(r.x=(l[u].x*40+l[u+1].x*60)*.01,r.y=(l[u].y*40+l[u+1].y*60)*.01):u+1>l.length*.6?(r.x=(l[u].x*60+l[u+1].x*40)*.01,r.y=(l[u].y*60+l[u+1].y*40)*.01):(r.x=(l[u].x+l[u+1].x)*.5,r.y=(l[u].y+l[u+1].y)*.5),a.push(r)}return a.push(l[l.length-1]),a},c=[t,e,n];for(let l=0;l<o;l++)c=s(c);return c}}class J{static getSegsAndConnections(t,e=!1,n=!1){let o={},s=[],c={},l=a=>{let u=`${Math.round(a.x*1)}|${Math.round(a.y*1)}`;return c[u]=a,u};if(e){let a=t.reduce((f,d)=>f.concat(d.a,d.b),[]),u=a.length;for(;u--;){let f=a[u],d=u;for(;d--;){let h=a[d];if(E.pointsEqual(f,h)){a.splice(u,1);break}}}let r=t.length;for(;r--;){let f=t[r],d=[];if(a.forEach(h=>{E.distancePointSegment(h,f)<.1&&!E.pointsEqual(h,f.a)&&!E.pointsEqual(h,f.b)&&d.push(h)}),d.length){d.sort((m,b)=>{const p=E.distanceBetweenSquared(m,f.a),g=E.distanceBetweenSquared(b,f.a);return p<g?-1:p>g?1:0});const h=[];let y=f.a;for(let m=0;m<d.length;m++){let b=d[m];h.push(new q(y,b)),y=b}h.push(new q(y,f.b)),t.splice(r,1,...h)}}}if(n){let a=t.length;for(;a--;){let u=a,r=!1;for(;u--;){let f=t[a],d=t[u],h=E.segmentSegmentIntersect(f,d,!0);h&&(r=!0,t.splice(a,1,new q(I.clone(f.a),I.clone(h)),new q(I.clone(h),I.clone(f.b))),t.splice(u,1,new q(I.clone(d.a),I.clone(h)),new q(I.clone(h),I.clone(d.b))))}r&&(a=t.length)}}return t.forEach(a=>{let u=l(a.a),r=l(a.b);o[u]||(o[u]=[]),o[r]||(o[r]=[]),o[u].indexOf(r)===-1&&o[u].push(r),o[r].indexOf(u)===-1&&o[r].push(u),s.indexOf(u)===-1&&s.push(u),s.indexOf(r)===-1&&s.push(r)}),{originalPts:c,pts:s,cxs:o}}static pathOrder(t,e=!1,n=!1){let o=[],{originalPts:s,pts:c,cxs:l}=J.getSegsAndConnections(t,e,n),a=r=>s[r],u=(r,f)=>l[r].length>l[f].length?1:l[r].length<l[f].length?-1:0;for(c.sort(u);c.length;){c.sort(u);let r=c.shift();for(;r;)if(l[r].length){l[r].sort(u);let f=l[r].shift(),d=l[f].indexOf(r);d!==-1&&l[f].splice(d,1),o.push(new q(a(r),a(f))),l[r].length&&c.unshift(r),r=f}else r=null}return o}static getEndingSegmentPoints(t,e=0){t=t.concat(),t=J.pathOrder(t,!0,!0);let{originalPts:n,pts:o,cxs:s}=J.getSegsAndConnections(t,!0),c=u=>n[u];const l=o.filter(u=>s[u].length===1),a=[];return l.forEach(u=>{const r=I.clone(c(u));if(e===0){a.push(r);return}const f=c(s[u]),d=E.angleBetween(f,r),h=new I(0,e);E.rotatePoint(h,Math.PI*.5-d),E.addToPoint(r,h),a.push(r)}),a}static getFills(t,e=5){t=t.concat();let{originalPts:n,cxs:o}=J.getSegsAndConnections(t,!0,!0),s=g=>{let x=`${Math.round(g.x*1)}|${Math.round(g.y*1)}`;return n[x]=g,x},c=[],l=[],a=1e5,u=1e5,r=-1e5,f=-1e5,d=1e5,h=1e5,y=[];for(let g in n){let x=n[g];y.push(x),a=Math.min(a,x.x),u=Math.min(u,x.y),r=Math.max(r,x.x),f=Math.max(f,x.y)}y.sort((g,x)=>g.x<x.x?-1:g.x>x.x?1:0),y.forEach((g,x)=>{if(x>0){let w=y[x-1],P=Math.round(Math.abs(g.x-w.x));P>1&&(d=Math.min(d,P))}}),y.sort((g,x)=>g.y<x.y?-1:g.y>x.y?1:0),y.forEach((g,x)=>{if(x>0){let w=y[x-1],P=Math.round(Math.abs(g.y-w.y));P>1&&(h=Math.min(h,P))}});let m=d*.5,b=h*.5,p=[];for(let g=u;g<f;g+=h)for(let x=a;x<r;x+=d)p.push(new I(x+m,g+b));return p.forEach(g=>{let x=[];if(y.forEach(S=>{let v=E.distanceBetween(S,g);if(v<Math.max(d,h)*e){let k=E.angleBetween(S,g);x.push({pt:S,dist:v,ang:k})}}),x.length<4)return;let w=x.length;for(;w--;){let S=x[w].pt,v=new q(g,S);E.segmentSegmentsIntersections(v,t,!0).length>0&&x.splice(w,1)}for(x.sort((S,v)=>S.ang<v.ang?-1:S.ang>v.ang?1:0),w=x.length;w--;){let S=x[w].pt,v=s(S),k=x.length,$=!1;for(;k--;){if(w===k)continue;let O=x[k].pt,C=s(O);if(o[v].indexOf(C)===-1){$=!0;break}}$||x.splice(w,1)}let P=!0;if(x.forEach((S,v)=>{let k=x[(v+1)%x.length],$=s(S.pt),O=s(k.pt);o[$].indexOf(O)===-1&&(P=!1)}),P){let S=x.map($=>$.pt),v=E.averagePoints(...S),k=s(v);c.indexOf(k)===-1&&(c.push(k),l.push(S))}}),l}}class _{static segmentCollections(t,e=!1,n=!0,o=1,s=!1,c=!1,l=!1){let a=t.reduce((u,r)=>u.concat(r.toSegments()),[]);return _.segments(a,e,n,o,s,c,l)}static segmentCollectionsPathOrder(t,e=!1,n=!1){let o=t.reduce((s,c)=>s.concat(c.toSegments()),[]);return new K(J.pathOrder(o,e,n))}static segments(t,e=!1,n=!0,o=1,s=!1,c=!1,l=!1){return t=_._segments(t,e,n,o),s&&(t=J.pathOrder(t,c,l)),new K(t)}static _segments(t,e,n,o){const s=t;for(t=[];s.length;){let l=s.shift(),a=t.length,u=!1;for(;a--;){const r=t[a];if(q.isEqual(l,r)){u=!0;break}}u||t.push(l)}if(!e)for(let l=0;l<3;l++){let a=t.length;for(;a--;){let u=t[a],r,f,d,h,y;for(let m=a-1;m>=0;m--){let b=t[m],p=!1,g=!1;if(E.sameAngle(u,b)?(p=!0,r=I.clone(u.a),f=I.clone(u.b),d=I.clone(b.a),h=I.clone(b.b)):E.sameAngleRev(u,b)&&(p=g=!0,r=I.clone(u.b),f=I.clone(u.a),d=I.clone(b.a),h=I.clone(b.b)),p&&(y=E.angleBetween(r,f),E.rotatePoints(y,r,f,d,h),Math.abs(r.y-d.y)<.1&&f.x>=d.x-1e-4&&r.x<=h.x+1e-4)){r.x<d.x&&(g?b.a=u.b:b.a=u.a),f.x>h.x&&(g?b.b=u.a:b.b=u.b),t.splice(a,1);break}}}}let c=t.length;for(;c--;){let l=t[c];if(!l){t.splice(c,1);continue}if(n&&E.distanceBetween(l.a,l.b)<o){t.splice(c,1);continue}}return console.log(`[JS] Optimize: ${s.length+t.length} -> ${t.length} segments`),t}}function xt(i,t){const e=i.geometry,n=e.attributes.position,o=e.index;if(!n)return[];const s=new Map,c=1e3,l=(f,d)=>{const h=Math.round(f.x*c),y=Math.round(f.y*c),m=Math.round(f.z*c),b=Math.round(d.x*c),p=Math.round(d.y*c),g=Math.round(d.z*c),x=`${h},${y},${m}`,w=`${b},${p},${g}`;return x<w?`${x}|${w}`:`${w}|${x}`},a=f=>new M.Vector3(n.getX(f),n.getY(f),n.getZ(f)).applyMatrix4(i.matrixWorld),u=(f,d,h)=>{const y=new M.Vector3().subVectors(d,f),m=new M.Vector3().subVectors(h,f);return new M.Vector3().crossVectors(y,m).normalize()},r=o?o.count/3:n.count/3;for(let f=0;f<r;f++){let d,h,y;o?(d=o.getX(f*3),h=o.getX(f*3+1),y=o.getX(f*3+2)):(d=f*3,h=f*3+1,y=f*3+2);const m=a(d),b=a(h),p=a(y),g=u(m,b,p),x=new M.Vector3().addVectors(m,b).add(p).divideScalar(3),w=new M.Vector3().subVectors(t,x);if(g.dot(w)<=0)continue;const P=[[m,b],[b,p],[p,m]];for(const[S,v]of P){const k=l(S,v);if(s.has(k)){const $=s.get(k);$&&!$.normal2&&($.normal2=g.clone(),$.faceIdx2=f)}else s.set(k,{a:S.clone(),b:v.clone(),normal1:g.clone(),faceIdx1:f,mesh:i})}}return Array.from(s.values())}function yt(i,t){return i.filter(e=>{const n=new M.Vector3().addVectors(e.a,e.b).multiplyScalar(.5),o=new M.Vector3().subVectors(t,n).normalize(),s=e.normal1.dot(o)>0;if(!e.normal2)return!0;const c=e.normal2.dot(o)>0;return s||c})}function pt(i,t,e=.99){const n=[],o=[];for(const s of i){const c=new M.Vector3().addVectors(s.a,s.b).multiplyScalar(.5),l=new M.Vector3().subVectors(t,c).normalize(),a=s.normal1.dot(l)>0,u=s.normal2?s.normal2.dot(l)>0:!0;if(a!==u||!s.normal2){n.push(s);continue}s.normal2&&s.normal1.dot(s.normal2)<e&&o.push(s)}return console.log(`classifyEdges: ${n.length} profiles, ${o.length} smooth/crease edges`),{profiles:n,smoothFiltered:o}}function st(i,t,e,n,o=1){const s=e/2,c=n/2,l=a=>{const u=a.clone().project(t);return new M.Vector2(u.x*s*o,-u.y*c*o)};return i.map(a=>({a:l(a.a),b:l(a.b),a3d:a.a.clone(),b3d:a.b.clone(),midpoint3d:new M.Vector3().addVectors(a.a,a.b).multiplyScalar(.5),isProfile:!1,visible:!0,faceIdx:a.faceIdx1,faceIdx2:a.faceIdx2,mesh:a.mesh,isHatch:a.isHatch,normal1:a.normal1,normal2:a.normal2}))}class Ht{constructor(t){this.cellSize=t,this.cells=new Map}getCellKey(t,e){const n=Math.floor(t/this.cellSize),o=Math.floor(e/this.cellSize);return`${n},${o}`}getCellsCrossed(t){const e=new Set,n=Math.abs(t.b.x-t.a.x),o=Math.abs(t.b.y-t.a.y),s=Math.max(n,o)/this.cellSize+1;for(let c=0;c<=s;c++){const l=c/s,a=t.a.x+l*(t.b.x-t.a.x),u=t.a.y+l*(t.b.y-t.a.y);e.add(this.getCellKey(a,u))}return Array.from(e)}insert(t){var n;const e=this.getCellsCrossed(t);for(const o of e)this.cells.has(o)||this.cells.set(o,[]),(n=this.cells.get(o))==null||n.push(t)}query(t){return this.cells.get(t)||[]}getAllCells(){return Array.from(this.cells.keys())}clear(){this.cells.clear()}}function Rt(i,t){const e=i.a.x,n=i.a.y,o=i.b.x,s=i.b.y,c=t.a.x,l=t.a.y,a=t.b.x,u=t.b.y,r=(e-o)*(l-u)-(n-s)*(c-a);if(Math.abs(r)<1e-10)return null;const f=((e-c)*(l-u)-(n-l)*(c-a))/r,d=-((e-o)*(n-l)-(n-s)*(e-c))/r,h=.001;return f>h&&f<1-h&&d>h&&d<1-h?{t1:f,t2:d,point:new M.Vector2(e+f*(o-e),n+f*(s-n))}:null}function mt(i){var c,l,a,u,r,f;const t=new Map,e=.01,n=(d,h)=>{const y=h.b.x-h.a.x,m=h.b.y-h.a.y,b=y*y+m*m;if(b<1e-10)return null;const p=((d.x-h.a.x)*y+(d.y-h.a.y)*m)/b;if(p<=e||p>=1-e)return null;const g=h.a.x+p*y,x=h.a.y+p*m;return(d.x-g)*(d.x-g)+(d.y-x)*(d.y-x)<1?p:null},o=new Set;for(let d=0;d<i.length;d++)for(let h=d+1;h<i.length;h++){const y=Rt(i[d],i[h]);if(y)t.has(i[d])||t.set(i[d],[]),t.has(i[h])||t.set(i[h],[]),(c=t.get(i[d]))==null||c.push({t:y.t1,point:y.point}),(l=t.get(i[h]))==null||l.push({t:y.t2,point:y.point});else{const m=n(i[d].a,i[h]);m!==null&&(t.has(i[h])||t.set(i[h],[]),(a=t.get(i[h]))==null||a.push({t:m,point:i[d].a.clone()}),o.add(i[d]),o.add(i[h]));const b=n(i[d].b,i[h]);b!==null&&(t.has(i[h])||t.set(i[h],[]),(u=t.get(i[h]))==null||u.push({t:b,point:i[d].b.clone()}),o.add(i[d]),o.add(i[h]));const p=n(i[h].a,i[d]);p!==null&&(t.has(i[d])||t.set(i[d],[]),(r=t.get(i[d]))==null||r.push({t:p,point:i[h].a.clone()}),o.add(i[d]),o.add(i[h]));const g=n(i[h].b,i[d]);g!==null&&(t.has(i[d])||t.set(i[d],[]),(f=t.get(i[d]))==null||f.push({t:g,point:i[h].b.clone()}),o.add(i[d]),o.add(i[h]))}}console.log(`T-junction detection: ${o.size} potential straggler edges`);const s=[];for(const d of i){const h=t.get(d),y=o.has(d);if(!h||h.length===0){d.isTJunctionStraggler=y,s.push(d);continue}h.sort((p,g)=>p.t-g.t);let m=d.a,b=d.a3d;for(const p of h){const g=new M.Vector3().lerpVectors(d.a3d,d.b3d,p.t);s.push({a:m.clone(),b:p.point.clone(),a3d:b.clone(),b3d:g.clone(),midpoint3d:new M.Vector3().addVectors(b,g).multiplyScalar(.5),isProfile:d.isProfile,visible:d.visible,faceIdx:d.faceIdx,mesh:d.mesh,isHatch:d.isHatch,normal1:d.normal1,isTJunctionStraggler:y}),p.t,m=p.point,b=g}s.push({a:m.clone(),b:d.b.clone(),a3d:b.clone(),b3d:d.b3d.clone(),midpoint3d:new M.Vector3().addVectors(b,d.b3d).multiplyScalar(.5),isProfile:d.isProfile,visible:d.visible,faceIdx:d.faceIdx,mesh:d.mesh,isHatch:d.isHatch,normal1:d.normal1,isTJunctionStraggler:y})}return s}function Wt(i,t,e,n,o,s,c=!1){if(c)return i.forEach(y=>y.visible=!0),i;const l=[];if(!s)return console.warn("No renderer provided, skipping occlusion test"),i;const a=new M.WebGLRenderTarget(n,o,{minFilter:M.NearestFilter,magFilter:M.NearestFilter,format:M.RGBAFormat,type:M.UnsignedByteType}),u=new M.ShaderMaterial({vertexShader:`
            attribute vec3 faceColor;
            varying vec3 vFaceColor;
            void main() {
                vFaceColor = faceColor;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `,fragmentShader:`
            varying vec3 vFaceColor;
            void main() {
                gl_FragColor = vec4(vFaceColor, 1.0);
            }
        `,side:M.DoubleSide}),r=[];let f=0;for(const y of t){const m=y.geometry,b=m.attributes.position,p=m.index,g=p?p.count/3:b.count/3,x=[],w=[];for(let v=0;v<g;v++){let k,$,O;p?(k=p.getX(v*3),$=p.getX(v*3+1),O=p.getX(v*3+2)):(k=v*3,$=v*3+1,O=v*3+2);const C=new M.Vector3(b.getX(k),b.getY(k),b.getZ(k)),R=new M.Vector3(b.getX($),b.getY($),b.getZ($)),V=new M.Vector3(b.getX(O),b.getY(O),b.getZ(O));C.applyMatrix4(y.matrixWorld),R.applyMatrix4(y.matrixWorld),V.applyMatrix4(y.matrixWorld),x.push(C.x,C.y,C.z,R.x,R.y,R.z,V.x,V.y,V.z);const z=f+v+1,F=(z&255)/255,T=(z>>8&255)/255,D=(z>>16&255)/255;w.push(F,T,D,F,T,D,F,T,D)}const P=new M.BufferGeometry;P.setAttribute("position",new M.BufferAttribute(new Float32Array(x),3)),P.setAttribute("faceColor",new M.BufferAttribute(new Float32Array(w),3));const S=new M.Mesh(P,u);r.push(S),f+=g}const d=new M.Scene;for(const y of r)d.add(y);s.setRenderTarget(a),s.setClearColor(0,1),s.clear(),s.render(d,e);const h=new Uint8Array(n*o*4);s.readRenderTargetPixels(a,0,0,n,o,h),s.setRenderTarget(null);for(const y of i){const m=(y.a.x+y.b.x)/2,b=(y.a.y+y.b.y)/2,p=Math.round(m+n/2),g=Math.round(o/2+b);if(p<0||p>=n||g<0||g>=o){y.visible=!0,l.push(y);continue}const x=((o-1-g)*n+p)*4,w=h[x],P=h[x+1],S=h[x+2],v=w+(P<<8)+(S<<16);if(v===0){y.visible=!0,l.push(y);continue}const k=y.faceIdx+1;v===k?(y.visible=!0,l.push(y)):y.visible=!1}a.dispose(),u.dispose();for(const y of r)y.geometry.dispose();return l}function Bt(i,t,e,n){const o=(r,f,d)=>(r.x-d.x)*(f.y-d.y)-(f.x-d.x)*(r.y-d.y),s=o(i,t,e),c=o(i,e,n),l=o(i,n,t),a=s<0||c<0||l<0,u=s>0||c>0||l>0;return!(a&&u)}function Lt(i,t,e,n,o=2){const s=n.x-e.x,c=n.y-e.y,l=s*s+c*c;if(l<1e-10)return!1;const a=u=>{const r=((u.x-e.x)*s+(u.y-e.y)*c)/l,f=e.x+r*s,d=e.y+r*c;return(u.x-f)*(u.x-f)+(u.y-d)*(u.y-d)<o*o&&r>=-.01&&r<=1.01};return a(i)&&a(t)}function Nt(i,t){const e=[];for(const n of t){const o=[{a:n.a2d,b:n.b2d,name:"AB"},{a:n.b2d,b:n.c2d,name:"BC"},{a:n.c2d,b:n.a2d,name:"CA"}];for(const s of o)if(Lt(i.a,i.b,s.a,s.b)){e.push({face:n,matchedEdge:s.name,matchType:"collinear"});break}}return e}function jt(i,t,e,n,o,s,c){const l={x:n.x-t.x,y:n.y-t.y},a={x:e.x-t.x,y:e.y-t.y},u={x:i.x-t.x,y:i.y-t.y},r=l.x*l.x+l.y*l.y,f=l.x*a.x+l.y*a.y,d=l.x*u.x+l.y*u.y,h=a.x*a.x+a.y*a.y,y=a.x*u.x+a.y*u.y,m=r*h-f*f;if(Math.abs(m)<1e-10)return 1/0;const b=(h*d-f*y)/m,p=(r*y-f*d)/m;return(1-b-p)*o+p*s+b*c}function Jt(i,t,e=.99,n=.5){const o=[];let s=0;for(const c of i){const l=Nt(c,t);c.adjacentFaceCount=l.length;let a=!1;if(l.length===2){const u=l[0].face,r=l[1].face,f=u.normal,d=r.normal;if(f&&d){const h=f.dot(d),y=Math.abs(h);c.faceSimilarity=y;let m;h>0?m=Math.abs(u.constant-r.constant):m=Math.abs(u.constant+r.constant),y>=e&&m<n&&(a=!0,s++)}}else if(l.length>2){const u=l.map(r=>r.face).filter(r=>r.normal);if(u.length>=2){let r=!0,f=1;for(let d=1;d<u.length;d++){const h=u[0].normal.dot(u[d].normal),y=Math.abs(h);let m;if(h>0?m=Math.abs(u[0].constant-u[d].constant):m=Math.abs(u[0].constant+u[d].constant),f=Math.min(f,y),y<e||m>=n){r=!1;break}}c.faceSimilarity=f,r&&(a=!0,s++)}}a||o.push(c)}return console.log(`Geometric straggler filter: removed ${s} coplanar edges`),o}function Zt(i,t,e){const n=e.position;return Kt(i,t,n)}function Kt(i,t,e){const n=[];let o=0,s=0;for(const c of i){const l=new M.Vector2((c.a.x+c.b.x)/2,(c.a.y+c.b.y)/2),a=c.midpoint3d,u=e.distanceTo(a);let r=!1;for(const f of t){if(f.mesh===c.mesh&&(f.faceIdx===c.faceIdx||f.faceIdx===c.faceIdx2)||!Bt(l,f.a2d,f.b2d,f.c2d))continue;if(jt(l,f.a2d,f.b2d,f.c2d,f.depthA,f.depthB,f.depthC)<u-.001){r=!0,s++;break}o++}r?c.visible=!1:(c.visible=!0,n.push(c))}return console.log(`[JS] Occlusion debug: ${o} point-in-triangle hits, ${s} occluded`),n}function Qt(i,t,e,n=.05){const o=new M.Raycaster,s=[],c=[];t.traverse(l=>{l.isMesh&&c.push(l)});for(const l of i){const a=new M.Vector3().subVectors(l.midpoint3d,e.position),u=a.clone().normalize(),r=a.length(),f=r*n;o.set(e.position.clone(),u);const d=o.intersectObjects(c,!0);if(d.length===0)l.visible=!0,s.push(l);else{let h=!1;for(const y of d)if(!(y.distance>=r-f)&&!(y.object===l.mesh&&y.faceIndex===l.faceIdx)){h=!0;break}h?l.visible=!1:(l.visible=!0,s.push(l))}}return s}function it(i,t=.5){const e=new Map,n=s=>`${Math.round(s.x/t)},${Math.round(s.y/t)}`,o=s=>{const c=n(s.a),l=n(s.b);return c<l?`${c}-${l}`:`${l}-${c}`};for(const s of i){const c=o(s);e.has(c)||e.set(c,s)}return Array.from(e.values())}function ct(i,t=1,e=50){const n=p=>`${Math.round(p.x/t)},${Math.round(p.y/t)}`,o=new Map;for(const p of i)for(const g of["a","b"]){const x=g==="a"?p.a:p.b,w=n(x);o.has(w)||o.set(w,{edges:[],point:{x:x.x,y:x.y}}),o.get(w).edges.push({edge:p,endpoint:g})}const s=[];for(const[p,g]of o)if(g.edges.length===1){const{edge:x,endpoint:w}=g.edges[0],P=g.point,S=w==="a"?x.b:x.a,v=P.x-S.x,k=P.y-S.y,$=Math.sqrt(v*v+k*k);if($<.001)continue;s.push({key:p,edge:x,endpoint:w,point:P,otherPoint:S,dirX:v/$,dirY:k/$,len:$})}if(console.log(`Edge cleanup: found ${s.length} orphaned endpoints`),s.length===0)return i;const c=(p,g,x,w)=>{const P=g.x*w.y-g.y*w.x;if(Math.abs(P)<1e-4)return null;const S=x.x-p.x,v=x.y-p.y,k=(S*w.y-v*w.x)/P,$=(S*g.y-v*g.x)/P;return{t1:k,t2:$}};let l=0;const a=new Set;for(let p=0;p<s.length;p++){const g=s[p];if(a.has(g.key))continue;let x=null,w=null,P=1/0;for(let S=0;S<s.length;S++){if(p===S)continue;const v=s[S];if(a.has(v.key)||Math.sqrt((v.point.x-g.point.x)**2+(v.point.y-g.point.y)**2)>e*2)continue;const $=c({x:g.point.x,y:g.point.y},{x:g.dirX,y:g.dirY},{x:v.point.x,y:v.point.y},{x:v.dirX,y:v.dirY});if(!$||$.t1<-.1||$.t2<-.1||$.t1>e||$.t2>e)continue;const O=g.point.x+$.t1*g.dirX,C=g.point.y+$.t1*g.dirY,R=$.t1+$.t2;R<P&&(P=R,x=v,w={x:O,y:C})}if(x&&w){const S=bt(g.point,w,i,g.edge,x.edge),v=bt(x.point,w,i,g.edge,x.edge);if(S||v)continue;g.endpoint==="a"?(g.edge.a.x=w.x,g.edge.a.y=w.y):(g.edge.b.x=w.x,g.edge.b.y=w.y),x.endpoint==="a"?(x.edge.a.x=w.x,x.edge.a.y=w.y):(x.edge.b.x=w.x,x.edge.b.y=w.y),a.add(g.key),a.add(x.key),l++}}console.log(`Edge cleanup: extended ${l} pairs of edges to intersections`);let u=0;for(const p of i){const g=p.b.x-p.a.x,x=p.b.y-p.a.y;u+=Math.sqrt(g*g+x*x)}const r=u/i.length,f=r/8;console.log(`Edge cleanup: average edge length = ${r.toFixed(2)}, snap threshold = ${f.toFixed(2)}`);const d=new Map;for(const p of i)for(const g of["a","b"]){const x=g==="a"?p.a:p.b,w=n(x);d.has(w)||d.set(w,{edges:[],point:x}),d.get(w).edges.push({edge:p,endpoint:g})}const h=[];for(const[p,g]of d)g.edges.length===1&&h.push({key:p,...g.edges[0],point:g.point});console.log(`Edge cleanup: ${h.length} orphaned endpoints before snap pass`);let y=0;const m=new Set;for(let p=0;p<h.length;p++){const g=h[p];if(m.has(g.key))continue;let x=null,w=1/0;for(let P=0;P<h.length;P++){if(p===P)continue;const S=h[P];if(m.has(S.key))continue;const v=Math.sqrt((S.point.x-g.point.x)**2+(S.point.y-g.point.y)**2);v<w&&(w=v,x=S)}if(x&&w<f){const P=(g.point.x+x.point.x)/2,S=(g.point.y+x.point.y)/2;g.endpoint==="a"?(g.edge.a.x=P,g.edge.a.y=S):(g.edge.b.x=P,g.edge.b.y=S),x.endpoint==="a"?(x.edge.a.x=P,x.edge.a.y=S):(x.edge.b.x=P,x.edge.b.y=S),m.add(g.key),m.add(x.key),y++}}console.log(`Edge cleanup: snapped ${y} pairs of nearby orphans`);const b=h.length-y*2;return console.log(`Edge cleanup: ${b} orphaned endpoints remaining`),i}function _t(i,t=1){const e=c=>`${Math.round(c.x/t)},${Math.round(c.y/t)}`,n=new Map;for(const c of i){const l=e(c.a),a=e(c.b);n.set(l,(n.get(l)||0)+1),n.set(a,(n.get(a)||0)+1)}const o=i.filter(c=>{const l=e(c.a),a=e(c.b),u=n.get(l)||0,r=n.get(a)||0;return u>=2||r>=2}),s=i.length-o.length;return s>0&&console.log(`Edge cleanup: removed ${s} isolated edges (orphaned at both ends)`),o}function bt(i,t,e,n,o){for(const c of e){if(c===n||c===o)continue;const l=t.x-i.x,a=t.y-i.y,u=c.b.x-c.a.x,r=c.b.y-c.a.y,f=l*r-a*u;if(Math.abs(f)<.001)continue;const d=c.a.x-i.x,h=c.a.y-i.y,y=(d*r-h*u)/f,m=(d*a-h*l)/f;if(y>.001&&y<1-.001&&m>.001&&m<1-.001)return!0}return!1}function Gt(i,t,e,n={}){const{smoothThreshold:o=.99,gridSize:s=32,occlusionEpsilon:c=.01,skipOcclusion:l=!1,width:a=800,height:u=600,renderer:r=null}=n;console.time("extractEdges");const f=xt(i,t.position);console.timeEnd("extractEdges"),console.log(`Extracted ${f.length} edges`),console.time("filterBackfacing");const d=yt(f,t.position);console.timeEnd("filterBackfacing"),console.log(`After backface filter: ${d.length} edges`),console.time("classifyEdges");const{profiles:h,smoothFiltered:y}=pt(d,t.position,o);console.timeEnd("classifyEdges"),console.log(`Profiles: ${h.length}, Smooth edges: ${y.length}`);const m=[...h,...y];console.time("projectEdges");let b=st(m,t,a,u);console.timeEnd("projectEdges");for(let k=0;k<h.length;k++)b[k].isProfile=!0;console.time("spatialHash");const p=Math.max(a,u)/s,g=new Ht(p);for(const k of b)g.insert(k);console.timeEnd("spatialHash"),console.time("splitIntersections");const x=new Set;let w=[];for(const k of g.getAllCells()){const $=g.query(k).filter(C=>!x.has(C)),O=mt($);w.push(...O);for(const C of $)x.add(C)}console.timeEnd("splitIntersections"),console.log(`After splitting: ${w.length} edges`);let P;if(l)console.log("Skipping occlusion test (debug mode)"),P=w;else if(r){console.time("testOcclusion (face ID buffer)");const k=w.filter(C=>C.isProfile),$=w.filter(C=>!C.isProfile);k.forEach(C=>C.visible=!0);const O=Wt($,[i],t,a,u,r,!1);P=[...k,...O],console.timeEnd("testOcclusion (face ID buffer)")}else console.time("testOcclusion (raycaster - slow)"),P=Qt(w,e,t,c),console.timeEnd("testOcclusion (raycaster - slow)");console.log(`Visible edges: ${P.length}`),console.time("optimize");const S=it(P);console.timeEnd("optimize"),console.time("cleanup orphans");const v=ct(S);return console.timeEnd("cleanup orphans"),console.log(`Final edges: ${v.length}`),{edges:v,profiles:v.filter(k=>k.isProfile)}}function wt(i,t,e,n={}){const{smoothThreshold:o=.99,gridSize:s=32,skipOcclusion:c=!1,width:l=800,height:a=600,renderer:u=null,internalScale:r=4,distanceThreshold:f=.5}=n;let d=[];for(const V of i){V.updateMatrixWorld(!0);const z=xt(V,t.position);d.push(...z)}console.log(`Extracted ${d.length} edges from ${i.length} meshes`);const{profiles:h,smoothFiltered:y}=pt(d,t.position,o);console.log(`Profiles: ${h.length}, Crease edges: ${y.length}`);const m=[...h,...y];console.log(`After smooth filter: ${m.length} edges`);let b=st(m,t,l,a,r);if(n.hatchEdges&&n.hatchEdges.length>0){console.log(`Processing ${n.hatchEdges.length} hatch edges...`);let V=yt(n.hatchEdges,t.position);if(n.minHatchDotProduct!==void 0){const F=n.minHatchDotProduct;V=V.filter(T=>{const D=new M.Vector3().addVectors(T.a,T.b).multiplyScalar(.5),A=new M.Vector3().subVectors(t.position,D).normalize(),N=T.normal1.dot(A);return Math.abs(N)>=F}),console.log(`Density filter: kept ${V.length} hatch edges (threshold ${F})`)}const z=st(V,t,l,a,r);z.forEach(F=>F.isHatch=!0),b.push(...z),console.log(`Added ${z.length} visible hatch edges`)}console.time("splitIntersections");const p=mt(b);console.timeEnd("splitIntersections"),console.log(`After splitting: ${p.length} edges`),console.time("buildProjectedFaces");const g=[],x=t.position,w=l/2,P=a/2;for(const V of i){const z=V.geometry,F=z.attributes.position,T=z.index,D=T?T.count/3:F.count/3;for(let A=0;A<D;A++){let N,Y,H;T?(N=T.getX(A*3),Y=T.getX(A*3+1),H=T.getX(A*3+2)):(N=A*3,Y=A*3+1,H=A*3+2);const W=new M.Vector3(F.getX(N),F.getY(N),F.getZ(N)).applyMatrix4(V.matrixWorld),L=new M.Vector3(F.getX(Y),F.getY(Y),F.getZ(Y)).applyMatrix4(V.matrixWorld),j=new M.Vector3(F.getX(H),F.getY(H),F.getZ(H)).applyMatrix4(V.matrixWorld),Z=new M.Vector3().subVectors(L,W),Q=new M.Vector3().subVectors(j,W),G=new M.Vector3().crossVectors(Z,Q).normalize(),at=new M.Vector3().addVectors(W,L).add(j).divideScalar(3),lt=new M.Vector3().subVectors(x,at),ut=-G.dot(W);if(G.dot(lt)<=0)continue;const Et=W.clone().project(t),vt=L.clone().project(t),St=j.clone().project(t),ne=new M.Vector2(Et.x*w*r,-Et.y*P*r),oe=new M.Vector2(vt.x*w*r,-vt.y*P*r),se=new M.Vector2(St.x*w*r,-St.y*P*r),ie=x.distanceTo(W),ce=x.distanceTo(L),re=x.distanceTo(j);g.push({a2d:ne,b2d:oe,c2d:se,depthA:ie,depthB:ce,depthC:re,mesh:V,faceIdx:A,normal:G,constant:ut})}}console.timeEnd("buildProjectedFaces"),console.log(`Built ${g.length} projected faces for occlusion`),console.time("classifySilhouettes"),Ut(p,g),console.timeEnd("classifySilhouettes"),console.time("filterSmoothSplitEdges");const S=Jt(p,g,o,f);console.timeEnd("filterSmoothSplitEdges");let v;c?v=S:(console.time("testOcclusion (math)"),v=Zt(S,g,t),console.timeEnd("testOcclusion (math)")),console.log(`Visible edges: ${v.length}`),console.time("optimize");const k=it(v);console.timeEnd("optimize"),console.time("cleanup orphans");const $=ct(k);console.timeEnd("cleanup orphans");const O=_t($);console.log(`Final edges before optimization: ${O.length}`);let C=O;if(O.length>0){let V=0;for(const T of O){const D=T.b.x-T.a.x,A=T.b.y-T.a.y;V+=Math.sqrt(D*D+A*A)}const z=V/O.length,F=z/10;console.log(`Optimization: avgLen=${z.toFixed(2)}, trim limit=${F.toFixed(2)}`),console.time("Optimize.segments"),C=_.segments(O,!1,!0,F,!1,!1,!1)._segments,console.timeEnd("Optimize.segments"),console.log(`After optimization: ${C.length} edges`)}for(const V of C)V.a.x/=r,V.a.y/=r,V.b.x/=r,V.b.y/=r;const R=C;return{edges:R,profiles:R.filter(V=>V.isProfile),allEdges:p,projectedFaces:g}}function Ut(i,t){for(const o of i){if(o.isHatch){o.isSilhouette=!1;continue}const s=(o.a.x+o.b.x)/2,c=(o.a.y+o.b.y)/2,l=o.b.x-o.a.x,a=o.b.y-o.a.y,u=Math.sqrt(l*l+a*a);if(u<.001){o.isSilhouette=!1;continue}const r=-a/u,f=l/u,d=Mt(s,c,r,f,1e3,t),h=Mt(s,c,-r,-f,1e3,t);o.isSilhouette=!d||!h}const n=i.filter(o=>o.isSilhouette).length;console.log(`Classified ${n} silhouette edges out of ${i.length}`)}function Mt(i,t,e,n,o,s){for(const c of s)if(te(i,t,e,n,o,c.a2d,c.b2d,c.c2d))return!0;return!1}function te(i,t,e,n,o,s,c,l){return!!(rt(i,t,e,n,o,s.x,s.y,c.x,c.y)||rt(i,t,e,n,o,c.x,c.y,l.x,l.y)||rt(i,t,e,n,o,l.x,l.y,s.x,s.y))}function rt(i,t,e,n,o,s,c,l,a){const u=l-s,r=a-c,f=e*r-n*u;if(Math.abs(f)<1e-10)return!1;const d=((s-i)*r-(c-t)*u)/f,h=((s-i)*n-(c-t)*e)/f;return d>.1&&d<=o&&h>=0&&h<=1}var B=i=>Math.round(i*100)/100,tt=function(i){M.Object3D.call(this),this.node=i};tt.prototype=Object.create(M.Object3D.prototype),tt.prototype.constructor=tt;var ee=function(){var i=this,t=document.createElementNS("http://www.w3.org/2000/svg","svg"),e=document.createElementNS("http://www.w3.org/2000/svg","g"),n=document.createElementNS("http://www.w3.org/2000/svg","g"),o=document.createElementNS("http://www.w3.org/2000/svg","g"),s,c,l,a,u=new M.Color;t.setAttribute("xmlns","http://www.w3.org/2000/svg"),t.setAttribute("xmlns:inkscape","http://www.inkscape.org/namespaces/inkscape"),t.setAttribute("xmlns:xlink","http://www.w3.org/1999/xlink"),t.setAttribute("version","1.1"),e.setAttribute("inkscape:label","Silhouettes"),e.setAttribute("inkscape:groupmode","layer"),e.id="silhouettes_layer",t.appendChild(e),o.setAttribute("inkscape:label","Shading"),o.setAttribute("inkscape:groupmode","layer"),o.id="shading_layer",t.appendChild(o),n.setAttribute("inkscape:label","Edges"),n.setAttribute("inkscape:groupmode","layer"),n.id="edges_layer",t.appendChild(n),this.domElement=t,this.showSilhouettes=!0,this.showEdges=!0,this.showHatches=!0,this.silhouetteOptions={normalBuckets:12,simplifyTolerance:2,minArea:100},this.hatchOptions={baseSpacing:8,minSpacing:3,maxSpacing:40,depthFactor:.5,insetPixels:3,stroke:"black",strokeWidth:"1px",axisSettings:{x:{rotation:0,spacing:8},y:{rotation:0,spacing:8},z:{rotation:0,spacing:8}}},this.edgeOptions={stroke:"white",strokeWidth:"1px"},this.hiddenLineOptions={smoothThreshold:.99},this._glRenderer=null,this.autoClear=!0,this.setClearColor=function(f){u.set(f)},this.setPixelRatio=function(){},this.setSize=function(f,d){s=f,c=d,l=s/2,a=c/2,t.setAttribute("viewBox",-l+" "+-a+" "+s+" "+c),t.setAttribute("width",s),t.setAttribute("height",c)},this.getSize=function(){return{width:s,height:c}},this.setGLRenderer=function(f){i._glRenderer=f};function r(){for(;e.childNodes.length>0;)e.removeChild(e.childNodes[0]);for(;n.childNodes.length>0;)n.removeChild(n.childNodes[0]);for(;o.childNodes.length>0;)o.removeChild(o.childNodes[0])}this.clear=function(){r(),t.style.backgroundColor=u.getStyle()},this.renderGPULayers=function(f,d){if(!i._glRenderer){console.warn("PlotterRenderer: WebGL renderer not set. Call setGLRenderer() first.");return}const h=i._glRenderer;if(i.showSilhouettes||i.showHatches){const y=ft(h,f,d,{normalBuckets:i.silhouetteOptions.normalBuckets,simplifyTolerance:i.silhouetteOptions.simplifyTolerance,minArea:i.silhouetteOptions.minArea,insetPixels:i.showHatches?i.hatchOptions.insetPixels:0});if(i.showSilhouettes&&y.forEach(m=>{if(m.boundary.length<3)return;const b=document.createElementNS("http://www.w3.org/2000/svg","path");let p="";m.boundary.forEach((S,v)=>{const k=S.x,$=-S.y;p+=(v===0?"M":"L")+B(k)+","+B($)}),p+="Z";const g=m.normal,x=Math.floor((g.x*.5+.5)*255),w=Math.floor((g.y*.5+.5)*255),P=Math.floor((g.z*.5+.5)*255);b.setAttribute("d",p),b.setAttribute("fill",`rgba(${x},${w},${P},0.3)`),b.setAttribute("stroke","none"),e.appendChild(b)}),i.showHatches){y.sort((b,p)=>b.depth-p.depth);const m=y.map(b=>b.boundary);y.forEach((b,p)=>{let g=dt(b,d,{baseSpacing:i.hatchOptions.baseSpacing,minSpacing:i.hatchOptions.minSpacing,maxSpacing:i.hatchOptions.maxSpacing,depthFactor:i.hatchOptions.depthFactor,insetPixels:i.hatchOptions.insetPixels,screenWidth:s,screenHeight:c,axisSettings:i.hatchOptions.axisSettings});for(let x=0;x<p;x++)g=g.flatMap(w=>ht(w,m[x]));g.forEach(x=>{const w=document.createElementNS("http://www.w3.org/2000/svg","path"),P=`M${B(x.start.x)},${B(-x.start.y)}L${B(x.end.x)},${B(-x.end.y)}`;w.setAttribute("d",P),w.setAttribute("fill","none"),w.setAttribute("stroke",i.hatchOptions.stroke),w.setAttribute("stroke-width",i.hatchOptions.strokeWidth),o.appendChild(w)})})}if(i.showEdges){const m=[];f.traverse(b=>{b.isMesh&&b.geometry&&m.push(b)}),m.length>0&&(wt(m,d,f,{smoothThreshold:i.hiddenLineOptions.smoothThreshold,width:s,height:c}).edges||[]).forEach(g=>{const x=document.createElementNS("http://www.w3.org/2000/svg","line");x.setAttribute("x1",B(g.a.x)),x.setAttribute("y1",B(g.a.y)),x.setAttribute("x2",B(g.b.x)),x.setAttribute("y2",B(g.b.y)),x.setAttribute("stroke",i.edgeOptions.stroke),x.setAttribute("stroke-width",i.edgeOptions.strokeWidth),n.appendChild(x)})}}},this.render=function(f,d){if(!(d instanceof M.Camera)){console.error("PlotterRenderer.render: camera is not an instance of Camera.");return}}};X.GeomUtil=E,X.Optimize=_,X.PlotterRenderer=ee,X.Point=I,X.SVGObject=tt,X.Segment=q,X.Segments=K,X.cleanupOrphanedEdges=ct,X.clipLineOutsidePolygon=ht,X.clipLineToPolygon=nt,X.computeHiddenLines=Gt,X.computeHiddenLinesMultiple=wt,X.extractNormalRegions=ft,X.generatePerspectiveHatches=dt,X.optimizeEdges=it,Object.defineProperty(X,Symbol.toStringTag,{value:"Module"})});
//# sourceMappingURL=three-plotter-renderer.umd.js.map
