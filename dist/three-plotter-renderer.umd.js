(function(X,M){typeof exports=="object"&&typeof module<"u"?M(exports,require("three")):typeof define=="function"&&define.amd?define(["exports","three"],M):(X=typeof globalThis<"u"?globalThis:X||self,M(X.ThreePlotterRenderer={},X.THREE))})(this,function(X,M){"use strict";function gt(i,t,e,n={}){const{resolution:o=2,normalBuckets:s=12,minArea:c=100,simplifyTolerance:a=2,insetPixels:l=0}=n,u=i.getSize(new M.Vector2),r=Math.floor(u.x*o),d=Math.floor(u.y*o),f=Math.round(l*o),g=kt(i,t,e,r,d),x=It(i,t,e,r,d),{regionMap:m,normalLookup:b}=Ot(g,r,d),{labels:p,regionCount:h}=Ft(m,r,d);f>0&&$t(m,r,d,f);const y=[];for(let w=1;w<=h;w++){const P=Ct(p,r,d,w);if(P.length<3)continue;const E=st(P,a),v=Math.abs(Yt(E));if(v<c)continue;const k=Tt(p,m,b,r,d,w),I=Vt(p,x,r,d,w);y.push({boundary:E.map(F=>new M.Vector2(F.x/o-u.x/2,F.y/o-u.y/2)),normal:k,depth:I,area:v/(o*o),regionId:w})}return y}function kt(i,t,e,n,o){const s=new M.WebGLRenderTarget(n,o,{minFilter:M.NearestFilter,magFilter:M.NearestFilter}),c=new M.MeshNormalMaterial({flatShading:!0}),a=new Map,l=[];t.traverse(r=>{r.isMesh?(a.set(r,r.material),r.material=c):(r.isLineSegments||r.isLine||r.isPoints)&&r.visible&&(l.push(r),r.visible=!1)}),i.setRenderTarget(s),i.render(t,e),t.traverse(r=>{r.isMesh&&a.has(r)&&(r.material=a.get(r))});for(const r of l)r.visible=!0;i.setRenderTarget(null);const u=new Uint8Array(n*o*4);return i.readRenderTargetPixels(s,0,0,n,o,u),s.dispose(),c.dispose(),u}function It(i,t,e,n,o){const s=new M.WebGLRenderTarget(n,o,{minFilter:M.NearestFilter,magFilter:M.NearestFilter}),c=new M.MeshDepthMaterial({depthPacking:M.RGBADepthPacking}),a=new Map,l=[];t.traverse(r=>{r.isMesh?(a.set(r,r.material),r.material=c):(r.isLineSegments||r.isLine||r.isPoints)&&r.visible&&(l.push(r),r.visible=!1)}),i.setRenderTarget(s),i.render(t,e),t.traverse(r=>{r.isMesh&&a.has(r)&&(r.material=a.get(r))});for(const r of l)r.visible=!0;i.setRenderTarget(null);const u=new Uint8Array(n*o*4);return i.readRenderTargetPixels(s,0,0,n,o,u),s.dispose(),c.dispose(),u}function Vt(i,t,e,n,o){let s=0,c=0;for(let a=0;a<n;a++)for(let l=0;l<e;l++)if(i[a*e+l]===o){const u=(a*e+l)*4,r=t[u]/255,d=t[u+1]/255,f=t[u+2]/255,g=t[u+3]/255,x=r+d/256+f/65536+g/16777216;s+=x,c++}return c>0?s/c:.5}function $t(i,t,e,n){let o=i;for(let s=0;s<n;s++){const c=new Uint16Array(o);for(let a=1;a<e-1;a++)for(let l=1;l<t-1;l++){const u=a*t+l;if(o[u]===0)continue;const d=o[u-1],f=o[u+1],g=o[u-t],x=o[u+t];(d===0||f===0||g===0||x===0)&&(c[u]=0)}o=c}return o}function Ot(i,t,e,n){const o=new Uint16Array(t*e),s={};let c=1;const a={};for(let l=0;l<t*e;l++){const u=l*4,r=i[u],d=i[u+1],f=i[u+2];if(r<5&&d<5&&f<5){o[l]=0;continue}const g=r/255*2-1,x=d/255*2-1,m=f/255*2-1,b=4,p=Math.round(r/b)*b,h=Math.round(d/b)*b,y=Math.round(f/b)*b,w=`${p}|${h}|${y}`;a[w]||(a[w]=c,s[c]=new M.Vector3(g,x,m).normalize(),c++),o[l]=a[w]}return{regionMap:o,normalLookup:s}}function Ft(i,t,e){const n=new Uint32Array(t*e),o=[];let s=1;function c(r){return o[r]!==r&&(o[r]=c(o[r])),o[r]}function a(r,d){const f=c(r),g=c(d);f!==g&&(o[g]=f)}for(let r=0;r<e;r++)for(let d=0;d<t;d++){const f=r*t+d,g=i[f];if(g===0)continue;const x=[];if(d>0&&i[f-1]===g&&n[f-1]>0&&x.push(n[f-1]),r>0&&i[f-t]===g&&n[f-t]>0&&x.push(n[f-t]),x.length===0)n[f]=s,o[s]=s,s++;else{const m=Math.min(...x);n[f]=m;for(const b of x)a(m,b)}}const l={};let u=0;for(let r=0;r<t*e;r++){if(n[r]===0)continue;const d=c(n[r]);l[d]===void 0&&(u++,l[d]=u),n[r]=l[d]}return{labels:n,regionCount:u}}function Ct(i,t,e,n){const o=[];let s=-1,c=-1;t:for(let x=0;x<e;x++)for(let m=0;m<t;m++)if(i[x*t+m]===n&&(m===0||i[x*t+m-1]!==n||x===0||i[(x-1)*t+m]!==n)){s=m,c=x;break t}if(s===-1)return o;const a=[1,1,0,-1,-1,-1,0,1],l=[0,1,1,1,0,-1,-1,-1];let u=s,r=c,d=7;const f=t*e*2;let g=0;do{o.push({x:u,y:r});let x=!1;for(let m=0;m<8;m++){const b=(d+6+m)%8,p=u+a[b],h=r+l[b];if(p>=0&&p<t&&h>=0&&h<e&&i[h*t+p]===n){u=p,r=h,d=b,x=!0;break}}if(!x)break;g++}while((u!==s||r!==c)&&g<f);return o}function Tt(i,t,e,n,o,s){let c=0,a=0,l=0;for(let g=0;g<o;g++)for(let x=0;x<n;x++)i[g*n+x]===s&&(c+=x,a+=g,l++);if(l===0)return new M.Vector3(0,0,1);const u=Math.round(c/l),d=Math.round(a/l)*n+u,f=t[d];return e[f]||new M.Vector3(0,0,1)}function st(i,t){if(i.length<3)return i;let e=0,n=0;const o=i[0],s=i[i.length-1];for(let c=1;c<i.length-1;c++){const a=Xt(i[c],o,s);a>e&&(e=a,n=c)}if(e>t){const c=st(i.slice(0,n+1),t),a=st(i.slice(n),t);return c.slice(0,-1).concat(a)}else return[o,s]}function Xt(i,t,e){const n=e.x-t.x,o=e.y-t.y,s=n*n+o*o;if(s<1e-10)return Math.sqrt((i.x-t.x)**2+(i.y-t.y)**2);let c=((i.x-t.x)*n+(i.y-t.y)*o)/s;c=Math.max(0,Math.min(1,c));const a=t.x+c*n,l=t.y+c*o;return Math.sqrt((i.x-a)**2+(i.y-l)**2)}function Yt(i){let t=0;for(let e=0;e<i.length;e++){const n=(e+1)%i.length;t+=i[e].x*i[n].y,t-=i[n].x*i[e].y}return t/2}function zt(i,t,e,n){const o=e/2,s=n/2,c=new M.Vector3(0,1,0),a=new M.Vector3(0,0,1);let l;Math.abs(i.y)>.9?l=a.clone():(l=new M.Vector3().crossVectors(c,i).normalize(),l.lengthSq()<.01&&(l=a.clone()));const u=new M.Vector3(0,0,0),r=l.clone().multiplyScalar(100),d=u.clone().project(t),f=r.clone().project(t),g=new M.Vector2(d.x*o,-d.y*s),m=new M.Vector2(f.x*o,-f.y*s).clone().sub(g).normalize(),p=l.clone().multiplyScalar(1e5).clone().project(t);let h=null;return Math.abs(p.x)<100&&Math.abs(p.y)<100&&p.z<1&&(h=new M.Vector2(p.x*o,-p.y*s)),{direction:m,vanishingPoint:h}}function xt(i,t,e={}){const{baseSpacing:n=8,minSpacing:o=3,maxSpacing:s=20,depthFactor:c=.5,screenWidth:a=1200,screenHeight:l=800,axisSettings:u={},brightness:r=null,invertBrightness:d=!1}=e,{boundary:f,normal:g,depth:x=.5}=i;if(f.length<3)return[];const m=Math.abs(g.x),b=Math.abs(g.y),p=Math.abs(g.z);let h="y";m>=b&&m>=p?h="x":p>=b&&p>=m&&(h="z");const y=u[h]||{},w=y.rotation||0,P=y.spacing;console.log(`[Hatch] normal=(${g.x.toFixed(2)}, ${g.y.toFixed(2)}, ${g.z.toFixed(2)}) => axis=${h}, rotation=${w}, spacing=${P}`);const{direction:E,vanishingPoint:v}=zt(g,t,a,l);let k=E;if(w!==0){const Y=w*(Math.PI/180),A=Math.cos(Y),L=Math.sin(Y);k=new M.Vector2(E.x*A-E.y*L,E.x*L+E.y*A)}const I=new M.Vector2(-k.y,k.x);let O=Math.max(o,Math.min(s,(P!==void 0?P:n)+x*c*(s-o)));if(r!=null){const A=.5+(d?r:1-r)*1.5;O=Math.max(o,Math.min(s,O*A))}let B=1/0,$=-1/0,z=1/0,C=-1/0;for(const Y of f)B=Math.min(B,Y.x),$=Math.max($,Y.x),z=Math.min(z,Y.y),C=Math.max(C,Y.y);const T=(B+$)/2,H=(z+C)/2,D=new M.Vector2(T,H),W=Math.sqrt(($-B)**2+(C-z)**2),N=[];if(v&&Math.abs(w)<5&&v.distanceTo(D)<W*5){const Y=v.distanceTo(D),A=Math.ceil(W/O)*2,Q=Math.atan2(W,Y)*2/A,U=Math.atan2(H-v.y,T-v.x);for(let j=-A;j<=A;j++){const _=U+j*Q,ft=new M.Vector2(Math.cos(_),Math.sin(_)),dt=v.clone(),nt=v.clone().add(ft.clone().multiplyScalar(Y*10)),ot=it({start:dt,end:nt},f);N.push(...ot)}}else{const Y=Math.ceil(W/O)+2;for(let A=-Y;A<=Y;A++){const L=I.clone().multiplyScalar(A*O),Q=D.clone().add(L),U=Q.clone().add(k.clone().multiplyScalar(-W)),j=Q.clone().add(k.clone().multiplyScalar(W)),_=it({start:U,end:j},f);N.push(..._)}}return N}function it(i,t){const e=[],n=t.length;for(let s=0;s<n;s++){const c=t[s],a=t[(s+1)%n],l=Dt(i.start.x,i.start.y,i.end.x,i.end.y,c.x,c.y,a.x,a.y);l&&e.push({point:new M.Vector2(l.x,l.y),t:l.t})}if(e.length<2)return[];e.sort((s,c)=>s.t-c.t);const o=[];for(let s=0;s<e.length-1;s++){const c=(e[s].point.x+e[s+1].point.x)/2,a=(e[s].point.y+e[s+1].point.y)/2;tt(c,a,t)&&o.push({start:e[s].point,end:e[s+1].point})}return o}function yt(i,t){const e=[],n=t.length,o=tt(i.start.x,i.start.y,t),s=tt(i.end.x,i.end.y,t);e.push({point:i.start.clone(),t:0,inside:o});for(let l=0;l<n;l++){const u=t[l],r=t[(l+1)%n],d=qt(i.start.x,i.start.y,i.end.x,i.end.y,u.x,u.y,r.x,r.y);d&&d.t>0&&d.t<1&&e.push({point:new M.Vector2(d.x,d.y),t:d.t,inside:null})}e.push({point:i.end.clone(),t:1,inside:s}),e.sort((l,u)=>l.t-u.t);const c=[e[0]];for(let l=1;l<e.length;l++)e[l].t-c[c.length-1].t>1e-4&&c.push(e[l]);if(c.length<2)return[i];const a=[];for(let l=0;l<c.length-1;l++){const u=(c[l].t+c[l+1].t)/2,r=i.start.x+u*(i.end.x-i.start.x),d=i.start.y+u*(i.end.y-i.start.y);tt(r,d,t)||a.push({start:c[l].point.clone(),end:c[l+1].point.clone()})}return a}function qt(i,t,e,n,o,s,c,a){const l=(i-e)*(s-a)-(t-n)*(o-c);if(Math.abs(l)<1e-10)return null;const u=((i-o)*(s-a)-(t-s)*(o-c))/l,r=-((i-e)*(t-s)-(t-n)*(i-o))/l;return u>=0&&u<=1&&r>=0&&r<=1?{x:i+u*(e-i),y:t+u*(n-t),t:u}:null}function Dt(i,t,e,n,o,s,c,a){const l=(i-e)*(s-a)-(t-n)*(o-c);if(Math.abs(l)<1e-10)return null;const u=((i-o)*(s-a)-(t-s)*(o-c))/l,r=-((i-e)*(t-s)-(t-n)*(i-o))/l;return r>=0&&r<=1?{x:i+u*(e-i),y:t+u*(n-t),t:u}:null}function tt(i,t,e){let n=!1;const o=e.length;for(let s=0,c=o-1;s<o;c=s++){const a=e[s].x,l=e[s].y,u=e[c].x,r=e[c].y;l>t!=r>t&&i<(u-a)*(t-l)/(r-l)+a&&(n=!n)}return n}const pt=.001;class V{constructor(t,e){this.x=t,this.y=e}static clone(t){return new V(t.x,t.y)}}class ct{constructor(t,e,n,o){this.minX=t,this.minY=e,this.maxX=n,this.maxY=o}width(){return Math.abs(this.maxX-this.minX)}height(){return Math.abs(this.maxY-this.minY)}}class At{constructor(t=0){this.r=t}}class q{constructor(t,e){this.a=t,this.b=e,this.tags={}}static isEqual(t,e){return S.pointsEqual(t.a,e.a)&&S.pointsEqual(t.b,e.b)||S.pointsEqual(t.b,e.a)&&S.pointsEqual(t.a,e.b)}static clone(t){return new q(new V(t.a.x,t.a.y),new V(t.b.x,t.b.y))}}class Bt{constructor(){this.pivot={x:0,y:0},this.rotation=0,this.isOpen=!0,this.isGroup=!1,this.isStrong=!1,this._makeAbsolute=t=>{let e=this.rotation*Math.PI/180;t.forEach((n,o)=>{const s={x:n.x,y:n.y};S.rotatePoint(s,e),s.x+=this.pivot.x,s.y+=this.pivot.y,t[o]=s})},this._makeSegsAbsolute=t=>{let e=this.rotation*Math.PI/180;t.forEach(n=>{const o={x:n.a.x,y:n.a.y},s={x:n.b.x,y:n.b.y};S.rotatePoint(o,e),S.rotatePoint(s,e),S.addToPoint(o,this.pivot),S.addToPoint(s,this.pivot),n.a=o,n.b=s})}}toPoints(t=!1){throw"not implemented"}toSegments(t=!1){throw"not implemented"}getBoundingBox(t=!1){const e=new ct(1e6,1e6,-1e6,-1e6);return this.toPoints(t).forEach(o=>{e.minX=Math.min(e.minX,o.x),e.minY=Math.min(e.minY,o.y),e.maxX=Math.max(e.maxX,o.x),e.maxY=Math.max(e.maxY,o.y)}),e}getBoundingCircle(){const t=new At;return this.toPoints(!0).forEach(n=>{t.r=Math.max(t.r,Math.sqrt(n.x*n.x+n.y*n.y))}),t}}class Z extends Bt{constructor(t){super(),this._segments=t}add(...t){this._segments=this._segments.concat(t)}toPoints(t=!1){return this.toSegments(t).reduce((e,n)=>n?e.concat([n.a,n.b]):e,[])}toSegments(t=!1){let e=this._segments.reduce((n,o)=>o?n.concat(q.clone(o)):n,[]);return t||this._makeSegsAbsolute(e),e}bake(){}result(){return Z.clone(this)}static clone(t){let e=t._segments,n=[],o=e.length;for(;o--;)n.unshift(q.clone(e[o]));let s=new Z(n);return s.pivot.x=t.pivot.x,s.pivot.y=t.pivot.y,s.rotation=t.rotation,s}}class S{static lerp(t,e,n){return(1-n)*t+n*e}static angleBetween(t,e){return Math.atan2(e.y-t.y,e.x-t.x)}static sameAngle(t,e){let n=S.angleBetween(t.a,t.b),o=S.angleBetween(e.a,e.b);return Math.abs(n-o)<pt}static sameAngleRev(t,e){let n=S.angleBetween(t.a,t.b),o=S.angleBetween(e.b,e.a);return Math.abs(n-o)<pt}static lerpPoints(t,e,n){return{x:S.lerp(t.x,e.x,n),y:S.lerp(t.y,e.y,n)}}static rotatePointDeg(t,e){S.rotatePoint(t,e*Math.PI/180)}static rotatePoint(t,e){const n=Math.cos(e),o=Math.sin(e),s=t.y,c=t.x;t.y=n*s-o*c,t.x=o*s+n*c}static rotatePoints(t,...e){e.forEach(n=>{S.rotatePoint(n,t)})}static rotatePointsDeg(t,...e){let n=t*Math.PI/180;e.forEach(o=>{S.rotatePoint(o,n)})}static outerTangents(t,e,n,o){var s=n.x-t.x,c=n.y-t.y,a=Math.sqrt(s*s+c*c);if(a<=Math.abs(o-e))return[];var l=Math.atan2(c,s),u=Math.acos((e-o)/a);return[new q({x:t.x+e*Math.cos(l+u),y:t.y+e*Math.sin(l+u)},{x:n.x+o*Math.cos(l+u),y:n.y+o*Math.sin(l+u)}),new q({x:t.x+e*Math.cos(l-u),y:t.y+e*Math.sin(l-u)},{x:n.x+o*Math.cos(l-u),y:n.y+o*Math.sin(l-u)})]}static cartesian2Polar(t){const e=Math.sqrt(t.x*t.x+t.y*t.y),n=Math.atan2(t.y,t.x);t.x=e,t.y=n}static pointsEqual(t,e,n=1){return Math.round(t.x*1e4/n)==Math.round(e.x*1e4/n)&&Math.round(t.y*1e4/n)==Math.round(e.y*1e4/n)}static distanceBetween(t,e){const n=e.x-t.x,o=e.y-t.y;return Math.sqrt(n*n+o*o)}static distanceBetweenSquared(t,e){const n=e.x-t.x,o=e.y-t.y;return n*n+o*o}static interpolatePoints(t,e,n){let o=[{x:t.x,y:t.y}],s=1/n,c=(e.x-t.x)*s,a=(e.y-t.y)*s;for(var l=1;l<n;l++)o.push(new V(t.x+c*l,t.y+a*l));return o.push({x:e.x,y:e.y}),o}static averagePoints(...t){let e=new V(0,0);return t.forEach(n=>{e.x+=n.x,e.y+=n.y}),e.x/=t.length,e.y/=t.length,e}static addToPoint(t,e){t.x+=e.x,t.y+=e.y}static subFromPoint(t,e){t.x-=e.x,t.y-=e.y}static subdivideByDistance(t,e,n){if(n===0)return[t,e];let o=[{x:t.x,y:t.y}],s=S.distanceBetween(t,e),c=n/s,a=Math.floor(1/c),l=s%n;n+=l/a,c=n/s;let u=c,r=1,d=(e.x-t.x)*c,f=(e.y-t.y)*c;for(;u<1;)o.push(new V(t.x+d*r,t.y+f*r)),u+=c,r++;return o.push({x:e.x,y:e.y}),o}static segmentsConnected(t,e,n=1){return S.pointsEqual(t.b,e.a,n)||S.pointsEqual(t.a,e.b,n)}static segmentsToPoints(t){let e=t.reduce((o,s)=>o.concat(s.a,s.b),[]),n=e.length;for(;n--;){let o=e[n];n>0&&S.pointsEqual(o,e[n-1])&&e.splice(n,1)}return e}static polygonArea(t){let e=0,n=t.length-1;for(var o=0;o<t.length;o++)e+=t[o].x*t[n].y,e-=t[n].x*t[o].y,n=o;return e/2}static pointsBoundingBox(t){const e=new ct(1e6,1e6,-1e6,-1e6);return t.forEach(n=>{e.minX=Math.min(e.minX,n.x),e.minY=Math.min(e.minY,n.y),e.maxX=Math.max(e.maxX,n.x),e.maxY=Math.max(e.maxY,n.y)}),e}static boundingBoxesBoundingBox(t){const e=new ct(1e6,1e6,-1e6,-1e6);return t.forEach(n=>{e.minX=Math.min(e.minX,n.minX),e.minY=Math.min(e.minY,n.minY),e.maxX=Math.max(e.maxX,n.maxX),e.maxY=Math.max(e.maxY,n.maxY)}),e}static segmentsBoundingBox(t){const e=[];return t.forEach(n=>{e.push(n.a),e.push(n.b)}),S.pointsBoundingBox(e)}static boundingBoxesIntersect(t,e){return t.maxX>=e.minX&&t.maxY>=e.minY&&t.minX<=e.maxX&&t.minY<=e.maxY}static polygonIsClockwise(t){return S.polygonArea(t)>0}static ccw(t,e,n){return(n.y-t.y)*(e.x-t.x)>(e.y-t.y)*(n.x-t.x)}static segmentsIntersect(t,e){const n=S.ccw;return n(t.a,e.a,e.b)!=n(t.b,e.a,e.b)&&n(t.a,t.b,e.a)!=n(t.a,t.b,e.b)}static segmentSegmentIntersect(t,e,n=!1){const o=t.a.x,s=t.a.y,c=t.b.x,a=t.b.y,l=e.a.x,u=e.a.y,r=e.b.x,d=e.b.y,f=c-o,g=a-s,x=r-l,m=d-u,b=(-g*(o-l)+f*(s-u))/(-x*g+f*m),p=(x*(s-u)-m*(o-l))/(-x*g+f*m);if(b>=0&&b<=1&&p>=0&&p<=1){const h=o+p*f,y=s+p*g;let w={x:h,y};return n&&(S.pointsEqual(w,e.a)||S.pointsEqual(w,e.b)||S.pointsEqual(w,t.a)||S.pointsEqual(w,t.b))?void 0:w}return null}static segmentSegmentsIntersections(t,e,n=!1){let o=[];return e.forEach(s=>{if(s==t)return;let c=S.segmentSegmentIntersect(t,s,n);c&&o.push(c)}),o}static dot(t,e){return t.x*e.x+t.y*e.y}static cross(t,e){return t.x*e.y-t.y*e.x}static lineSide(t,e,n){return Math.round(((n.x-e.x)*(t.y-e.y)-(n.y-e.y)*(t.x-e.x))*100)/100}static sub(t,e){return new V(t.x-e.x,t.y-e.y)}static add(t,e){return new V(t.x+e.x,t.y+e.y)}static closestPtPointSegment(t,e){var n=S.sub(e.b,e.a),o=S.sub(t,e.a),s=S.dot(o,n);if(s<0)t=e.a;else{var c=S.dot(n,n);s>=c?t=e.b:(s/=c,o.x=e.a.x+s*n.x,o.y=e.a.y+s*n.y,t=o)}return V.clone(t)}static distancePointSegment(t,e){return S.distanceBetween(t,S.closestPtPointSegment(t,e))}static pointWithinBoundingBox(t,e){return t.x>=e.minX&&t.y>=e.minY&&t.x<=e.maxX&&t.y<=e.maxY}static pointWithinPolygon(t,e,n){const o=S.segmentsBoundingBox(e);if(!this.pointWithinBoundingBox(t,o))return!1;let s=new V(1e5,1e5),c=new q(s,t),a=S.segmentSegmentsIntersections(c,e);return a.length%2!=0&&n&&S.pointsEqual(t,a[0])?!1:a.length%2!=0}static segmentWithinPolygon(t,e){let n=this.pointWithinPolygon(t.a,e,!1),o=this.pointWithinPolygon(t.b,e,!1),s=this.pointWithinPolygon(t.a,e,!0),c=this.pointWithinPolygon(t.b,e,!0);return s&&c||s&&o||c&&n}static sign(t,e,n){return(t.x-n.x)*(e.y-n.y)-(e.x-n.x)*(t.y-n.y)}static pointWithinTriangle(t,e,n,o,s){const c=S.sign(t,e,n),a=S.sign(t,n,o),l=S.sign(t,o,e),u=c<0||a<0||l<0,r=c>0||a>0||l>0;if(!(u&&r)&&s){let d={a:e,b:n,tags:null};if(S.distancePointSegment(t,d)<1||(d.a=n,d.b=o,S.distancePointSegment(t,d)<1)||(d.a=o,d.b=e,S.distancePointSegment(t,d)<1))return!1}return!(u&&r)}static segmentWithinTriangle(t,e,n,o){let s=this.pointWithinTriangle(t.a,e,n,o,!1),c=this.pointWithinTriangle(t.b,e,n,o,!1),a=this.pointWithinTriangle(t.a,e,n,o,!0),l=this.pointWithinTriangle(t.b,e,n,o,!0);return S.averagePoints(t.a,t.b),a&&l||a&&c||l&&s||s&&c}static pointsToClosedPolySegments(...t){let e=[];for(let n=0;n<t.length;n++)e.push(new q(t[n],n<t.length-1?t[n+1]:t[0]));return e}static polygonWithinPolygon(t,e){const n=S.segmentsBoundingBox(t),o=S.segmentsBoundingBox(e);if(!S.boundingBoxesIntersect(n,o))return!1;new V(o.minX-100,o.minY-100);for(let s=0;s<t.length;s++){let c=t[s];if(S.segmentSegmentsIntersections(c,e).length%2==0)return!1}return!0}static splinePoints(t,e,n,o=0){let s=a=>{let l=[a[0]];for(let u=0;u<a.length-1;u++){let r=new V(0,0);u+1<a.length*.4?(r.x=(a[u].x*40+a[u+1].x*60)*.01,r.y=(a[u].y*40+a[u+1].y*60)*.01):u+1>a.length*.6?(r.x=(a[u].x*60+a[u+1].x*40)*.01,r.y=(a[u].y*60+a[u+1].y*40)*.01):(r.x=(a[u].x+a[u+1].x)*.5,r.y=(a[u].y+a[u+1].y)*.5),l.push(r)}return l.push(a[a.length-1]),l},c=[t,e,n];for(let a=0;a<o;a++)c=s(c);return c}}class J{static getSegsAndConnections(t,e=!1,n=!1){let o={},s=[],c={},a=l=>{let u=`${Math.round(l.x*1)}|${Math.round(l.y*1)}`;return c[u]=l,u};if(e){let l=t.reduce((d,f)=>d.concat(f.a,f.b),[]),u=l.length;for(;u--;){let d=l[u],f=u;for(;f--;){let g=l[f];if(S.pointsEqual(d,g)){l.splice(u,1);break}}}let r=t.length;for(;r--;){let d=t[r],f=[];if(l.forEach(g=>{S.distancePointSegment(g,d)<.1&&!S.pointsEqual(g,d.a)&&!S.pointsEqual(g,d.b)&&f.push(g)}),f.length){f.sort((m,b)=>{const p=S.distanceBetweenSquared(m,d.a),h=S.distanceBetweenSquared(b,d.a);return p<h?-1:p>h?1:0});const g=[];let x=d.a;for(let m=0;m<f.length;m++){let b=f[m];g.push(new q(x,b)),x=b}g.push(new q(x,d.b)),t.splice(r,1,...g)}}}if(n){let l=t.length;for(;l--;){let u=l,r=!1;for(;u--;){let d=t[l],f=t[u],g=S.segmentSegmentIntersect(d,f,!0);g&&(r=!0,t.splice(l,1,new q(V.clone(d.a),V.clone(g)),new q(V.clone(g),V.clone(d.b))),t.splice(u,1,new q(V.clone(f.a),V.clone(g)),new q(V.clone(g),V.clone(f.b))))}r&&(l=t.length)}}return t.forEach(l=>{let u=a(l.a),r=a(l.b);o[u]||(o[u]=[]),o[r]||(o[r]=[]),o[u].indexOf(r)===-1&&o[u].push(r),o[r].indexOf(u)===-1&&o[r].push(u),s.indexOf(u)===-1&&s.push(u),s.indexOf(r)===-1&&s.push(r)}),{originalPts:c,pts:s,cxs:o}}static pathOrder(t,e=!1,n=!1){let o=[],{originalPts:s,pts:c,cxs:a}=J.getSegsAndConnections(t,e,n),l=r=>s[r],u=(r,d)=>a[r].length>a[d].length?1:a[r].length<a[d].length?-1:0;for(c.sort(u);c.length;){c.sort(u);let r=c.shift();for(;r;)if(a[r].length){a[r].sort(u);let d=a[r].shift(),f=a[d].indexOf(r);f!==-1&&a[d].splice(f,1),o.push(new q(l(r),l(d))),a[r].length&&c.unshift(r),r=d}else r=null}return o}static getEndingSegmentPoints(t,e=0){t=t.concat(),t=J.pathOrder(t,!0,!0);let{originalPts:n,pts:o,cxs:s}=J.getSegsAndConnections(t,!0),c=u=>n[u];const a=o.filter(u=>s[u].length===1),l=[];return a.forEach(u=>{const r=V.clone(c(u));if(e===0){l.push(r);return}const d=c(s[u]),f=S.angleBetween(d,r),g=new V(0,e);S.rotatePoint(g,Math.PI*.5-f),S.addToPoint(r,g),l.push(r)}),l}static getFills(t,e=5){t=t.concat();let{originalPts:n,cxs:o}=J.getSegsAndConnections(t,!0,!0),s=h=>{let y=`${Math.round(h.x*1)}|${Math.round(h.y*1)}`;return n[y]=h,y},c=[],a=[],l=1e5,u=1e5,r=-1e5,d=-1e5,f=1e5,g=1e5,x=[];for(let h in n){let y=n[h];x.push(y),l=Math.min(l,y.x),u=Math.min(u,y.y),r=Math.max(r,y.x),d=Math.max(d,y.y)}x.sort((h,y)=>h.x<y.x?-1:h.x>y.x?1:0),x.forEach((h,y)=>{if(y>0){let w=x[y-1],P=Math.round(Math.abs(h.x-w.x));P>1&&(f=Math.min(f,P))}}),x.sort((h,y)=>h.y<y.y?-1:h.y>y.y?1:0),x.forEach((h,y)=>{if(y>0){let w=x[y-1],P=Math.round(Math.abs(h.y-w.y));P>1&&(g=Math.min(g,P))}});let m=f*.5,b=g*.5,p=[];for(let h=u;h<d;h+=g)for(let y=l;y<r;y+=f)p.push(new V(y+m,h+b));return p.forEach(h=>{let y=[];if(x.forEach(E=>{let v=S.distanceBetween(E,h);if(v<Math.max(f,g)*e){let k=S.angleBetween(E,h);y.push({pt:E,dist:v,ang:k})}}),y.length<4)return;let w=y.length;for(;w--;){let E=y[w].pt,v=new q(h,E);S.segmentSegmentsIntersections(v,t,!0).length>0&&y.splice(w,1)}for(y.sort((E,v)=>E.ang<v.ang?-1:E.ang>v.ang?1:0),w=y.length;w--;){let E=y[w].pt,v=s(E),k=y.length,I=!1;for(;k--;){if(w===k)continue;let F=y[k].pt,O=s(F);if(o[v].indexOf(O)===-1){I=!0;break}}I||y.splice(w,1)}let P=!0;if(y.forEach((E,v)=>{let k=y[(v+1)%y.length],I=s(E.pt),F=s(k.pt);o[I].indexOf(F)===-1&&(P=!1)}),P){let E=y.map(I=>I.pt),v=S.averagePoints(...E),k=s(v);c.indexOf(k)===-1&&(c.push(k),a.push(E))}}),a}}class G{static segmentCollections(t,e=!1,n=!0,o=1,s=!1,c=!1,a=!1){let l=t.reduce((u,r)=>u.concat(r.toSegments()),[]);return G.segments(l,e,n,o,s,c,a)}static segmentCollectionsPathOrder(t,e=!1,n=!1){let o=t.reduce((s,c)=>s.concat(c.toSegments()),[]);return new Z(J.pathOrder(o,e,n))}static segments(t,e=!1,n=!0,o=1,s=!1,c=!1,a=!1){return t=G._segments(t,e,n,o),s&&(t=J.pathOrder(t,c,a)),new Z(t)}static _segments(t,e,n,o){const s=t;for(t=[];s.length;){let a=s.shift(),l=t.length,u=!1;for(;l--;){const r=t[l];if(q.isEqual(a,r)){u=!0;break}}u||t.push(a)}if(!e)for(let a=0;a<3;a++){let l=t.length;for(;l--;){let u=t[l],r,d,f,g,x;for(let m=l-1;m>=0;m--){let b=t[m],p=!1,h=!1;if(S.sameAngle(u,b)?(p=!0,r=V.clone(u.a),d=V.clone(u.b),f=V.clone(b.a),g=V.clone(b.b)):S.sameAngleRev(u,b)&&(p=h=!0,r=V.clone(u.b),d=V.clone(u.a),f=V.clone(b.a),g=V.clone(b.b)),p&&(x=S.angleBetween(r,d),S.rotatePoints(x,r,d,f,g),Math.abs(r.y-f.y)<.1&&d.x>=f.x-1e-4&&r.x<=g.x+1e-4)){r.x<f.x&&(h?b.a=u.b:b.a=u.a),d.x>g.x&&(h?b.b=u.a:b.b=u.b),t.splice(l,1);break}}}}let c=t.length;for(;c--;){let a=t[c];if(!a){t.splice(c,1);continue}if(n&&S.distanceBetween(a.a,a.b)<o){t.splice(c,1);continue}}return console.log(`[JS] Optimize: ${s.length+t.length} -> ${t.length} segments`),t}}function mt(i,t){const e=i.geometry,n=e.attributes.position,o=e.index;if(!n)return[];const s=new Map,c=1e3,a=(d,f)=>{const g=Math.round(d.x*c),x=Math.round(d.y*c),m=Math.round(d.z*c),b=Math.round(f.x*c),p=Math.round(f.y*c),h=Math.round(f.z*c),y=`${g},${x},${m}`,w=`${b},${p},${h}`;return y<w?`${y}|${w}`:`${w}|${y}`},l=d=>new M.Vector3(n.getX(d),n.getY(d),n.getZ(d)).applyMatrix4(i.matrixWorld),u=(d,f,g)=>{const x=new M.Vector3().subVectors(f,d),m=new M.Vector3().subVectors(g,d);return new M.Vector3().crossVectors(x,m).normalize()},r=o?o.count/3:n.count/3;for(let d=0;d<r;d++){let f,g,x;o?(f=o.getX(d*3),g=o.getX(d*3+1),x=o.getX(d*3+2)):(f=d*3,g=d*3+1,x=d*3+2);const m=l(f),b=l(g),p=l(x),h=u(m,b,p),y=new M.Vector3().addVectors(m,b).add(p).divideScalar(3),w=new M.Vector3().subVectors(t,y);if(h.dot(w)<=0)continue;const P=[[m,b],[b,p],[p,m]];for(const[E,v]of P){const k=a(E,v);if(s.has(k)){const I=s.get(k);I&&!I.normal2&&(I.normal2=h.clone(),I.faceIdx2=d)}else s.set(k,{a:E.clone(),b:v.clone(),normal1:h.clone(),faceIdx1:d,mesh:i})}}return Array.from(s.values())}function bt(i,t){return i.filter(e=>{const n=new M.Vector3().addVectors(e.a,e.b).multiplyScalar(.5),o=new M.Vector3().subVectors(t,n).normalize(),s=e.normal1.dot(o)>0;if(!e.normal2)return!0;const c=e.normal2.dot(o)>0;return s||c})}function wt(i,t,e=.99){const n=[],o=[];for(const s of i){const c=new M.Vector3().addVectors(s.a,s.b).multiplyScalar(.5),a=new M.Vector3().subVectors(t,c).normalize(),l=s.normal1.dot(a)>0,u=s.normal2?s.normal2.dot(a)>0:!0;if(l!==u||!s.normal2){n.push(s);continue}s.normal2&&s.normal1.dot(s.normal2)<e&&o.push(s)}return console.log(`classifyEdges: ${n.length} profiles, ${o.length} smooth/crease edges`),{profiles:n,smoothFiltered:o}}function rt(i,t,e,n,o=1){const s=e/2,c=n/2,a=l=>{const u=l.clone().project(t);return new M.Vector2(u.x*s*o,-u.y*c*o)};return i.map(l=>({a:a(l.a),b:a(l.b),a3d:l.a.clone(),b3d:l.b.clone(),midpoint3d:new M.Vector3().addVectors(l.a,l.b).multiplyScalar(.5),isProfile:!1,visible:!0,faceIdx:l.faceIdx1,faceIdx2:l.faceIdx2,mesh:l.mesh,isHatch:l.isHatch,normal1:l.normal1,normal2:l.normal2}))}class Wt{constructor(t){this.cellSize=t,this.cells=new Map}getCellKey(t,e){const n=Math.floor(t/this.cellSize),o=Math.floor(e/this.cellSize);return`${n},${o}`}getCellsCrossed(t){const e=new Set,n=Math.abs(t.b.x-t.a.x),o=Math.abs(t.b.y-t.a.y),s=Math.max(n,o)/this.cellSize+1;for(let c=0;c<=s;c++){const a=c/s,l=t.a.x+a*(t.b.x-t.a.x),u=t.a.y+a*(t.b.y-t.a.y);e.add(this.getCellKey(l,u))}return Array.from(e)}insert(t){var n;const e=this.getCellsCrossed(t);for(const o of e)this.cells.has(o)||this.cells.set(o,[]),(n=this.cells.get(o))==null||n.push(t)}query(t){return this.cells.get(t)||[]}getAllCells(){return Array.from(this.cells.keys())}clear(){this.cells.clear()}}function Ht(i,t){const e=i.a.x,n=i.a.y,o=i.b.x,s=i.b.y,c=t.a.x,a=t.a.y,l=t.b.x,u=t.b.y,r=(e-o)*(a-u)-(n-s)*(c-l);if(Math.abs(r)<1e-10)return null;const d=((e-c)*(a-u)-(n-a)*(c-l))/r,f=-((e-o)*(n-a)-(n-s)*(e-c))/r,g=.001;return d>g&&d<1-g&&f>g&&f<1-g?{t1:d,t2:f,point:new M.Vector2(e+d*(o-e),n+d*(s-n))}:null}function Mt(i){var c,a,l,u,r,d;const t=new Map,e=.01,n=(f,g)=>{const x=g.b.x-g.a.x,m=g.b.y-g.a.y,b=x*x+m*m;if(b<1e-10)return null;const p=((f.x-g.a.x)*x+(f.y-g.a.y)*m)/b;if(p<=e||p>=1-e)return null;const h=g.a.x+p*x,y=g.a.y+p*m;return(f.x-h)*(f.x-h)+(f.y-y)*(f.y-y)<1?p:null},o=new Set;for(let f=0;f<i.length;f++)for(let g=f+1;g<i.length;g++){const x=Ht(i[f],i[g]);if(x)t.has(i[f])||t.set(i[f],[]),t.has(i[g])||t.set(i[g],[]),(c=t.get(i[f]))==null||c.push({t:x.t1,point:x.point}),(a=t.get(i[g]))==null||a.push({t:x.t2,point:x.point});else{const m=n(i[f].a,i[g]);m!==null&&(t.has(i[g])||t.set(i[g],[]),(l=t.get(i[g]))==null||l.push({t:m,point:i[f].a.clone()}),o.add(i[f]),o.add(i[g]));const b=n(i[f].b,i[g]);b!==null&&(t.has(i[g])||t.set(i[g],[]),(u=t.get(i[g]))==null||u.push({t:b,point:i[f].b.clone()}),o.add(i[f]),o.add(i[g]));const p=n(i[g].a,i[f]);p!==null&&(t.has(i[f])||t.set(i[f],[]),(r=t.get(i[f]))==null||r.push({t:p,point:i[g].a.clone()}),o.add(i[f]),o.add(i[g]));const h=n(i[g].b,i[f]);h!==null&&(t.has(i[f])||t.set(i[f],[]),(d=t.get(i[f]))==null||d.push({t:h,point:i[g].b.clone()}),o.add(i[f]),o.add(i[g]))}}console.log(`T-junction detection: ${o.size} potential straggler edges`);const s=[];for(const f of i){const g=t.get(f),x=o.has(f);if(!g||g.length===0){f.isTJunctionStraggler=x,s.push(f);continue}g.sort((p,h)=>p.t-h.t);let m=f.a,b=f.a3d;for(const p of g){const h=new M.Vector3().lerpVectors(f.a3d,f.b3d,p.t);s.push({a:m.clone(),b:p.point.clone(),a3d:b.clone(),b3d:h.clone(),midpoint3d:new M.Vector3().addVectors(b,h).multiplyScalar(.5),isProfile:f.isProfile,visible:f.visible,faceIdx:f.faceIdx,mesh:f.mesh,isHatch:f.isHatch,normal1:f.normal1,isTJunctionStraggler:x}),p.t,m=p.point,b=h}s.push({a:m.clone(),b:f.b.clone(),a3d:b.clone(),b3d:f.b3d.clone(),midpoint3d:new M.Vector3().addVectors(b,f.b3d).multiplyScalar(.5),isProfile:f.isProfile,visible:f.visible,faceIdx:f.faceIdx,mesh:f.mesh,isHatch:f.isHatch,normal1:f.normal1,isTJunctionStraggler:x})}return s}function Rt(i,t,e,n,o,s,c=!1){if(c)return i.forEach(x=>x.visible=!0),i;const a=[];if(!s)return console.warn("No renderer provided, skipping occlusion test"),i;const l=new M.WebGLRenderTarget(n,o,{minFilter:M.NearestFilter,magFilter:M.NearestFilter,format:M.RGBAFormat,type:M.UnsignedByteType}),u=new M.ShaderMaterial({vertexShader:`
            attribute vec3 faceColor;
            varying vec3 vFaceColor;
            void main() {
                vFaceColor = faceColor;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `,fragmentShader:`
            varying vec3 vFaceColor;
            void main() {
                gl_FragColor = vec4(vFaceColor, 1.0);
            }
        `,side:M.DoubleSide}),r=[];let d=0;for(const x of t){x.__globalFaceOffset=d;const m=x.geometry,b=m.attributes.position,p=m.index,h=p?p.count/3:b.count/3,y=[],w=[];for(let v=0;v<h;v++){let k,I,F;p?(k=p.getX(v*3),I=p.getX(v*3+1),F=p.getX(v*3+2)):(k=v*3,I=v*3+1,F=v*3+2);const O=new M.Vector3(b.getX(k),b.getY(k),b.getZ(k)),B=new M.Vector3(b.getX(I),b.getY(I),b.getZ(I)),$=new M.Vector3(b.getX(F),b.getY(F),b.getZ(F));O.applyMatrix4(x.matrixWorld),B.applyMatrix4(x.matrixWorld),$.applyMatrix4(x.matrixWorld),y.push(O.x,O.y,O.z,B.x,B.y,B.z,$.x,$.y,$.z);const z=d+v+1,C=(z&255)/255,T=(z>>8&255)/255,H=(z>>16&255)/255;w.push(C,T,H,C,T,H,C,T,H)}const P=new M.BufferGeometry;P.setAttribute("position",new M.BufferAttribute(new Float32Array(y),3)),P.setAttribute("faceColor",new M.BufferAttribute(new Float32Array(w),3));const E=new M.Mesh(P,u);r.push(E),d+=h}const f=new M.Scene;for(const x of r)f.add(x);s.setRenderTarget(l),s.setClearColor(0,1),s.clear(),s.render(f,e);const g=new Uint8Array(n*o*4);s.readRenderTargetPixels(l,0,0,n,o,g),s.setRenderTarget(null);for(const x of i){const m=(x.a.x+x.b.x)/2,b=(x.a.y+x.b.y)/2,p=Math.round(m+n/2),h=Math.round(o/2+b);if(p<0||p>=n||h<0||h>=o){x.visible=!0,a.push(x);continue}const y=((o-1-h)*n+p)*4,w=g[y],P=g[y+1],E=g[y+2],v=w+(P<<8)+(E<<16);if(v===0){x.visible=!0,a.push(x);continue}const k=x.mesh.__globalFaceOffset||0,I=k+x.faceIdx+1;if(v===I)x.visible=!0,a.push(x);else{if(x.faceIdx2!==void 0){const F=k+x.faceIdx2+1;if(v===F){x.visible=!0,a.push(x);continue}}x.visible=!1}}l.dispose(),u.dispose();for(const x of r)x.geometry.dispose();return a}function Lt(i,t,e,n){const o=(r,d,f)=>(r.x-f.x)*(d.y-f.y)-(d.x-f.x)*(r.y-f.y),s=o(i,t,e),c=o(i,e,n),a=o(i,n,t),l=s<0||c<0||a<0,u=s>0||c>0||a>0;return!(l&&u)}function Nt(i,t,e,n,o=2){const s=n.x-e.x,c=n.y-e.y,a=s*s+c*c;if(a<1e-10)return!1;const l=u=>{const r=((u.x-e.x)*s+(u.y-e.y)*c)/a,d=e.x+r*s,f=e.y+r*c;return(u.x-d)*(u.x-d)+(u.y-f)*(u.y-f)<o*o&&r>=-.01&&r<=1.01};return l(i)&&l(t)}function jt(i,t){const e=[];for(const n of t){const o=[{a:n.a2d,b:n.b2d,name:"AB"},{a:n.b2d,b:n.c2d,name:"BC"},{a:n.c2d,b:n.a2d,name:"CA"}];for(const s of o)if(Nt(i.a,i.b,s.a,s.b)){e.push({face:n,matchedEdge:s.name,matchType:"collinear"});break}}return e}function Jt(i,t,e,n,o,s,c){const a={x:n.x-t.x,y:n.y-t.y},l={x:e.x-t.x,y:e.y-t.y},u={x:i.x-t.x,y:i.y-t.y},r=a.x*a.x+a.y*a.y,d=a.x*l.x+a.y*l.y,f=a.x*u.x+a.y*u.y,g=l.x*l.x+l.y*l.y,x=l.x*u.x+l.y*u.y,m=r*g-d*d;if(Math.abs(m)<1e-10)return 1/0;const b=(g*f-d*x)/m,p=(r*x-d*f)/m;return(1-b-p)*o+p*s+b*c}function Zt(i,t,e=.99,n=.5){const o=[];let s=0;for(const c of i){const a=jt(c,t);c.adjacentFaceCount=a.length;let l=!1;if(a.length===2){const u=a[0].face,r=a[1].face,d=u.normal,f=r.normal;if(d&&f){const g=d.dot(f),x=Math.abs(g);c.faceSimilarity=x;let m;g>0?m=Math.abs(u.constant-r.constant):m=Math.abs(u.constant+r.constant),x>=e&&m<n&&(l=!0,s++)}}else if(a.length>2){const u=a.map(r=>r.face).filter(r=>r.normal);if(u.length>=2){let r=!0,d=1;for(let f=1;f<u.length;f++){const g=u[0].normal.dot(u[f].normal),x=Math.abs(g);let m;if(g>0?m=Math.abs(u[0].constant-u[f].constant):m=Math.abs(u[0].constant+u[f].constant),d=Math.min(d,x),x<e||m>=n){r=!1;break}}c.faceSimilarity=d,r&&(l=!0,s++)}}l||o.push(c)}return console.log(`Geometric straggler filter: removed ${s} coplanar edges`),o}function Kt(i,t,e){const n=e.position,o=e.matrixWorldInverse;return Qt(i,t,n,o)}function Qt(i,t,e,n){const o=[];let s=0,c=0;for(const a of i){const l=new M.Vector2((a.a.x+a.b.x)/2,(a.a.y+a.b.y)/2),u=a.midpoint3d;let r;n?r=-u.clone().applyMatrix4(n).z:r=e.distanceTo(u);let d=!1;for(const f of t){if(f.mesh===a.mesh&&(f.faceIdx===a.faceIdx||f.faceIdx===a.faceIdx2)||!Lt(l,f.a2d,f.b2d,f.c2d))continue;if(Jt(l,f.a2d,f.b2d,f.c2d,f.depthA,f.depthB,f.depthC)<r-.001){d=!0,c++;break}s++}d?a.visible=!1:(a.visible=!0,o.push(a))}return console.log(`[JS] Occlusion debug: ${s} point-in-triangle hits, ${c} occluded`),o}function _t(i,t,e,n=.05){const o=new M.Raycaster,s=[],c=[];t.traverse(a=>{a.isMesh&&c.push(a)});for(const a of i){const l=new M.Vector3().subVectors(a.midpoint3d,e.position),u=l.clone().normalize(),r=l.length(),d=r*n;o.set(e.position.clone(),u);const f=o.intersectObjects(c,!0);if(f.length===0)a.visible=!0,s.push(a);else{let g=!1;for(const x of f)if(!(x.distance>=r-d)&&!(x.object===a.mesh&&x.faceIndex===a.faceIdx)){g=!0;break}g?a.visible=!1:(a.visible=!0,s.push(a))}}return s}function at(i,t=.5){const e=new Map,n=s=>`${Math.round(s.x/t)},${Math.round(s.y/t)}`,o=s=>{const c=n(s.a),a=n(s.b);return c<a?`${c}-${a}`:`${a}-${c}`};for(const s of i){const c=o(s);e.has(c)||e.set(c,s)}return Array.from(e.values())}function lt(i,t=1,e=50){const n=p=>`${Math.round(p.x/t)},${Math.round(p.y/t)}`,o=new Map;for(const p of i)for(const h of["a","b"]){const y=h==="a"?p.a:p.b,w=n(y);o.has(w)||o.set(w,{edges:[],point:{x:y.x,y:y.y}}),o.get(w).edges.push({edge:p,endpoint:h})}const s=[];for(const[p,h]of o)if(h.edges.length===1){const{edge:y,endpoint:w}=h.edges[0],P=h.point,E=w==="a"?y.b:y.a,v=P.x-E.x,k=P.y-E.y,I=Math.sqrt(v*v+k*k);if(I<.001)continue;s.push({key:p,edge:y,endpoint:w,point:P,otherPoint:E,dirX:v/I,dirY:k/I,len:I})}if(console.log(`Edge cleanup: found ${s.length} orphaned endpoints`),s.length===0)return i;const c=(p,h,y,w)=>{const P=h.x*w.y-h.y*w.x;if(Math.abs(P)<1e-4)return null;const E=y.x-p.x,v=y.y-p.y,k=(E*w.y-v*w.x)/P,I=(E*h.y-v*h.x)/P;return{t1:k,t2:I}};let a=0;const l=new Set;for(let p=0;p<s.length;p++){const h=s[p];if(l.has(h.key))continue;let y=null,w=null,P=1/0;for(let E=0;E<s.length;E++){if(p===E)continue;const v=s[E];if(l.has(v.key)||Math.sqrt((v.point.x-h.point.x)**2+(v.point.y-h.point.y)**2)>e*2)continue;const I=c({x:h.point.x,y:h.point.y},{x:h.dirX,y:h.dirY},{x:v.point.x,y:v.point.y},{x:v.dirX,y:v.dirY});if(!I||I.t1<-.1||I.t2<-.1||I.t1>e||I.t2>e)continue;const F=h.point.x+I.t1*h.dirX,O=h.point.y+I.t1*h.dirY,B=I.t1+I.t2;B<P&&(P=B,y=v,w={x:F,y:O})}if(y&&w){const E=vt(h.point,w,i,h.edge,y.edge),v=vt(y.point,w,i,h.edge,y.edge);if(E||v)continue;h.endpoint==="a"?(h.edge.a.x=w.x,h.edge.a.y=w.y):(h.edge.b.x=w.x,h.edge.b.y=w.y),y.endpoint==="a"?(y.edge.a.x=w.x,y.edge.a.y=w.y):(y.edge.b.x=w.x,y.edge.b.y=w.y),l.add(h.key),l.add(y.key),a++}}console.log(`Edge cleanup: extended ${a} pairs of edges to intersections`);let u=0;for(const p of i){const h=p.b.x-p.a.x,y=p.b.y-p.a.y;u+=Math.sqrt(h*h+y*y)}const r=u/i.length,d=r/8;console.log(`Edge cleanup: average edge length = ${r.toFixed(2)}, snap threshold = ${d.toFixed(2)}`);const f=new Map;for(const p of i)for(const h of["a","b"]){const y=h==="a"?p.a:p.b,w=n(y);f.has(w)||f.set(w,{edges:[],point:y}),f.get(w).edges.push({edge:p,endpoint:h})}const g=[];for(const[p,h]of f)h.edges.length===1&&g.push({key:p,...h.edges[0],point:h.point});console.log(`Edge cleanup: ${g.length} orphaned endpoints before snap pass`);let x=0;const m=new Set;for(let p=0;p<g.length;p++){const h=g[p];if(m.has(h.key))continue;let y=null,w=1/0;for(let P=0;P<g.length;P++){if(p===P)continue;const E=g[P];if(m.has(E.key))continue;const v=Math.sqrt((E.point.x-h.point.x)**2+(E.point.y-h.point.y)**2);v<w&&(w=v,y=E)}if(y&&w<d){const P=(h.point.x+y.point.x)/2,E=(h.point.y+y.point.y)/2;h.endpoint==="a"?(h.edge.a.x=P,h.edge.a.y=E):(h.edge.b.x=P,h.edge.b.y=E),y.endpoint==="a"?(y.edge.a.x=P,y.edge.a.y=E):(y.edge.b.x=P,y.edge.b.y=E),m.add(h.key),m.add(y.key),x++}}console.log(`Edge cleanup: snapped ${x} pairs of nearby orphans`);const b=g.length-x*2;return console.log(`Edge cleanup: ${b} orphaned endpoints remaining`),i}function Gt(i,t=1){const e=c=>`${Math.round(c.x/t)},${Math.round(c.y/t)}`,n=new Map;for(const c of i){const a=e(c.a),l=e(c.b);n.set(a,(n.get(a)||0)+1),n.set(l,(n.get(l)||0)+1)}const o=i.filter(c=>{const a=e(c.a),l=e(c.b),u=n.get(a)||0,r=n.get(l)||0;return u>=2||r>=2}),s=i.length-o.length;return s>0&&console.log(`Edge cleanup: removed ${s} isolated edges (orphaned at both ends)`),o}function vt(i,t,e,n,o){for(const c of e){if(c===n||c===o)continue;const a=t.x-i.x,l=t.y-i.y,u=c.b.x-c.a.x,r=c.b.y-c.a.y,d=a*r-l*u;if(Math.abs(d)<.001)continue;const f=c.a.x-i.x,g=c.a.y-i.y,x=(f*r-g*u)/d,m=(f*l-g*a)/d;if(x>.001&&x<1-.001&&m>.001&&m<1-.001)return!0}return!1}function Ut(i,t,e,n={}){const{smoothThreshold:o=.99,gridSize:s=32,occlusionEpsilon:c=.01,skipOcclusion:a=!1,width:l=800,height:u=600,renderer:r=null}=n;console.time("extractEdges");const d=mt(i,t.position);console.timeEnd("extractEdges"),console.log(`Extracted ${d.length} edges`),console.time("filterBackfacing");const f=bt(d,t.position);console.timeEnd("filterBackfacing"),console.log(`After backface filter: ${f.length} edges`),console.time("classifyEdges");const{profiles:g,smoothFiltered:x}=wt(f,t.position,o);console.timeEnd("classifyEdges"),console.log(`Profiles: ${g.length}, Smooth edges: ${x.length}`);const m=[...g,...x];console.time("projectEdges");let b=rt(m,t,l,u);console.timeEnd("projectEdges");for(let k=0;k<g.length;k++)b[k].isProfile=!0;console.time("spatialHash");const p=Math.max(l,u)/s,h=new Wt(p);for(const k of b)h.insert(k);console.timeEnd("spatialHash"),console.time("splitIntersections");const y=new Set;let w=[];for(const k of h.getAllCells()){const I=h.query(k).filter(O=>!y.has(O)),F=Mt(I);w.push(...F);for(const O of I)y.add(O)}console.timeEnd("splitIntersections"),console.log(`After splitting: ${w.length} edges`);let P;if(a)console.log("Skipping occlusion test (debug mode)"),P=w;else if(r){console.time("testOcclusion (face ID buffer)");const k=w.filter(O=>O.isProfile),I=w.filter(O=>!O.isProfile);k.forEach(O=>O.visible=!0);const F=Rt(I,[i],t,l,u,r,!1);P=[...k,...F],console.timeEnd("testOcclusion (face ID buffer)")}else console.time("testOcclusion (raycaster - slow)"),P=_t(w,e,t,c),console.timeEnd("testOcclusion (raycaster - slow)");console.log(`Visible edges: ${P.length}`),console.time("optimize");const E=at(P);console.timeEnd("optimize"),console.time("cleanup orphans");const v=lt(E);return console.timeEnd("cleanup orphans"),console.log(`Final edges: ${v.length}`),{edges:v,profiles:v.filter(k=>k.isProfile)}}function Et(i,t,e,n={}){const{smoothThreshold:o=.99,gridSize:s=32,skipOcclusion:c=!1,width:a=800,height:l=600,renderer:u=null,internalScale:r=4,distanceThreshold:d=.5}=n;let f=[];for(const $ of i){$.updateMatrixWorld(!0);const z=mt($,t.position);f.push(...z)}console.log(`Extracted ${f.length} edges from ${i.length} meshes`);const{profiles:g,smoothFiltered:x}=wt(f,t.position,o);console.log(`Profiles: ${g.length}, Crease edges: ${x.length}`);const m=[...g,...x];console.log(`After smooth filter: ${m.length} edges`);let b=rt(m,t,a,l,r);if(n.hatchEdges&&n.hatchEdges.length>0){console.log(`Processing ${n.hatchEdges.length} hatch edges...`);let $=bt(n.hatchEdges,t.position);if(n.minHatchDotProduct!==void 0){const C=n.minHatchDotProduct;$=$.filter(T=>{const H=new M.Vector3().addVectors(T.a,T.b).multiplyScalar(.5),D=new M.Vector3().subVectors(t.position,H).normalize(),W=T.normal1.dot(D);return Math.abs(W)>=C}),console.log(`Density filter: kept ${$.length} hatch edges (threshold ${C})`)}const z=rt($,t,a,l,r);z.forEach(C=>C.isHatch=!0),b.push(...z),console.log(`Added ${z.length} visible hatch edges`)}console.time("splitIntersections");const p=Mt(b);console.timeEnd("splitIntersections"),console.log(`After splitting: ${p.length} edges`),console.time("buildProjectedFaces");const h=[],y=t.position,w=a/2,P=l/2;for(const $ of i){const z=$.geometry,C=z.attributes.position,T=z.index,H=T?T.count/3:C.count/3;for(let D=0;D<H;D++){let W,N,K;T?(W=T.getX(D*3),N=T.getX(D*3+1),K=T.getX(D*3+2)):(W=D*3,N=D*3+1,K=D*3+2);const Y=new M.Vector3(C.getX(W),C.getY(W),C.getZ(W)).applyMatrix4($.matrixWorld),A=new M.Vector3(C.getX(N),C.getY(N),C.getZ(N)).applyMatrix4($.matrixWorld),L=new M.Vector3(C.getX(K),C.getY(K),C.getZ(K)).applyMatrix4($.matrixWorld),Q=new M.Vector3().subVectors(A,Y),U=new M.Vector3().subVectors(L,Y),j=new M.Vector3().crossVectors(Q,U).normalize(),_=new M.Vector3().addVectors(Y,A).add(L).divideScalar(3),ft=new M.Vector3().subVectors(y,_),dt=-j.dot(Y);if(j.dot(ft)<=0)continue;const nt=Y.clone().project(t),ot=A.clone().project(t),Pt=L.clone().project(t),oe=new M.Vector2(nt.x*w*r,-nt.y*P*r),se=new M.Vector2(ot.x*w*r,-ot.y*P*r),ie=new M.Vector2(Pt.x*w*r,-Pt.y*P*r),ht=t.matrixWorldInverse,ce=-Y.clone().applyMatrix4(ht).z,re=-A.clone().applyMatrix4(ht).z,ae=-L.clone().applyMatrix4(ht).z;h.push({a2d:oe,b2d:se,c2d:ie,depthA:ce,depthB:re,depthC:ae,mesh:$,faceIdx:D,normal:j,constant:dt})}}console.timeEnd("buildProjectedFaces"),console.log(`Built ${h.length} projected faces for occlusion`),console.time("classifySilhouettes"),te(p,h),console.timeEnd("classifySilhouettes"),console.time("filterSmoothSplitEdges");const E=Zt(p,h,o,d);console.timeEnd("filterSmoothSplitEdges");let v;c?v=E:(console.time("testOcclusion (math)"),v=Kt(E,h,t),console.timeEnd("testOcclusion (math)")),console.log(`Visible edges: ${v.length}`),console.time("optimize");const k=at(v);console.timeEnd("optimize"),console.time("cleanup orphans");const I=lt(k);console.timeEnd("cleanup orphans");const F=Gt(I);console.log(`Final edges before optimization: ${F.length}`);let O=F;if(F.length>0){let $=0;for(const T of F){const H=T.b.x-T.a.x,D=T.b.y-T.a.y;$+=Math.sqrt(H*H+D*D)}const z=$/F.length,C=z/10;console.log(`Optimization: avgLen=${z.toFixed(2)}, trim limit=${C.toFixed(2)}`),console.time("Optimize.segments"),O=G.segments(F,!1,!0,C,!1,!1,!1)._segments,console.timeEnd("Optimize.segments"),console.log(`After optimization: ${O.length} edges`)}for(const $ of O)$.a.x/=r,$.a.y/=r,$.b.x/=r,$.b.y/=r;const B=O;return{edges:B,profiles:B.filter($=>$.isProfile),allEdges:p,projectedFaces:h}}function te(i,t){for(const o of i){if(o.isHatch){o.isSilhouette=!1;continue}const s=(o.a.x+o.b.x)/2,c=(o.a.y+o.b.y)/2,a=o.b.x-o.a.x,l=o.b.y-o.a.y,u=Math.sqrt(a*a+l*l);if(u<.001){o.isSilhouette=!1;continue}const r=-l/u,d=a/u,f=St(s,c,r,d,1e3,t),g=St(s,c,-r,-d,1e3,t);o.isSilhouette=!f||!g}const n=i.filter(o=>o.isSilhouette).length;console.log(`Classified ${n} silhouette edges out of ${i.length}`)}function St(i,t,e,n,o,s){for(const c of s)if(ee(i,t,e,n,o,c.a2d,c.b2d,c.c2d))return!0;return!1}function ee(i,t,e,n,o,s,c,a){return!!(ut(i,t,e,n,o,s.x,s.y,c.x,c.y)||ut(i,t,e,n,o,c.x,c.y,a.x,a.y)||ut(i,t,e,n,o,a.x,a.y,s.x,s.y))}function ut(i,t,e,n,o,s,c,a,l){const u=a-s,r=l-c,d=e*r-n*u;if(Math.abs(d)<1e-10)return!1;const f=((s-i)*r-(c-t)*u)/d,g=((s-i)*n-(c-t)*e)/d;return f>.1&&f<=o&&g>=0&&g<=1}var R=i=>Math.round(i*100)/100,et=function(i){M.Object3D.call(this),this.node=i};et.prototype=Object.create(M.Object3D.prototype),et.prototype.constructor=et;var ne=function(){var i=this,t=document.createElementNS("http://www.w3.org/2000/svg","svg"),e=document.createElementNS("http://www.w3.org/2000/svg","g"),n=document.createElementNS("http://www.w3.org/2000/svg","g"),o=document.createElementNS("http://www.w3.org/2000/svg","g"),s,c,a,l,u=new M.Color;t.setAttribute("xmlns","http://www.w3.org/2000/svg"),t.setAttribute("xmlns:inkscape","http://www.inkscape.org/namespaces/inkscape"),t.setAttribute("xmlns:xlink","http://www.w3.org/1999/xlink"),t.setAttribute("version","1.1"),e.setAttribute("inkscape:label","Silhouettes"),e.setAttribute("inkscape:groupmode","layer"),e.id="silhouettes_layer",t.appendChild(e),o.setAttribute("inkscape:label","Shading"),o.setAttribute("inkscape:groupmode","layer"),o.id="shading_layer",t.appendChild(o),n.setAttribute("inkscape:label","Edges"),n.setAttribute("inkscape:groupmode","layer"),n.id="edges_layer",t.appendChild(n),this.domElement=t,this.showSilhouettes=!0,this.showEdges=!0,this.showHatches=!0,this.silhouetteOptions={normalBuckets:12,simplifyTolerance:2,minArea:100},this.hatchOptions={baseSpacing:8,minSpacing:3,maxSpacing:40,depthFactor:.5,insetPixels:3,stroke:"black",strokeWidth:"1px",axisSettings:{x:{rotation:0,spacing:8},y:{rotation:0,spacing:8},z:{rotation:0,spacing:8}},brightnessShading:{enabled:!1,invert:!1,lightDirection:null}},this.edgeOptions={stroke:"white",strokeWidth:"1px"},this.hiddenLineOptions={smoothThreshold:.99},this._glRenderer=null,this.autoClear=!0,this.setClearColor=function(d){u.set(d)},this.setPixelRatio=function(){},this.setSize=function(d,f){s=d,c=f,a=s/2,l=c/2,t.setAttribute("viewBox",-a+" "+-l+" "+s+" "+c),t.setAttribute("width",s),t.setAttribute("height",c)},this.getSize=function(){return{width:s,height:c}},this.setGLRenderer=function(d){i._glRenderer=d};function r(){for(;e.childNodes.length>0;)e.removeChild(e.childNodes[0]);for(;n.childNodes.length>0;)n.removeChild(n.childNodes[0]);for(;o.childNodes.length>0;)o.removeChild(o.childNodes[0])}this.clear=function(){r(),t.style.backgroundColor=u.getStyle()},this.renderGPULayers=function(d,f){if(!i._glRenderer){console.warn("PlotterRenderer: WebGL renderer not set. Call setGLRenderer() first.");return}const g=i._glRenderer;if(i.showSilhouettes||i.showHatches){const x=gt(g,d,f,{normalBuckets:i.silhouetteOptions.normalBuckets,simplifyTolerance:i.silhouetteOptions.simplifyTolerance,minArea:i.silhouetteOptions.minArea,insetPixels:i.showHatches?i.hatchOptions.insetPixels:0});if(i.showSilhouettes&&x.forEach(m=>{if(m.boundary.length<3)return;const b=document.createElementNS("http://www.w3.org/2000/svg","path");let p="";m.boundary.forEach((E,v)=>{const k=E.x,I=-E.y;p+=(v===0?"M":"L")+R(k)+","+R(I)}),p+="Z";const h=m.normal,y=Math.floor((h.x*.5+.5)*255),w=Math.floor((h.y*.5+.5)*255),P=Math.floor((h.z*.5+.5)*255);b.setAttribute("d",p),b.setAttribute("fill",`rgba(${y},${w},${P},0.3)`),b.setAttribute("stroke","none"),e.appendChild(b)}),i.showHatches){x.sort((h,y)=>h.depth-y.depth);const m=x.map(h=>h.boundary);let b=null;const p=i.hatchOptions.brightnessShading||{};p.enabled&&(p.lightDirection?b=p.lightDirection.clone().normalize():(d.traverse(h=>{b||(h instanceof M.DirectionalLight?b=new M.Vector3().subVectors(h.position,h.target.position).normalize():(h instanceof M.PointLight||h instanceof M.SpotLight)&&(b=h.position.clone().normalize()))}),b||(b=new M.Vector3(1,1,1).normalize()))),x.forEach((h,y)=>{let w=null;b&&p.enabled&&(w=Math.max(0,h.normal.dot(b)));let P=xt(h,f,{baseSpacing:i.hatchOptions.baseSpacing,minSpacing:i.hatchOptions.minSpacing,maxSpacing:i.hatchOptions.maxSpacing,depthFactor:i.hatchOptions.depthFactor,insetPixels:i.hatchOptions.insetPixels,screenWidth:s,screenHeight:c,axisSettings:i.hatchOptions.axisSettings,brightness:w,invertBrightness:p.invert||!1});for(let E=0;E<y;E++)P=P.flatMap(v=>yt(v,m[E]));P.forEach(E=>{const v=document.createElementNS("http://www.w3.org/2000/svg","path"),k=`M${R(E.start.x)},${R(-E.start.y)}L${R(E.end.x)},${R(-E.end.y)}`;v.setAttribute("d",k),v.setAttribute("fill","none"),v.setAttribute("stroke",i.hatchOptions.stroke),v.setAttribute("stroke-width",i.hatchOptions.strokeWidth),o.appendChild(v)})})}if(i.showEdges){const m=[];d.traverse(b=>{b.isMesh&&b.geometry&&m.push(b)}),m.length>0&&(Et(m,f,d,{smoothThreshold:i.hiddenLineOptions.smoothThreshold,width:s,height:c}).edges||[]).forEach(h=>{const y=document.createElementNS("http://www.w3.org/2000/svg","line");y.setAttribute("x1",R(h.a.x)),y.setAttribute("y1",R(h.a.y)),y.setAttribute("x2",R(h.b.x)),y.setAttribute("y2",R(h.b.y)),y.setAttribute("stroke",i.edgeOptions.stroke),y.setAttribute("stroke-width",i.edgeOptions.strokeWidth),n.appendChild(y)})}}},this.render=function(d,f){if(!(f instanceof M.Camera)){console.error("PlotterRenderer.render: camera is not an instance of Camera.");return}}};X.GeomUtil=S,X.Optimize=G,X.PlotterRenderer=ne,X.Point=V,X.SVGObject=et,X.Segment=q,X.Segments=Z,X.cleanupOrphanedEdges=lt,X.clipLineOutsidePolygon=yt,X.clipLineToPolygon=it,X.computeHiddenLines=Ut,X.computeHiddenLinesMultiple=Et,X.extractNormalRegions=gt,X.generatePerspectiveHatches=xt,X.optimizeEdges=at,Object.defineProperty(X,Symbol.toStringTag,{value:"Module"})});
//# sourceMappingURL=three-plotter-renderer.umd.js.map
