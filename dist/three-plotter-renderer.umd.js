(function(A,M){typeof exports=="object"&&typeof module<"u"?M(exports,require("three")):typeof define=="function"&&define.amd?define(["exports","three"],M):(A=typeof globalThis<"u"?globalThis:A||self,M(A.ThreePlotterRenderer={},A.THREE))})(this,function(A,M){"use strict";function St(s,t,e,n={}){const{resolution:o=2,normalBuckets:i=12,minArea:c=100,simplifyTolerance:l=2,insetPixels:r=0}=n,f=s.getSize(new M.Vector2),d=Math.floor(f.x*o),a=Math.floor(f.y*o),u=Math.round(r*o),h=zt(s,t,e,d,a),x=Xt(s,t,e,d,a),{regionMap:p,normalLookup:b}=Yt(h,d,a),{labels:m,regionCount:g,labelToNormalId:y}=Bt(p,d,a),S=[];for(let P=1;P<=g;P++){const k=qt(m,d,a,P);if(k.length<3)continue;const w=dt(k,l),v=Math.abs(vt(w));if(v<c)continue;const I=y[P],O=b[I]||new M.Vector3(0,0,1),z=Tt(m,x,d,a,P),B=u/o,F=w.map(C=>({x:C.x/o-f.x/2,y:C.y/o-f.y/2})),V=At(F,B);S.push({boundary:F.map(C=>new M.Vector2(C.x,C.y)),hatchBoundary:V.map(C=>new M.Vector2(C.x,C.y)),normal:O,depth:z,area:v/(o*o),regionId:P})}return Lt(S),S}function zt(s,t,e,n,o){const i=new M.WebGLRenderTarget(n,o,{minFilter:M.NearestFilter,magFilter:M.NearestFilter}),c=new M.MeshNormalMaterial({flatShading:!0}),l=new Map,r=[];t.traverse(a=>{let u=!1,h=a;for(;h;){if(h.userData&&h.userData.excludeFromSVG){u=!0;break}h=h.parent}if(u){a.visible&&(r.push(a),a.visible=!1);return}a.isMesh?(l.set(a,a.material),a.material=c):(a.isLineSegments||a.isLine||a.isPoints)&&a.visible&&(r.push(a),a.visible=!1)});const f=t.background;t.background=null,s.setRenderTarget(i),s.render(t,e),t.background=f,t.traverse(a=>{a.isMesh&&l.has(a)&&(a.material=l.get(a))});for(const a of r)a.visible=!0;s.setRenderTarget(null);const d=new Uint8Array(n*o*4);return s.readRenderTargetPixels(i,0,0,n,o,d),i.dispose(),c.dispose(),d}function Xt(s,t,e,n,o){const i=new M.WebGLRenderTarget(n,o,{minFilter:M.NearestFilter,magFilter:M.NearestFilter}),c=new M.MeshDepthMaterial({depthPacking:M.RGBADepthPacking}),l=new Map,r=[];t.traverse(a=>{let u=!1,h=a;for(;h;){if(h.userData&&h.userData.excludeFromSVG){u=!0;break}h=h.parent}if(u){a.visible&&(r.push(a),a.visible=!1);return}a.isMesh?(l.set(a,a.material),a.material=c):(a.isLineSegments||a.isLine||a.isPoints)&&a.visible&&(r.push(a),a.visible=!1)});const f=t.background;t.background=null,s.setRenderTarget(i),s.render(t,e),t.background=f,t.traverse(a=>{a.isMesh&&l.has(a)&&(a.material=l.get(a))});for(const a of r)a.visible=!0;s.setRenderTarget(null);const d=new Uint8Array(n*o*4);return s.readRenderTargetPixels(i,0,0,n,o,d),i.dispose(),c.dispose(),d}function Tt(s,t,e,n,o){let i=0,c=0;for(let l=0;l<n;l++)for(let r=0;r<e;r++)if(s[l*e+r]===o){const f=(l*e+r)*4,d=t[f]/255,a=t[f+1]/255,u=t[f+2]/255,h=t[f+3]/255,x=d+a/256+u/65536+h/16777216;i+=x,c++}return c>0?i/c:.5}function Yt(s,t,e,n){const o=new Uint16Array(t*e),i={};let c=1;const l={};for(let r=0;r<t*e;r++){const f=r*4,d=s[f],a=s[f+1],u=s[f+2];if(d<5&&a<5&&u<5){o[r]=0;continue}const h=d/255*2-1,x=a/255*2-1,p=u/255*2-1,b=4,m=Math.round(d/b)*b,g=Math.round(a/b)*b,y=Math.round(u/b)*b,S=`${m}|${g}|${y}`;l[S]||(l[S]=c,i[c]=new M.Vector3(h,x,p).normalize(),c++),o[r]=l[S]}return{regionMap:o,normalLookup:i}}function Bt(s,t,e){const n=new Uint32Array(t*e),o=[];let i=1;function c(a){return o[a]!==a&&(o[a]=c(o[a])),o[a]}function l(a,u){const h=c(a),x=c(u);h!==x&&(o[x]=h)}for(let a=0;a<e;a++)for(let u=0;u<t;u++){const h=a*t+u,x=s[h];if(x===0)continue;const p=[];if(u>0&&s[h-1]===x&&n[h-1]>0&&p.push(n[h-1]),a>0&&s[h-t]===x&&n[h-t]>0&&p.push(n[h-t]),p.length===0)n[h]=i,o[i]=i,i++;else{const b=Math.min(...p);n[h]=b;for(const m of p)l(b,m)}}const r={},f={};let d=0;for(let a=0;a<t*e;a++){if(n[a]===0)continue;const u=c(n[a]);r[u]===void 0&&(d++,r[u]=d,f[d]=s[a]),n[a]=r[u]}return{labels:n,regionCount:d,labelToNormalId:f}}function qt(s,t,e,n){const o=[];let i=-1,c=-1;t:for(let x=0;x<e;x++)for(let p=0;p<t;p++)if(s[x*t+p]===n&&(p===0||s[x*t+p-1]!==n||x===0||s[(x-1)*t+p]!==n)){i=p,c=x;break t}if(i===-1)return o;const l=[1,1,0,-1,-1,-1,0,1],r=[0,1,1,1,0,-1,-1,-1];let f=i,d=c,a=7;const u=t*e*2;let h=0;do{o.push({x:f,y:d});let x=!1;for(let p=0;p<8;p++){const b=(a+6+p)%8,m=f+l[b],g=d+r[b];if(m>=0&&m<t&&g>=0&&g<e&&s[g*t+m]===n){f=m,d=g,a=b,x=!0;break}}if(!x)break;h++}while((f!==i||d!==c)&&h<u);return o}function dt(s,t){if(s.length<3)return s;let e=0,n=0;const o=s[0],i=s[s.length-1];for(let c=1;c<s.length-1;c++){const l=Dt(s[c],o,i);l>e&&(e=l,n=c)}if(e>t){const c=dt(s.slice(0,n+1),t),l=dt(s.slice(n),t);return c.slice(0,-1).concat(l)}else return[o,i]}function Dt(s,t,e){const n=e.x-t.x,o=e.y-t.y,i=n*n+o*o;if(i<1e-10)return Math.sqrt((s.x-t.x)**2+(s.y-t.y)**2);let c=((s.x-t.x)*n+(s.y-t.y)*o)/i;c=Math.max(0,Math.min(1,c));const l=t.x+c*n,r=t.y+c*o;return Math.sqrt((s.x-l)**2+(s.y-r)**2)}function vt(s){let t=0;for(let e=0;e<s.length;e++){const n=(e+1)%s.length;t+=s[e].x*s[n].y,t-=s[n].x*s[e].y}return t/2}function At(s,t){if(s.length<3||t<=0)return s;const e=s.length,n=[],i=vt(s)>0?1:-1;for(let c=0;c<e;c++){const l=s[(c-1+e)%e],r=s[c],f=s[(c+1)%e],d=r.x-l.x,a=r.y-l.y,u=f.x-r.x,h=f.y-r.y,x=Math.sqrt(d*d+a*a)||1,p=Math.sqrt(u*u+h*h)||1,b=d/x,m=a/x,g=u/p,y=h/p,S=-m*i,P=b*i,k=-y*i,w=g*i;let v=S+k,I=P+w;const O=Math.sqrt(v*v+I*I)||1;v/=O,I/=O;const z=S*k+P*w,B=t/Math.sqrt((1+z)/2+.001);n.push({x:r.x+v*Math.min(B,t*3),y:r.y+I*Math.min(B,t*3)})}return n}function Rt(s){let t=1/0,e=-1/0,n=1/0,o=-1/0;for(const i of s)t=Math.min(t,i.x),e=Math.max(e,i.x),n=Math.min(n,i.y),o=Math.max(o,i.y);return{minX:t,maxX:e,minY:n,maxY:o}}function Ht(s,t){return t.minX>=s.minX&&t.maxX<=s.maxX&&t.minY>=s.minY&&t.maxY<=s.maxY}function Wt(s,t,e){let n=!1;const o=e.length;for(let i=0,c=o-1;i<o;c=i++){const l=e[i].x,r=e[i].y,f=e[c].x,d=e[c].y;r>t!=d>t&&s<(f-l)*(t-r)/(d-r)+l&&(n=!n)}return n}function Lt(s){const t=s.map(e=>Rt(e.boundary));for(let e=0;e<s.length;e++){const n=s[e];n.isHole=!1,n.parentRegionId=null;const o=t[e];for(let i=0;i<s.length;i++){if(e===i)continue;const c=s[i],l=t[i];if(!Ht(l,o))continue;if(n.boundary.every(f=>Wt(f.x,f.y,c.boundary))){n.isHole=!0,n.parentRegionId=c.regionId;break}}}}function Nt(s,t,e,n){const o=e/2,i=n/2,c=new M.Vector3(0,1,0),l=new M.Vector3(0,0,1);let r;Math.abs(s.y)>.9?r=l.clone():(r=new M.Vector3().crossVectors(c,s).normalize(),r.lengthSq()<.01&&(r=l.clone()));const f=new M.Vector3(0,0,0),d=r.clone().multiplyScalar(100),a=f.clone().project(t),u=d.clone().project(t),h=new M.Vector2(a.x*o,-a.y*i),p=new M.Vector2(u.x*o,-u.y*i).clone().sub(h).normalize(),m=r.clone().multiplyScalar(1e5).clone().project(t);let g=null;return Math.abs(m.x)<100&&Math.abs(m.y)<100&&m.z<1&&(g=new M.Vector2(m.x*o,-m.y*i)),{direction:p,vanishingPoint:g}}function Et(s,t,e={}){const{baseSpacing:n=8,minSpacing:o=3,maxSpacing:i=20,depthFactor:c=.5,screenWidth:l=1200,screenHeight:r=800,axisSettings:f={},brightness:d=null,invertBrightness:a=!1}=e,{boundary:u,hatchBoundary:h,normal:x,depth:p=.5}=s,b=h||u;if(b.length<3)return[];const m=x.clone().applyQuaternion(t.quaternion),g=Math.round(m.x*10)/10,y=Math.round(m.y*10)/10,S=Math.round(m.z*10)/10,P=Math.abs(g),k=Math.abs(y),w=Math.abs(S),v=P+k+w||1,I=P/v,O=k/v,z=w/v;s.regionId<=5&&console.log(`[Hatch] Region ${s.regionId}: viewNormal=(${x.x.toFixed(2)}, ${x.y.toFixed(2)}, ${x.z.toFixed(2)}) -> worldNormal=(${g}, ${y}, ${S}) -> weights=(wx:${I.toFixed(2)}, wy:${O.toFixed(2)}, wz:${z.toFixed(2)})`);const B=f.x||{rotation:0,spacing:n},F=f.y||{rotation:0,spacing:n},V=f.z||{rotation:0,spacing:n},C=I*(B.spacing||n)+O*(F.spacing||n)+z*(V.spacing||n),X=I*(B.rotation||0)+O*(F.rotation||0)+z*(V.rotation||0),{direction:R,vanishingPoint:$}=Nt(x,t,l,r);let Y=R;if(X!==0){const W=X*(Math.PI/180),J=Math.cos(W),G=Math.sin(W);Y=new M.Vector2(R.x*J-R.y*G,R.x*G+R.y*J)}const D=new M.Vector2(-Y.y,Y.x);let q=Math.max(o,Math.min(i,(C!==void 0?C:n)+p*c*(i-o)));if(d!=null){const W=.5+d*1.5;if(q=q*W,q>i)return[];q=Math.max(o,q)}let L=1/0,Z=-1/0,K=1/0,nt=-1/0;for(const W of b)L=Math.min(L,W.x),Z=Math.max(Z,W.x),K=Math.min(K,W.y),nt=Math.max(nt,W.y);const ot=(L+Z)/2,ut=(K+nt)/2,rt=new M.Vector2(ot,ut),Q=Math.sqrt((Z-L)**2+(nt-K)**2),st=[];if($&&Math.abs(X)<5&&$.distanceTo(rt)<Q*5){const W=$.distanceTo(rt),J=Math.ceil(Q/q)*2,it=Math.atan2(Q,W)*2/J,U=Math.atan2(ut-$.y,ot-$.x);for(let tt=-J;tt<=J;tt++){const ct=U+tt*it,Mt=new M.Vector2(Math.cos(ct),Math.sin(ct)),de=$.clone(),he=$.clone().add(Mt.clone().multiplyScalar(W*10)),ge=ht({start:de,end:he},b);st.push(...ge)}}else{const W=Math.ceil(Q/q)+2;for(let J=-W;J<=W;J++){const G=D.clone().multiplyScalar(J*q),it=rt.clone().add(G),U=it.clone().add(Y.clone().multiplyScalar(-Q)),tt=it.clone().add(Y.clone().multiplyScalar(Q)),ct=ht({start:U,end:tt},b);st.push(...ct)}}return st}function ht(s,t){const e=[],n=t.length;for(let i=0;i<n;i++){const c=t[i],l=t[(i+1)%n],r=Zt(s.start.x,s.start.y,s.end.x,s.end.y,c.x,c.y,l.x,l.y);r&&e.push({point:new M.Vector2(r.x,r.y),t:r.t})}if(e.length<2)return[];e.sort((i,c)=>i.t-c.t);const o=[];for(let i=0;i<e.length-1;i++){const c=(e[i].point.x+e[i+1].point.x)/2,l=(e[i].point.y+e[i+1].point.y)/2;lt(c,l,t)&&o.push({start:e[i].point,end:e[i+1].point})}return o}function gt(s,t){const e=[],n=t.length,o=lt(s.start.x,s.start.y,t),i=lt(s.end.x,s.end.y,t);e.push({point:s.start.clone(),t:0,inside:o});for(let r=0;r<n;r++){const f=t[r],d=t[(r+1)%n],a=jt(s.start.x,s.start.y,s.end.x,s.end.y,f.x,f.y,d.x,d.y);a&&a.t>0&&a.t<1&&e.push({point:new M.Vector2(a.x,a.y),t:a.t,inside:null})}e.push({point:s.end.clone(),t:1,inside:i}),e.sort((r,f)=>r.t-f.t);const c=[e[0]];for(let r=1;r<e.length;r++)e[r].t-c[c.length-1].t>1e-4&&c.push(e[r]);if(c.length<2)return[s];const l=[];for(let r=0;r<c.length-1;r++){const f=(c[r].t+c[r+1].t)/2,d=s.start.x+f*(s.end.x-s.start.x),a=s.start.y+f*(s.end.y-s.start.y);lt(d,a,t)||l.push({start:c[r].point.clone(),end:c[r+1].point.clone()})}return l}function jt(s,t,e,n,o,i,c,l){const r=(s-e)*(i-l)-(t-n)*(o-c);if(Math.abs(r)<1e-10)return null;const f=((s-o)*(i-l)-(t-i)*(o-c))/r,d=-((s-e)*(t-i)-(t-n)*(s-o))/r;return f>=0&&f<=1&&d>=0&&d<=1?{x:s+f*(e-s),y:t+f*(n-t),t:f}:null}function Zt(s,t,e,n,o,i,c,l){const r=(s-e)*(i-l)-(t-n)*(o-c);if(Math.abs(r)<1e-10)return null;const f=((s-o)*(i-l)-(t-i)*(o-c))/r,d=-((s-e)*(t-i)-(t-n)*(s-o))/r;return d>=0&&d<=1?{x:s+f*(e-s),y:t+f*(n-t),t:f}:null}function lt(s,t,e){let n=!1;const o=e.length;for(let i=0,c=o-1;i<o;c=i++){const l=e[i].x,r=e[i].y,f=e[c].x,d=e[c].y;r>t!=d>t&&s<(f-l)*(t-r)/(d-r)+l&&(n=!n)}return n}const Pt=.001;class T{constructor(t,e){this.x=t,this.y=e}static clone(t){return new T(t.x,t.y)}}class xt{constructor(t,e,n,o){this.minX=t,this.minY=e,this.maxX=n,this.maxY=o}width(){return Math.abs(this.maxX-this.minX)}height(){return Math.abs(this.maxY-this.minY)}}class Jt{constructor(t=0){this.r=t}}class H{constructor(t,e){this.a=t,this.b=e,this.tags={}}static isEqual(t,e){return E.pointsEqual(t.a,e.a)&&E.pointsEqual(t.b,e.b)||E.pointsEqual(t.b,e.a)&&E.pointsEqual(t.a,e.b)}static clone(t){return new H(new T(t.a.x,t.a.y),new T(t.b.x,t.b.y))}}class Kt{constructor(){this.pivot={x:0,y:0},this.rotation=0,this.isOpen=!0,this.isGroup=!1,this.isStrong=!1,this._makeAbsolute=t=>{let e=this.rotation*Math.PI/180;t.forEach((n,o)=>{const i={x:n.x,y:n.y};E.rotatePoint(i,e),i.x+=this.pivot.x,i.y+=this.pivot.y,t[o]=i})},this._makeSegsAbsolute=t=>{let e=this.rotation*Math.PI/180;t.forEach(n=>{const o={x:n.a.x,y:n.a.y},i={x:n.b.x,y:n.b.y};E.rotatePoint(o,e),E.rotatePoint(i,e),E.addToPoint(o,this.pivot),E.addToPoint(i,this.pivot),n.a=o,n.b=i})}}toPoints(t=!1){throw"not implemented"}toSegments(t=!1){throw"not implemented"}getBoundingBox(t=!1){const e=new xt(1e6,1e6,-1e6,-1e6);return this.toPoints(t).forEach(o=>{e.minX=Math.min(e.minX,o.x),e.minY=Math.min(e.minY,o.y),e.maxX=Math.max(e.maxX,o.x),e.maxY=Math.max(e.maxY,o.y)}),e}getBoundingCircle(){const t=new Jt;return this.toPoints(!0).forEach(n=>{t.r=Math.max(t.r,Math.sqrt(n.x*n.x+n.y*n.y))}),t}}class et extends Kt{constructor(t){super(),this._segments=t}add(...t){this._segments=this._segments.concat(t)}toPoints(t=!1){return this.toSegments(t).reduce((e,n)=>n?e.concat([n.a,n.b]):e,[])}toSegments(t=!1){let e=this._segments.reduce((n,o)=>o?n.concat(H.clone(o)):n,[]);return t||this._makeSegsAbsolute(e),e}bake(){}result(){return et.clone(this)}static clone(t){let e=t._segments,n=[],o=e.length;for(;o--;)n.unshift(H.clone(e[o]));let i=new et(n);return i.pivot.x=t.pivot.x,i.pivot.y=t.pivot.y,i.rotation=t.rotation,i}}class E{static lerp(t,e,n){return(1-n)*t+n*e}static angleBetween(t,e){return Math.atan2(e.y-t.y,e.x-t.x)}static sameAngle(t,e){let n=E.angleBetween(t.a,t.b),o=E.angleBetween(e.a,e.b);return Math.abs(n-o)<Pt}static sameAngleRev(t,e){let n=E.angleBetween(t.a,t.b),o=E.angleBetween(e.b,e.a);return Math.abs(n-o)<Pt}static lerpPoints(t,e,n){return{x:E.lerp(t.x,e.x,n),y:E.lerp(t.y,e.y,n)}}static rotatePointDeg(t,e){E.rotatePoint(t,e*Math.PI/180)}static rotatePoint(t,e){const n=Math.cos(e),o=Math.sin(e),i=t.y,c=t.x;t.y=n*i-o*c,t.x=o*i+n*c}static rotatePoints(t,...e){e.forEach(n=>{E.rotatePoint(n,t)})}static rotatePointsDeg(t,...e){let n=t*Math.PI/180;e.forEach(o=>{E.rotatePoint(o,n)})}static outerTangents(t,e,n,o){var i=n.x-t.x,c=n.y-t.y,l=Math.sqrt(i*i+c*c);if(l<=Math.abs(o-e))return[];var r=Math.atan2(c,i),f=Math.acos((e-o)/l);return[new H({x:t.x+e*Math.cos(r+f),y:t.y+e*Math.sin(r+f)},{x:n.x+o*Math.cos(r+f),y:n.y+o*Math.sin(r+f)}),new H({x:t.x+e*Math.cos(r-f),y:t.y+e*Math.sin(r-f)},{x:n.x+o*Math.cos(r-f),y:n.y+o*Math.sin(r-f)})]}static cartesian2Polar(t){const e=Math.sqrt(t.x*t.x+t.y*t.y),n=Math.atan2(t.y,t.x);t.x=e,t.y=n}static pointsEqual(t,e,n=1){return Math.round(t.x*1e4/n)==Math.round(e.x*1e4/n)&&Math.round(t.y*1e4/n)==Math.round(e.y*1e4/n)}static distanceBetween(t,e){const n=e.x-t.x,o=e.y-t.y;return Math.sqrt(n*n+o*o)}static distanceBetweenSquared(t,e){const n=e.x-t.x,o=e.y-t.y;return n*n+o*o}static interpolatePoints(t,e,n){let o=[{x:t.x,y:t.y}],i=1/n,c=(e.x-t.x)*i,l=(e.y-t.y)*i;for(var r=1;r<n;r++)o.push(new T(t.x+c*r,t.y+l*r));return o.push({x:e.x,y:e.y}),o}static averagePoints(...t){let e=new T(0,0);return t.forEach(n=>{e.x+=n.x,e.y+=n.y}),e.x/=t.length,e.y/=t.length,e}static addToPoint(t,e){t.x+=e.x,t.y+=e.y}static subFromPoint(t,e){t.x-=e.x,t.y-=e.y}static subdivideByDistance(t,e,n){if(n===0)return[t,e];let o=[{x:t.x,y:t.y}],i=E.distanceBetween(t,e),c=n/i,l=Math.floor(1/c),r=i%n;n+=r/l,c=n/i;let f=c,d=1,a=(e.x-t.x)*c,u=(e.y-t.y)*c;for(;f<1;)o.push(new T(t.x+a*d,t.y+u*d)),f+=c,d++;return o.push({x:e.x,y:e.y}),o}static segmentsConnected(t,e,n=1){return E.pointsEqual(t.b,e.a,n)||E.pointsEqual(t.a,e.b,n)}static segmentsToPoints(t){let e=t.reduce((o,i)=>o.concat(i.a,i.b),[]),n=e.length;for(;n--;){let o=e[n];n>0&&E.pointsEqual(o,e[n-1])&&e.splice(n,1)}return e}static polygonArea(t){let e=0,n=t.length-1;for(var o=0;o<t.length;o++)e+=t[o].x*t[n].y,e-=t[n].x*t[o].y,n=o;return e/2}static pointsBoundingBox(t){const e=new xt(1e6,1e6,-1e6,-1e6);return t.forEach(n=>{e.minX=Math.min(e.minX,n.x),e.minY=Math.min(e.minY,n.y),e.maxX=Math.max(e.maxX,n.x),e.maxY=Math.max(e.maxY,n.y)}),e}static boundingBoxesBoundingBox(t){const e=new xt(1e6,1e6,-1e6,-1e6);return t.forEach(n=>{e.minX=Math.min(e.minX,n.minX),e.minY=Math.min(e.minY,n.minY),e.maxX=Math.max(e.maxX,n.maxX),e.maxY=Math.max(e.maxY,n.maxY)}),e}static segmentsBoundingBox(t){const e=[];return t.forEach(n=>{e.push(n.a),e.push(n.b)}),E.pointsBoundingBox(e)}static boundingBoxesIntersect(t,e){return t.maxX>=e.minX&&t.maxY>=e.minY&&t.minX<=e.maxX&&t.minY<=e.maxY}static polygonIsClockwise(t){return E.polygonArea(t)>0}static ccw(t,e,n){return(n.y-t.y)*(e.x-t.x)>(e.y-t.y)*(n.x-t.x)}static segmentsIntersect(t,e){const n=E.ccw;return n(t.a,e.a,e.b)!=n(t.b,e.a,e.b)&&n(t.a,t.b,e.a)!=n(t.a,t.b,e.b)}static segmentSegmentIntersect(t,e,n=!1){const o=t.a.x,i=t.a.y,c=t.b.x,l=t.b.y,r=e.a.x,f=e.a.y,d=e.b.x,a=e.b.y,u=c-o,h=l-i,x=d-r,p=a-f,b=(-h*(o-r)+u*(i-f))/(-x*h+u*p),m=(x*(i-f)-p*(o-r))/(-x*h+u*p);if(b>=0&&b<=1&&m>=0&&m<=1){const g=o+m*u,y=i+m*h;let S={x:g,y};return n&&(E.pointsEqual(S,e.a)||E.pointsEqual(S,e.b)||E.pointsEqual(S,t.a)||E.pointsEqual(S,t.b))?void 0:S}return null}static segmentSegmentsIntersections(t,e,n=!1){let o=[];return e.forEach(i=>{if(i==t)return;let c=E.segmentSegmentIntersect(t,i,n);c&&o.push(c)}),o}static dot(t,e){return t.x*e.x+t.y*e.y}static cross(t,e){return t.x*e.y-t.y*e.x}static lineSide(t,e,n){return Math.round(((n.x-e.x)*(t.y-e.y)-(n.y-e.y)*(t.x-e.x))*100)/100}static sub(t,e){return new T(t.x-e.x,t.y-e.y)}static add(t,e){return new T(t.x+e.x,t.y+e.y)}static closestPtPointSegment(t,e){var n=E.sub(e.b,e.a),o=E.sub(t,e.a),i=E.dot(o,n);if(i<0)t=e.a;else{var c=E.dot(n,n);i>=c?t=e.b:(i/=c,o.x=e.a.x+i*n.x,o.y=e.a.y+i*n.y,t=o)}return T.clone(t)}static distancePointSegment(t,e){return E.distanceBetween(t,E.closestPtPointSegment(t,e))}static pointWithinBoundingBox(t,e){return t.x>=e.minX&&t.y>=e.minY&&t.x<=e.maxX&&t.y<=e.maxY}static pointWithinPolygon(t,e,n){const o=E.segmentsBoundingBox(e);if(!this.pointWithinBoundingBox(t,o))return!1;let i=new T(1e5,1e5),c=new H(i,t),l=E.segmentSegmentsIntersections(c,e);return l.length%2!=0&&n&&E.pointsEqual(t,l[0])?!1:l.length%2!=0}static segmentWithinPolygon(t,e){let n=this.pointWithinPolygon(t.a,e,!1),o=this.pointWithinPolygon(t.b,e,!1),i=this.pointWithinPolygon(t.a,e,!0),c=this.pointWithinPolygon(t.b,e,!0);return i&&c||i&&o||c&&n}static sign(t,e,n){return(t.x-n.x)*(e.y-n.y)-(e.x-n.x)*(t.y-n.y)}static pointWithinTriangle(t,e,n,o,i){const c=E.sign(t,e,n),l=E.sign(t,n,o),r=E.sign(t,o,e),f=c<0||l<0||r<0,d=c>0||l>0||r>0;if(!(f&&d)&&i){let a={a:e,b:n,tags:null};if(E.distancePointSegment(t,a)<1||(a.a=n,a.b=o,E.distancePointSegment(t,a)<1)||(a.a=o,a.b=e,E.distancePointSegment(t,a)<1))return!1}return!(f&&d)}static segmentWithinTriangle(t,e,n,o){let i=this.pointWithinTriangle(t.a,e,n,o,!1),c=this.pointWithinTriangle(t.b,e,n,o,!1),l=this.pointWithinTriangle(t.a,e,n,o,!0),r=this.pointWithinTriangle(t.b,e,n,o,!0);return E.averagePoints(t.a,t.b),l&&r||l&&c||r&&i||i&&c}static pointsToClosedPolySegments(...t){let e=[];for(let n=0;n<t.length;n++)e.push(new H(t[n],n<t.length-1?t[n+1]:t[0]));return e}static polygonWithinPolygon(t,e){const n=E.segmentsBoundingBox(t),o=E.segmentsBoundingBox(e);if(!E.boundingBoxesIntersect(n,o))return!1;new T(o.minX-100,o.minY-100);for(let i=0;i<t.length;i++){let c=t[i];if(E.segmentSegmentsIntersections(c,e).length%2==0)return!1}return!0}static splinePoints(t,e,n,o=0){let i=l=>{let r=[l[0]];for(let f=0;f<l.length-1;f++){let d=new T(0,0);f+1<l.length*.4?(d.x=(l[f].x*40+l[f+1].x*60)*.01,d.y=(l[f].y*40+l[f+1].y*60)*.01):f+1>l.length*.6?(d.x=(l[f].x*60+l[f+1].x*40)*.01,d.y=(l[f].y*60+l[f+1].y*40)*.01):(d.x=(l[f].x+l[f+1].x)*.5,d.y=(l[f].y+l[f+1].y)*.5),r.push(d)}return r.push(l[l.length-1]),r},c=[t,e,n];for(let l=0;l<o;l++)c=i(c);return c}}class _{static getSegsAndConnections(t,e=!1,n=!1){let o={},i=[],c={},l=r=>{let f=`${Math.round(r.x*1)}|${Math.round(r.y*1)}`;return c[f]=r,f};if(e){let r=t.reduce((a,u)=>a.concat(u.a,u.b),[]),f=r.length;for(;f--;){let a=r[f],u=f;for(;u--;){let h=r[u];if(E.pointsEqual(a,h)){r.splice(f,1);break}}}let d=t.length;for(;d--;){let a=t[d],u=[];if(r.forEach(h=>{E.distancePointSegment(h,a)<.1&&!E.pointsEqual(h,a.a)&&!E.pointsEqual(h,a.b)&&u.push(h)}),u.length){u.sort((p,b)=>{const m=E.distanceBetweenSquared(p,a.a),g=E.distanceBetweenSquared(b,a.a);return m<g?-1:m>g?1:0});const h=[];let x=a.a;for(let p=0;p<u.length;p++){let b=u[p];h.push(new H(x,b)),x=b}h.push(new H(x,a.b)),t.splice(d,1,...h)}}}if(n){let r=t.length;for(;r--;){let f=r,d=!1;for(;f--;){let a=t[r],u=t[f],h=E.segmentSegmentIntersect(a,u,!0);h&&(d=!0,t.splice(r,1,new H(T.clone(a.a),T.clone(h)),new H(T.clone(h),T.clone(a.b))),t.splice(f,1,new H(T.clone(u.a),T.clone(h)),new H(T.clone(h),T.clone(u.b))))}d&&(r=t.length)}}return t.forEach(r=>{let f=l(r.a),d=l(r.b);o[f]||(o[f]=[]),o[d]||(o[d]=[]),o[f].indexOf(d)===-1&&o[f].push(d),o[d].indexOf(f)===-1&&o[d].push(f),i.indexOf(f)===-1&&i.push(f),i.indexOf(d)===-1&&i.push(d)}),{originalPts:c,pts:i,cxs:o}}static pathOrder(t,e=!1,n=!1){let o=[],{originalPts:i,pts:c,cxs:l}=_.getSegsAndConnections(t,e,n),r=d=>i[d],f=(d,a)=>l[d].length>l[a].length?1:l[d].length<l[a].length?-1:0;for(c.sort(f);c.length;){c.sort(f);let d=c.shift();for(;d;)if(l[d].length){l[d].sort(f);let a=l[d].shift(),u=l[a].indexOf(d);u!==-1&&l[a].splice(u,1),o.push(new H(r(d),r(a))),l[d].length&&c.unshift(d),d=a}else d=null}return o}static getEndingSegmentPoints(t,e=0){t=t.concat(),t=_.pathOrder(t,!0,!0);let{originalPts:n,pts:o,cxs:i}=_.getSegsAndConnections(t,!0),c=f=>n[f];const l=o.filter(f=>i[f].length===1),r=[];return l.forEach(f=>{const d=T.clone(c(f));if(e===0){r.push(d);return}const a=c(i[f]),u=E.angleBetween(a,d),h=new T(0,e);E.rotatePoint(h,Math.PI*.5-u),E.addToPoint(d,h),r.push(d)}),r}static getFills(t,e=5){t=t.concat();let{originalPts:n,cxs:o}=_.getSegsAndConnections(t,!0,!0),i=g=>{let y=`${Math.round(g.x*1)}|${Math.round(g.y*1)}`;return n[y]=g,y},c=[],l=[],r=1e5,f=1e5,d=-1e5,a=-1e5,u=1e5,h=1e5,x=[];for(let g in n){let y=n[g];x.push(y),r=Math.min(r,y.x),f=Math.min(f,y.y),d=Math.max(d,y.x),a=Math.max(a,y.y)}x.sort((g,y)=>g.x<y.x?-1:g.x>y.x?1:0),x.forEach((g,y)=>{if(y>0){let S=x[y-1],P=Math.round(Math.abs(g.x-S.x));P>1&&(u=Math.min(u,P))}}),x.sort((g,y)=>g.y<y.y?-1:g.y>y.y?1:0),x.forEach((g,y)=>{if(y>0){let S=x[y-1],P=Math.round(Math.abs(g.y-S.y));P>1&&(h=Math.min(h,P))}});let p=u*.5,b=h*.5,m=[];for(let g=f;g<a;g+=h)for(let y=r;y<d;y+=u)m.push(new T(y+p,g+b));return m.forEach(g=>{let y=[];if(x.forEach(k=>{let w=E.distanceBetween(k,g);if(w<Math.max(u,h)*e){let v=E.angleBetween(k,g);y.push({pt:k,dist:w,ang:v})}}),y.length<4)return;let S=y.length;for(;S--;){let k=y[S].pt,w=new H(g,k);E.segmentSegmentsIntersections(w,t,!0).length>0&&y.splice(S,1)}for(y.sort((k,w)=>k.ang<w.ang?-1:k.ang>w.ang?1:0),S=y.length;S--;){let k=y[S].pt,w=i(k),v=y.length,I=!1;for(;v--;){if(S===v)continue;let O=y[v].pt,z=i(O);if(o[w].indexOf(z)===-1){I=!0;break}}I||y.splice(S,1)}let P=!0;if(y.forEach((k,w)=>{let v=y[(w+1)%y.length],I=i(k.pt),O=i(v.pt);o[I].indexOf(O)===-1&&(P=!1)}),P){let k=y.map(I=>I.pt),w=E.averagePoints(...k),v=i(w);c.indexOf(v)===-1&&(c.push(v),l.push(k))}}),l}}class at{static segmentCollections(t,e=!1,n=!0,o=1,i=!1,c=!1,l=!1){let r=t.reduce((f,d)=>f.concat(d.toSegments()),[]);return at.segments(r,e,n,o,i,c,l)}static segmentCollectionsPathOrder(t,e=!1,n=!1){let o=t.reduce((i,c)=>i.concat(c.toSegments()),[]);return new et(_.pathOrder(o,e,n))}static segments(t,e=!1,n=!0,o=1,i=!1,c=!1,l=!1){return t=at._segments(t,e,n,o),i&&(t=_.pathOrder(t,c,l)),new et(t)}static _segments(t,e,n,o){const i=t;for(t=[];i.length;){let l=i.shift(),r=t.length,f=!1;for(;r--;){const d=t[r];if(H.isEqual(l,d)){f=!0;break}}f||t.push(l)}if(!e)for(let l=0;l<3;l++){let r=t.length;for(;r--;){let f=t[r],d,a,u,h,x;for(let p=r-1;p>=0;p--){let b=t[p],m=!1,g=!1;if(E.sameAngle(f,b)?(m=!0,d=T.clone(f.a),a=T.clone(f.b),u=T.clone(b.a),h=T.clone(b.b)):E.sameAngleRev(f,b)&&(m=g=!0,d=T.clone(f.b),a=T.clone(f.a),u=T.clone(b.a),h=T.clone(b.b)),m&&(x=E.angleBetween(d,a),E.rotatePoints(x,d,a,u,h),Math.abs(d.y-u.y)<.1&&a.x>=u.x-1e-4&&d.x<=h.x+1e-4)){d.x<u.x&&(g?b.a=f.b:b.a=f.a),a.x>h.x&&(g?b.b=f.a:b.b=f.b),t.splice(r,1);break}}}}let c=t.length;for(;c--;){let l=t[c];if(!l){t.splice(c,1);continue}if(n&&E.distanceBetween(l.a,l.b)<o){t.splice(c,1);continue}}return console.log(`[JS] Optimize: ${i.length+t.length} -> ${t.length} segments`),t}}function kt(s,t){const e=s.geometry,n=e.attributes.position,o=e.index;if(!n)return[];const i=new Map,c=1e3,l=(a,u)=>{const h=Math.round(a.x*c),x=Math.round(a.y*c),p=Math.round(a.z*c),b=Math.round(u.x*c),m=Math.round(u.y*c),g=Math.round(u.z*c),y=`${h},${x},${p}`,S=`${b},${m},${g}`;return y<S?`${y}|${S}`:`${S}|${y}`},r=a=>new M.Vector3(n.getX(a),n.getY(a),n.getZ(a)).applyMatrix4(s.matrixWorld),f=(a,u,h)=>{const x=new M.Vector3().subVectors(u,a),p=new M.Vector3().subVectors(h,a);return new M.Vector3().crossVectors(x,p).normalize()},d=o?o.count/3:n.count/3;for(let a=0;a<d;a++){let u,h,x;o?(u=o.getX(a*3),h=o.getX(a*3+1),x=o.getX(a*3+2)):(u=a*3,h=a*3+1,x=a*3+2);const p=r(u),b=r(h),m=r(x),g=f(p,b,m),y=new M.Vector3().addVectors(p,b).add(m).divideScalar(3),S=new M.Vector3().subVectors(t,y);if(g.dot(S)<=0)continue;const P=[[p,b],[b,m],[m,p]];for(const[k,w]of P){const v=l(k,w);if(i.has(v)){const I=i.get(v);I&&!I.normal2&&(I.normal2=g.clone(),I.faceIdx2=a)}else i.set(v,{a:k.clone(),b:w.clone(),normal1:g.clone(),faceIdx1:a,mesh:s})}}return Array.from(i.values())}function It(s,t){return s.filter(e=>{const n=new M.Vector3().addVectors(e.a,e.b).multiplyScalar(.5),o=new M.Vector3().subVectors(t,n).normalize(),i=e.normal1.dot(o)>0;if(!e.normal2)return!0;const c=e.normal2.dot(o)>0;return i||c})}function Vt(s,t,e=.99){const n=[],o=[];for(const i of s){const c=new M.Vector3().addVectors(i.a,i.b).multiplyScalar(.5),l=new M.Vector3().subVectors(t,c).normalize(),r=i.normal1.dot(l)>0,f=i.normal2?i.normal2.dot(l)>0:!0;if(r!==f||!i.normal2){n.push(i);continue}i.normal2&&i.normal1.dot(i.normal2)<e&&o.push(i)}return console.log(`classifyEdges: ${n.length} profiles, ${o.length} smooth/crease edges`),{profiles:n,smoothFiltered:o}}function mt(s,t,e,n,o=1){const i=e/2,c=n/2,l=r=>{const f=r.clone().project(t);return new M.Vector2(f.x*i*o,-f.y*c*o)};return s.map(r=>({a:l(r.a),b:l(r.b),a3d:r.a.clone(),b3d:r.b.clone(),midpoint3d:new M.Vector3().addVectors(r.a,r.b).multiplyScalar(.5),isProfile:!1,visible:!0,faceIdx:r.faceIdx1,faceIdx2:r.faceIdx2,mesh:r.mesh,isHatch:r.isHatch,normal1:r.normal1,normal2:r.normal2}))}class Qt{constructor(t){this.cellSize=t,this.cells=new Map}getCellKey(t,e){const n=Math.floor(t/this.cellSize),o=Math.floor(e/this.cellSize);return`${n},${o}`}getCellsCrossed(t){const e=new Set,n=Math.abs(t.b.x-t.a.x),o=Math.abs(t.b.y-t.a.y),i=Math.max(n,o)/this.cellSize+1;for(let c=0;c<=i;c++){const l=c/i,r=t.a.x+l*(t.b.x-t.a.x),f=t.a.y+l*(t.b.y-t.a.y);e.add(this.getCellKey(r,f))}return Array.from(e)}insert(t){var n;const e=this.getCellsCrossed(t);for(const o of e)this.cells.has(o)||this.cells.set(o,[]),(n=this.cells.get(o))==null||n.push(t)}query(t){return this.cells.get(t)||[]}getAllCells(){return Array.from(this.cells.keys())}clear(){this.cells.clear()}}function _t(s,t){const e=s.a.x,n=s.a.y,o=s.b.x,i=s.b.y,c=t.a.x,l=t.a.y,r=t.b.x,f=t.b.y,d=(e-o)*(l-f)-(n-i)*(c-r);if(Math.abs(d)<1e-10)return null;const a=((e-c)*(l-f)-(n-l)*(c-r))/d,u=-((e-o)*(n-l)-(n-i)*(e-c))/d,h=.001;return a>h&&a<1-h&&u>h&&u<1-h?{t1:a,t2:u,point:new M.Vector2(e+a*(o-e),n+a*(i-n))}:null}function $t(s){var c,l,r,f,d,a;const t=new Map,e=.01,n=(u,h)=>{const x=h.b.x-h.a.x,p=h.b.y-h.a.y,b=x*x+p*p;if(b<1e-10)return null;const m=((u.x-h.a.x)*x+(u.y-h.a.y)*p)/b;if(m<=e||m>=1-e)return null;const g=h.a.x+m*x,y=h.a.y+m*p;return(u.x-g)*(u.x-g)+(u.y-y)*(u.y-y)<1?m:null},o=new Set;for(let u=0;u<s.length;u++)for(let h=u+1;h<s.length;h++){const x=_t(s[u],s[h]);if(x)t.has(s[u])||t.set(s[u],[]),t.has(s[h])||t.set(s[h],[]),(c=t.get(s[u]))==null||c.push({t:x.t1,point:x.point}),(l=t.get(s[h]))==null||l.push({t:x.t2,point:x.point});else{const p=n(s[u].a,s[h]);p!==null&&(t.has(s[h])||t.set(s[h],[]),(r=t.get(s[h]))==null||r.push({t:p,point:s[u].a.clone()}),o.add(s[u]),o.add(s[h]));const b=n(s[u].b,s[h]);b!==null&&(t.has(s[h])||t.set(s[h],[]),(f=t.get(s[h]))==null||f.push({t:b,point:s[u].b.clone()}),o.add(s[u]),o.add(s[h]));const m=n(s[h].a,s[u]);m!==null&&(t.has(s[u])||t.set(s[u],[]),(d=t.get(s[u]))==null||d.push({t:m,point:s[h].a.clone()}),o.add(s[u]),o.add(s[h]));const g=n(s[h].b,s[u]);g!==null&&(t.has(s[u])||t.set(s[u],[]),(a=t.get(s[u]))==null||a.push({t:g,point:s[h].b.clone()}),o.add(s[u]),o.add(s[h]))}}console.log(`T-junction detection: ${o.size} potential straggler edges`);const i=[];for(const u of s){const h=t.get(u),x=o.has(u);if(!h||h.length===0){u.isTJunctionStraggler=x,i.push(u);continue}h.sort((m,g)=>m.t-g.t);let p=u.a,b=u.a3d;for(const m of h){const g=new M.Vector3().lerpVectors(u.a3d,u.b3d,m.t);i.push({a:p.clone(),b:m.point.clone(),a3d:b.clone(),b3d:g.clone(),midpoint3d:new M.Vector3().addVectors(b,g).multiplyScalar(.5),isProfile:u.isProfile,visible:u.visible,faceIdx:u.faceIdx,mesh:u.mesh,isHatch:u.isHatch,normal1:u.normal1,isTJunctionStraggler:x}),m.t,p=m.point,b=g}i.push({a:p.clone(),b:u.b.clone(),a3d:b.clone(),b3d:u.b3d.clone(),midpoint3d:new M.Vector3().addVectors(b,u.b3d).multiplyScalar(.5),isProfile:u.isProfile,visible:u.visible,faceIdx:u.faceIdx,mesh:u.mesh,isHatch:u.isHatch,normal1:u.normal1,isTJunctionStraggler:x})}return i}function Gt(s,t,e,n,o,i,c=!1){if(c)return s.forEach(x=>x.visible=!0),s;const l=[];if(!i)return console.warn("No renderer provided, skipping occlusion test"),s;const r=new M.WebGLRenderTarget(n,o,{minFilter:M.NearestFilter,magFilter:M.NearestFilter,format:M.RGBAFormat,type:M.UnsignedByteType}),f=new M.ShaderMaterial({vertexShader:`
            attribute vec3 faceColor;
            varying vec3 vFaceColor;
            void main() {
                vFaceColor = faceColor;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `,fragmentShader:`
            varying vec3 vFaceColor;
            void main() {
                gl_FragColor = vec4(vFaceColor, 1.0);
            }
        `,side:M.DoubleSide}),d=[];let a=0;for(const x of t){x.__globalFaceOffset=a;const p=x.geometry,b=p.attributes.position,m=p.index,g=m?m.count/3:b.count/3,y=[],S=[];for(let w=0;w<g;w++){let v,I,O;m?(v=m.getX(w*3),I=m.getX(w*3+1),O=m.getX(w*3+2)):(v=w*3,I=w*3+1,O=w*3+2);const z=new M.Vector3(b.getX(v),b.getY(v),b.getZ(v)),B=new M.Vector3(b.getX(I),b.getY(I),b.getZ(I)),F=new M.Vector3(b.getX(O),b.getY(O),b.getZ(O));z.applyMatrix4(x.matrixWorld),B.applyMatrix4(x.matrixWorld),F.applyMatrix4(x.matrixWorld),y.push(z.x,z.y,z.z,B.x,B.y,B.z,F.x,F.y,F.z);const V=a+w+1,C=(V&255)/255,X=(V>>8&255)/255,R=(V>>16&255)/255;S.push(C,X,R,C,X,R,C,X,R)}const P=new M.BufferGeometry;P.setAttribute("position",new M.BufferAttribute(new Float32Array(y),3)),P.setAttribute("faceColor",new M.BufferAttribute(new Float32Array(S),3));const k=new M.Mesh(P,f);d.push(k),a+=g}const u=new M.Scene;for(const x of d)u.add(x);i.setRenderTarget(r),i.setClearColor(0,1),i.clear(),i.render(u,e);const h=new Uint8Array(n*o*4);i.readRenderTargetPixels(r,0,0,n,o,h),i.setRenderTarget(null);for(const x of s){const p=(x.a.x+x.b.x)/2,b=(x.a.y+x.b.y)/2,m=Math.round(p+n/2),g=Math.round(o/2+b);if(m<0||m>=n||g<0||g>=o){x.visible=!0,l.push(x);continue}const y=((o-1-g)*n+m)*4,S=h[y],P=h[y+1],k=h[y+2],w=S+(P<<8)+(k<<16);if(w===0){x.visible=!0,l.push(x);continue}const v=x.mesh.__globalFaceOffset||0,I=v+x.faceIdx+1;if(w===I)x.visible=!0,l.push(x);else{if(x.faceIdx2!==void 0){const O=v+x.faceIdx2+1;if(w===O){x.visible=!0,l.push(x);continue}}x.visible=!1}}r.dispose(),f.dispose();for(const x of d)x.geometry.dispose();return l}function Ut(s,t,e,n){const o=(d,a,u)=>(d.x-u.x)*(a.y-u.y)-(a.x-u.x)*(d.y-u.y),i=o(s,t,e),c=o(s,e,n),l=o(s,n,t),r=i<0||c<0||l<0,f=i>0||c>0||l>0;return!(r&&f)}function te(s,t,e,n,o=2){const i=n.x-e.x,c=n.y-e.y,l=i*i+c*c;if(l<1e-10)return!1;const r=f=>{const d=((f.x-e.x)*i+(f.y-e.y)*c)/l,a=e.x+d*i,u=e.y+d*c;return(f.x-a)*(f.x-a)+(f.y-u)*(f.y-u)<o*o&&d>=-.01&&d<=1.01};return r(s)&&r(t)}function ee(s,t){const e=[];for(const n of t){const o=[{a:n.a2d,b:n.b2d,name:"AB"},{a:n.b2d,b:n.c2d,name:"BC"},{a:n.c2d,b:n.a2d,name:"CA"}];for(const i of o)if(te(s.a,s.b,i.a,i.b)){e.push({face:n,matchedEdge:i.name,matchType:"collinear"});break}}return e}function ne(s,t,e,n,o,i,c){const l={x:n.x-t.x,y:n.y-t.y},r={x:e.x-t.x,y:e.y-t.y},f={x:s.x-t.x,y:s.y-t.y},d=l.x*l.x+l.y*l.y,a=l.x*r.x+l.y*r.y,u=l.x*f.x+l.y*f.y,h=r.x*r.x+r.y*r.y,x=r.x*f.x+r.y*f.y,p=d*h-a*a;if(Math.abs(p)<1e-10)return 1/0;const b=(h*u-a*x)/p,m=(d*x-a*u)/p;return(1-b-m)*o+m*i+b*c}function oe(s,t,e=.99,n=.5){const o=[];let i=0;for(const c of s){const l=ee(c,t);c.adjacentFaceCount=l.length;let r=!1;if(l.length===2){const f=l[0].face,d=l[1].face,a=f.normal,u=d.normal;if(a&&u){const h=a.dot(u),x=Math.abs(h);c.faceSimilarity=x;let p;h>0?p=Math.abs(f.constant-d.constant):p=Math.abs(f.constant+d.constant),x>=e&&p<n&&(r=!0,i++)}}else if(l.length>2){const f=l.map(d=>d.face).filter(d=>d.normal);if(f.length>=2){let d=!0,a=1;for(let u=1;u<f.length;u++){const h=f[0].normal.dot(f[u].normal),x=Math.abs(h);let p;if(h>0?p=Math.abs(f[0].constant-f[u].constant):p=Math.abs(f[0].constant+f[u].constant),a=Math.min(a,x),x<e||p>=n){d=!1;break}}c.faceSimilarity=a,d&&(r=!0,i++)}}r||o.push(c)}return console.log(`Geometric straggler filter: removed ${i} coplanar edges`),o}function se(s,t,e){const n=e.position,o=e.matrixWorldInverse;return ie(s,t,n,o)}function ie(s,t,e,n){const o=[];let i=0,c=0;for(const l of s){const r=new M.Vector2((l.a.x+l.b.x)/2,(l.a.y+l.b.y)/2),f=l.midpoint3d;let d;n?d=-f.clone().applyMatrix4(n).z:d=e.distanceTo(f);let a=!1;for(const u of t){if(u.mesh===l.mesh&&(u.faceIdx===l.faceIdx||u.faceIdx===l.faceIdx2)||!Ut(r,u.a2d,u.b2d,u.c2d))continue;if(ne(r,u.a2d,u.b2d,u.c2d,u.depthA,u.depthB,u.depthC)<d-.001){a=!0,c++;break}i++}a?l.visible=!1:(l.visible=!0,o.push(l))}return console.log(`[JS] Occlusion debug: ${i} point-in-triangle hits, ${c} occluded`),o}function ce(s,t,e,n=.05){const o=new M.Raycaster,i=[],c=[];t.traverse(l=>{l.isMesh&&c.push(l)});for(const l of s){const r=new M.Vector3().subVectors(l.midpoint3d,e.position),f=r.clone().normalize(),d=r.length(),a=d*n;o.set(e.position.clone(),f);const u=o.intersectObjects(c,!0);if(u.length===0)l.visible=!0,i.push(l);else{let h=!1;for(const x of u)if(!(x.distance>=d-a)&&!(x.object===l.mesh&&x.faceIndex===l.faceIdx)){h=!0;break}h?l.visible=!1:(l.visible=!0,i.push(l))}}return i}function yt(s,t=.5){const e=new Map,n=i=>`${Math.round(i.x/t)},${Math.round(i.y/t)}`,o=i=>{const c=n(i.a),l=n(i.b);return c<l?`${c}-${l}`:`${l}-${c}`};for(const i of s){const c=o(i);e.has(c)||e.set(c,i)}return Array.from(e.values())}function pt(s,t=1,e=50){const n=m=>`${Math.round(m.x/t)},${Math.round(m.y/t)}`,o=new Map;for(const m of s)for(const g of["a","b"]){const y=g==="a"?m.a:m.b,S=n(y);o.has(S)||o.set(S,{edges:[],point:{x:y.x,y:y.y}}),o.get(S).edges.push({edge:m,endpoint:g})}const i=[];for(const[m,g]of o)if(g.edges.length===1){const{edge:y,endpoint:S}=g.edges[0],P=g.point,k=S==="a"?y.b:y.a,w=P.x-k.x,v=P.y-k.y,I=Math.sqrt(w*w+v*v);if(I<.001)continue;i.push({key:m,edge:y,endpoint:S,point:P,otherPoint:k,dirX:w/I,dirY:v/I,len:I})}if(console.log(`Edge cleanup: found ${i.length} orphaned endpoints`),i.length===0)return s;const c=(m,g,y,S)=>{const P=g.x*S.y-g.y*S.x;if(Math.abs(P)<1e-4)return null;const k=y.x-m.x,w=y.y-m.y,v=(k*S.y-w*S.x)/P,I=(k*g.y-w*g.x)/P;return{t1:v,t2:I}};let l=0;const r=new Set;for(let m=0;m<i.length;m++){const g=i[m];if(r.has(g.key))continue;let y=null,S=null,P=1/0;for(let k=0;k<i.length;k++){if(m===k)continue;const w=i[k];if(r.has(w.key)||Math.sqrt((w.point.x-g.point.x)**2+(w.point.y-g.point.y)**2)>e*2)continue;const I=c({x:g.point.x,y:g.point.y},{x:g.dirX,y:g.dirY},{x:w.point.x,y:w.point.y},{x:w.dirX,y:w.dirY});if(!I||I.t1<-.1||I.t2<-.1||I.t1>e||I.t2>e)continue;const O=g.point.x+I.t1*g.dirX,z=g.point.y+I.t1*g.dirY,B=I.t1+I.t2;B<P&&(P=B,y=w,S={x:O,y:z})}if(y&&S){const k=Ft(g.point,S,s,g.edge,y.edge),w=Ft(y.point,S,s,g.edge,y.edge);if(k||w)continue;g.endpoint==="a"?(g.edge.a.x=S.x,g.edge.a.y=S.y):(g.edge.b.x=S.x,g.edge.b.y=S.y),y.endpoint==="a"?(y.edge.a.x=S.x,y.edge.a.y=S.y):(y.edge.b.x=S.x,y.edge.b.y=S.y),r.add(g.key),r.add(y.key),l++}}console.log(`Edge cleanup: extended ${l} pairs of edges to intersections`);let f=0;for(const m of s){const g=m.b.x-m.a.x,y=m.b.y-m.a.y;f+=Math.sqrt(g*g+y*y)}const d=f/s.length,a=d/8;console.log(`Edge cleanup: average edge length = ${d.toFixed(2)}, snap threshold = ${a.toFixed(2)}`);const u=new Map;for(const m of s)for(const g of["a","b"]){const y=g==="a"?m.a:m.b,S=n(y);u.has(S)||u.set(S,{edges:[],point:y}),u.get(S).edges.push({edge:m,endpoint:g})}const h=[];for(const[m,g]of u)g.edges.length===1&&h.push({key:m,...g.edges[0],point:g.point});console.log(`Edge cleanup: ${h.length} orphaned endpoints before snap pass`);let x=0;const p=new Set;for(let m=0;m<h.length;m++){const g=h[m];if(p.has(g.key))continue;let y=null,S=1/0;for(let P=0;P<h.length;P++){if(m===P)continue;const k=h[P];if(p.has(k.key))continue;const w=Math.sqrt((k.point.x-g.point.x)**2+(k.point.y-g.point.y)**2);w<S&&(S=w,y=k)}if(y&&S<a){const P=(g.point.x+y.point.x)/2,k=(g.point.y+y.point.y)/2;g.endpoint==="a"?(g.edge.a.x=P,g.edge.a.y=k):(g.edge.b.x=P,g.edge.b.y=k),y.endpoint==="a"?(y.edge.a.x=P,y.edge.a.y=k):(y.edge.b.x=P,y.edge.b.y=k),p.add(g.key),p.add(y.key),x++}}console.log(`Edge cleanup: snapped ${x} pairs of nearby orphans`);const b=h.length-x*2;return console.log(`Edge cleanup: ${b} orphaned endpoints remaining`),s}function ae(s,t=1){const e=c=>`${Math.round(c.x/t)},${Math.round(c.y/t)}`,n=new Map;for(const c of s){const l=e(c.a),r=e(c.b);n.set(l,(n.get(l)||0)+1),n.set(r,(n.get(r)||0)+1)}const o=s.filter(c=>{const l=e(c.a),r=e(c.b),f=n.get(l)||0,d=n.get(r)||0;return f>=2||d>=2}),i=s.length-o.length;return i>0&&console.log(`Edge cleanup: removed ${i} isolated edges (orphaned at both ends)`),o}function Ft(s,t,e,n,o){for(const c of e){if(c===n||c===o)continue;const l=t.x-s.x,r=t.y-s.y,f=c.b.x-c.a.x,d=c.b.y-c.a.y,a=l*d-r*f;if(Math.abs(a)<.001)continue;const u=c.a.x-s.x,h=c.a.y-s.y,x=(u*d-h*f)/a,p=(u*r-h*l)/a;if(x>.001&&x<1-.001&&p>.001&&p<1-.001)return!0}return!1}function re(s,t,e,n={}){const{smoothThreshold:o=.99,gridSize:i=32,occlusionEpsilon:c=.01,skipOcclusion:l=!1,width:r=800,height:f=600,renderer:d=null}=n;console.time("extractEdges");const a=kt(s,t.position);console.timeEnd("extractEdges"),console.log(`Extracted ${a.length} edges`),console.time("filterBackfacing");const u=It(a,t.position);console.timeEnd("filterBackfacing"),console.log(`After backface filter: ${u.length} edges`),console.time("classifyEdges");const{profiles:h,smoothFiltered:x}=Vt(u,t.position,o);console.timeEnd("classifyEdges"),console.log(`Profiles: ${h.length}, Smooth edges: ${x.length}`);const p=[...h,...x];console.time("projectEdges");let b=mt(p,t,r,f);console.timeEnd("projectEdges");for(let v=0;v<h.length;v++)b[v].isProfile=!0;console.time("spatialHash");const m=Math.max(r,f)/i,g=new Qt(m);for(const v of b)g.insert(v);console.timeEnd("spatialHash"),console.time("splitIntersections");const y=new Set;let S=[];for(const v of g.getAllCells()){const I=g.query(v).filter(z=>!y.has(z)),O=$t(I);S.push(...O);for(const z of I)y.add(z)}console.timeEnd("splitIntersections"),console.log(`After splitting: ${S.length} edges`);let P;if(l)console.log("Skipping occlusion test (debug mode)"),P=S;else if(d){console.time("testOcclusion (face ID buffer)");const v=S.filter(z=>z.isProfile),I=S.filter(z=>!z.isProfile);v.forEach(z=>z.visible=!0);const O=Gt(I,[s],t,r,f,d,!1);P=[...v,...O],console.timeEnd("testOcclusion (face ID buffer)")}else console.time("testOcclusion (raycaster - slow)"),P=ce(S,e,t,c),console.timeEnd("testOcclusion (raycaster - slow)");console.log(`Visible edges: ${P.length}`),console.time("optimize");const k=yt(P);console.timeEnd("optimize"),console.time("cleanup orphans");const w=pt(k);return console.timeEnd("cleanup orphans"),console.log(`Final edges: ${w.length}`),{edges:w,profiles:w.filter(v=>v.isProfile)}}function Ot(s,t,e,n={}){const{smoothThreshold:o=.99,gridSize:i=32,skipOcclusion:c=!1,width:l=800,height:r=600,renderer:f=null,internalScale:d=4,distanceThreshold:a=.5}=n;let u=[];for(const F of s){F.updateMatrixWorld(!0);const V=kt(F,t.position);u.push(...V)}console.log(`Extracted ${u.length} edges from ${s.length} meshes`);const{profiles:h,smoothFiltered:x}=Vt(u,t.position,o);console.log(`Profiles: ${h.length}, Crease edges: ${x.length}`);const p=[...h,...x];console.log(`After smooth filter: ${p.length} edges`);let b=mt(p,t,l,r,d);if(n.hatchEdges&&n.hatchEdges.length>0){console.log(`Processing ${n.hatchEdges.length} hatch edges...`);let F=It(n.hatchEdges,t.position);if(n.minHatchDotProduct!==void 0){const C=n.minHatchDotProduct;F=F.filter(X=>{const R=new M.Vector3().addVectors(X.a,X.b).multiplyScalar(.5),$=new M.Vector3().subVectors(t.position,R).normalize(),Y=X.normal1.dot($);return Math.abs(Y)>=C}),console.log(`Density filter: kept ${F.length} hatch edges (threshold ${C})`)}const V=mt(F,t,l,r,d);V.forEach(C=>C.isHatch=!0),b.push(...V),console.log(`Added ${V.length} visible hatch edges`)}console.time("splitIntersections");const m=$t(b);console.timeEnd("splitIntersections"),console.log(`After splitting: ${m.length} edges`),console.time("buildProjectedFaces");const g=[],y=t.position,S=l/2,P=r/2;for(const F of s){const V=F.geometry,C=V.attributes.position,X=V.index,R=X?X.count/3:C.count/3;for(let $=0;$<R;$++){let Y,D,j;X?(Y=X.getX($*3),D=X.getX($*3+1),j=X.getX($*3+2)):(Y=$*3,D=$*3+1,j=$*3+2);const q=new M.Vector3(C.getX(Y),C.getY(Y),C.getZ(Y)).applyMatrix4(F.matrixWorld),L=new M.Vector3(C.getX(D),C.getY(D),C.getZ(D)).applyMatrix4(F.matrixWorld),Z=new M.Vector3(C.getX(j),C.getY(j),C.getZ(j)).applyMatrix4(F.matrixWorld),K=new M.Vector3().subVectors(L,q),nt=new M.Vector3().subVectors(Z,q),ot=new M.Vector3().crossVectors(K,nt).normalize(),ut=new M.Vector3().addVectors(q,L).add(Z).divideScalar(3),rt=new M.Vector3().subVectors(y,ut),Q=-ot.dot(q);if(ot.dot(rt)<=0)continue;const st=q.clone().project(t),wt=L.clone().project(t),W=Z.clone().project(t),J=new M.Vector2(st.x*S*d,-st.y*P*d),G=new M.Vector2(wt.x*S*d,-wt.y*P*d),it=new M.Vector2(W.x*S*d,-W.y*P*d),U=t.matrixWorldInverse,tt=-q.clone().applyMatrix4(U).z,ct=-L.clone().applyMatrix4(U).z,Mt=-Z.clone().applyMatrix4(U).z;g.push({a2d:J,b2d:G,c2d:it,depthA:tt,depthB:ct,depthC:Mt,mesh:F,faceIdx:$,normal:ot,constant:Q})}}console.timeEnd("buildProjectedFaces"),console.log(`Built ${g.length} projected faces for occlusion`),console.time("classifySilhouettes"),le(m,g),console.timeEnd("classifySilhouettes"),console.time("filterSmoothSplitEdges");const k=oe(m,g,o,a);console.timeEnd("filterSmoothSplitEdges");let w;c?w=k:(console.time("testOcclusion (math)"),w=se(k,g,t),console.timeEnd("testOcclusion (math)")),console.log(`Visible edges: ${w.length}`),console.time("optimize");const v=yt(w);console.timeEnd("optimize"),console.time("cleanup orphans");const I=pt(v);console.timeEnd("cleanup orphans");const O=ae(I);console.log(`Final edges before optimization: ${O.length}`);let z=O;if(O.length>0){let F=0;for(const X of O){const R=X.b.x-X.a.x,$=X.b.y-X.a.y;F+=Math.sqrt(R*R+$*$)}const V=F/O.length,C=V/10;console.log(`Optimization: avgLen=${V.toFixed(2)}, trim limit=${C.toFixed(2)}`),console.time("Optimize.segments"),z=at.segments(O,!1,!0,C,!1,!1,!1)._segments,console.timeEnd("Optimize.segments"),console.log(`After optimization: ${z.length} edges`)}for(const F of z)F.a.x/=d,F.a.y/=d,F.b.x/=d,F.b.y/=d;const B=z;return{edges:B,profiles:B.filter(F=>F.isProfile),allEdges:m,projectedFaces:g}}function le(s,t){for(const o of s){if(o.isHatch){o.isSilhouette=!1;continue}const i=(o.a.x+o.b.x)/2,c=(o.a.y+o.b.y)/2,l=o.b.x-o.a.x,r=o.b.y-o.a.y,f=Math.sqrt(l*l+r*r);if(f<.001){o.isSilhouette=!1;continue}const d=-r/f,a=l/f,u=Ct(i,c,d,a,1e3,t),h=Ct(i,c,-d,-a,1e3,t);o.isSilhouette=!u||!h}const n=s.filter(o=>o.isSilhouette).length;console.log(`Classified ${n} silhouette edges out of ${s.length}`)}function Ct(s,t,e,n,o,i){for(const c of i)if(fe(s,t,e,n,o,c.a2d,c.b2d,c.c2d))return!0;return!1}function fe(s,t,e,n,o,i,c,l){return!!(bt(s,t,e,n,o,i.x,i.y,c.x,c.y)||bt(s,t,e,n,o,c.x,c.y,l.x,l.y)||bt(s,t,e,n,o,l.x,l.y,i.x,i.y))}function bt(s,t,e,n,o,i,c,l,r){const f=l-i,d=r-c,a=e*d-n*f;if(Math.abs(a)<1e-10)return!1;const u=((i-s)*d-(c-t)*f)/a,h=((i-s)*n-(c-t)*e)/a;return u>.1&&u<=o&&h>=0&&h<=1}var N=s=>Math.round(s*100)/100,ft=function(s){M.Object3D.call(this),this.node=s};ft.prototype=Object.create(M.Object3D.prototype),ft.prototype.constructor=ft;var ue=function(){var s=this,t=document.createElementNS("http://www.w3.org/2000/svg","svg"),e=document.createElementNS("http://www.w3.org/2000/svg","g"),n=document.createElementNS("http://www.w3.org/2000/svg","g"),o=document.createElementNS("http://www.w3.org/2000/svg","g"),i,c,l,r,f=new M.Color;t.setAttribute("xmlns","http://www.w3.org/2000/svg"),t.setAttribute("xmlns:inkscape","http://www.inkscape.org/namespaces/inkscape"),t.setAttribute("xmlns:xlink","http://www.w3.org/1999/xlink"),t.setAttribute("version","1.1"),e.setAttribute("inkscape:label","Silhouettes"),e.setAttribute("inkscape:groupmode","layer"),e.id="silhouettes_layer",t.appendChild(e),o.setAttribute("inkscape:label","Shading"),o.setAttribute("inkscape:groupmode","layer"),o.id="shading_layer",t.appendChild(o),n.setAttribute("inkscape:label","Edges"),n.setAttribute("inkscape:groupmode","layer"),n.id="edges_layer",t.appendChild(n),this.domElement=t,this.showSilhouettes=!0,this.showEdges=!0,this.showHatches=!0,this.themes={light:{background:"#ffffff",edgeStroke:"#000000",hatchStroke:"#444444",silhouetteFill:a=>`rgba(${Math.floor((a.x*.5+.5)*40+200)},${Math.floor((a.y*.5+.5)*40+200)},${Math.floor((a.z*.5+.5)*40+200)},0.3)`},dark:{background:"#222222",edgeStroke:"#ffffff",hatchStroke:"#aaaaaa",silhouetteFill:a=>`rgba(${Math.floor((a.x*.5+.5)*255)},${Math.floor((a.y*.5+.5)*255)},${Math.floor((a.z*.5+.5)*255)},0.3)`}},this.theme="dark",this.silhouetteOptions={normalBuckets:12,simplifyTolerance:2,minArea:100},this.hatchOptions={baseSpacing:8,minSpacing:3,maxSpacing:40,depthFactor:.5,insetPixels:2,stroke:null,strokeWidth:"1px",axisSettings:{x:{rotation:0,spacing:8},y:{rotation:0,spacing:8},z:{rotation:0,spacing:8}},brightnessShading:{enabled:!1,invert:!1,lightDirection:null},frameBudgetMs:16,progressCallback:null},this.edgeOptions={stroke:null,strokeWidth:"1px"},this.hiddenLineOptions={smoothThreshold:.99},this._glRenderer=null,this.autoClear=!0,this.setClearColor=function(a){f.set(a)},this.setPixelRatio=function(){},this.setSize=function(a,u){i=a,c=u,l=i/2,r=c/2,t.setAttribute("viewBox",-l+" "+-r+" "+i+" "+c),t.setAttribute("width",i),t.setAttribute("height",c)},this.getSize=function(){return{width:i,height:c}},this.setGLRenderer=function(a){s._glRenderer=a};function d(){for(;e.childNodes.length>0;)e.removeChild(e.childNodes[0]);for(;n.childNodes.length>0;)n.removeChild(n.childNodes[0]);for(;o.childNodes.length>0;)o.removeChild(o.childNodes[0])}this.clear=function(){d(),t.style.backgroundColor=f.getStyle()},this.renderGPULayers=async function(a,u){if(!s._glRenderer){console.warn("PlotterRenderer: WebGL renderer not set. Call setGLRenderer() first.");return}const h=s._glRenderer;if(s.showSilhouettes||s.showHatches){const x=St(h,a,u,{normalBuckets:s.silhouetteOptions.normalBuckets,simplifyTolerance:s.silhouetteOptions.simplifyTolerance,minArea:s.silhouetteOptions.minArea,insetPixels:s.showHatches?s.hatchOptions.insetPixels:0});if(s.showSilhouettes&&x.forEach(p=>{if(p.boundary.length<3)return;const b=document.createElementNS("http://www.w3.org/2000/svg","path");let m="";p.boundary.forEach((P,k)=>{const w=P.x,v=-P.y;m+=(k===0?"M":"L")+N(w)+","+N(v)}),m+="Z";const g=p.normal,y=s.themes[s.theme]||s.themes.dark,S=y.silhouetteFill?y.silhouetteFill(g):`rgba(${Math.floor((g.x*.5+.5)*255)},${Math.floor((g.y*.5+.5)*255)},${Math.floor((g.z*.5+.5)*255)},0.3)`;b.setAttribute("d",m),b.setAttribute("fill",S),b.setAttribute("stroke","none"),e.appendChild(b)}),s.showHatches){x.sort((w,v)=>w.depth-v.depth);const p=x.map(w=>w.hatchBoundary||w.boundary);let b=1;{let w=1/0,v=-1/0,I=1/0,O=-1/0,z=1/0,B=-1/0;if(a.traverse(F=>{if(!F.isMesh||!F.geometry)return;F.geometry.computeBoundingBox();const V=F.geometry.boundingBox;if(!V)return;const C=[new M.Vector3(V.min.x,V.min.y,V.min.z),new M.Vector3(V.max.x,V.max.y,V.max.z),new M.Vector3(V.min.x,V.min.y,V.max.z),new M.Vector3(V.min.x,V.max.y,V.min.z),new M.Vector3(V.max.x,V.min.y,V.min.z),new M.Vector3(V.min.x,V.max.y,V.max.z),new M.Vector3(V.max.x,V.min.y,V.max.z),new M.Vector3(V.max.x,V.max.y,V.min.z)];for(const X of C)X.applyMatrix4(F.matrixWorld),w=Math.min(w,X.x),v=Math.max(v,X.x),I=Math.min(I,X.y),O=Math.max(O,X.y),z=Math.min(z,X.z),B=Math.max(B,X.z)}),isFinite(w)){const F=[new M.Vector3(w,I,z),new M.Vector3(v,O,B),new M.Vector3(w,I,B),new M.Vector3(w,O,z),new M.Vector3(v,I,z),new M.Vector3(w,O,B),new M.Vector3(v,I,B),new M.Vector3(v,O,z)];let V=1/0,C=-1/0,X=1/0,R=-1/0;for(const q of F){const L=q.clone().project(u),Z=(L.x+1)*i/2,K=(1-L.y)*c/2;V=Math.min(V,Z),C=Math.max(C,Z),X=Math.min(X,K),R=Math.max(R,K)}const $=C-V,Y=R-X,D=Math.max($,Y),j=Math.max(i,c);D>0&&j>0&&(b=D/j)}}const m=x.filter(w=>w.isHole);let g=null;const y=s.hatchOptions.brightnessShading||{};y.enabled&&(y.lightDirection?g=y.lightDirection.clone().normalize():(a.traverse(w=>{g||(w.isDirectionalLight?g=new M.Vector3().subVectors(w.position,w.target.position).normalize():(w.isPointLight||w.isSpotLight)&&(g=w.position.clone().normalize()))}),g||(g=new M.Vector3(1,1,1).normalize())),g=g.clone().transformDirection(u.matrixWorldInverse));const S=s.hatchOptions.frameBudgetMs||16,P=s.hatchOptions.progressCallback;let k=performance.now();for(let w=0;w<x.length;w++){const v=x[w];let I=null;g&&y.enabled&&(I=Math.max(0,v.normal.dot(g)));const O=performance.now(),z=s.hatchOptions.regionTimeBudget||100,B={},F=s.hatchOptions.axisSettings||{};for(const $ of["x","y","z"]){const Y=F[$]||{};B[$]={rotation:Y.rotation||0,spacing:(Y.spacing||s.hatchOptions.baseSpacing)*b}}let V=Et(v,u,{baseSpacing:s.hatchOptions.baseSpacing*b,minSpacing:s.hatchOptions.minSpacing*b,maxSpacing:s.hatchOptions.maxSpacing*b,depthFactor:s.hatchOptions.depthFactor,insetPixels:s.hatchOptions.insetPixels,screenWidth:i,screenHeight:c,axisSettings:B,brightness:I,invertBrightness:y.invert||!1});if(performance.now()-O>z){console.warn(`Region ${w} hatch generation exceeded time budget, skipping`);continue}for(let $=0;$<w;$++){const Y=x[$];if(!(v.isHole&&v.parentRegionId===Y.regionId)&&(V=V.flatMap(D=>gt(D,p[$])),performance.now()-O>z)){console.warn(`Region ${w} clipping exceeded time budget, aborting`),V=[];break}}for(const $ of m)if($.parentRegionId===v.regionId){if(V.length===0)break;V=V.flatMap(Y=>gt(Y,$.boundary))}const C=s.themes[s.theme]||s.themes.dark,X=s.hatchOptions.stroke||C.hatchStroke;if(s.hatchOptions.connectHatches&&V.length>0){const $=document.createElementNS("http://www.w3.org/2000/svg","path");let Y="";V.forEach((D,j)=>{const q=j%2===0?D.start:D.end,L=j%2===0?D.end:D.start;j===0?Y+=`M${N(q.x)},${N(-q.y)}`:Y+=`L${N(q.x)},${N(-q.y)}`,Y+=`L${N(L.x)},${N(-L.y)}`}),$.setAttribute("d",Y),$.setAttribute("fill","none"),$.setAttribute("stroke",X),$.setAttribute("stroke-width",s.hatchOptions.strokeWidth),o.appendChild($)}else V.forEach(($,Y)=>{const D=document.createElementNS("http://www.w3.org/2000/svg","path"),j=Y%2===0?$.start:$.end,q=Y%2===0?$.end:$.start,L=`M${N(j.x)},${N(-j.y)}L${N(q.x)},${N(-q.y)}`;D.setAttribute("d",L),D.setAttribute("fill","none"),D.setAttribute("stroke",X),D.setAttribute("stroke-width",s.hatchOptions.strokeWidth),o.appendChild(D)});performance.now()-k>S&&w<x.length-1&&(P&&P((w+1)/x.length),await new Promise($=>requestAnimationFrame($)),k=performance.now())}P&&P(1)}}if(s.showEdges){const x=[];if(a.traverse(p=>{if(!p.isMesh||!p.geometry)return;let b=!1,m=p;for(;m;){if(m.userData&&m.userData.excludeFromSVG){b=!0;break}m=m.parent}b||x.push(p)}),x.length>0){const b=Ot(x,u,a,{smoothThreshold:s.hiddenLineOptions.smoothThreshold,width:i,height:c}).edges||[],m=s.themes[s.theme]||s.themes.dark,g=s.edgeOptions.stroke||m.edgeStroke;b.forEach(y=>{const S=document.createElementNS("http://www.w3.org/2000/svg","line");S.setAttribute("x1",N(y.a.x)),S.setAttribute("y1",N(y.a.y)),S.setAttribute("x2",N(y.b.x)),S.setAttribute("y2",N(y.b.y)),S.setAttribute("stroke",g),S.setAttribute("stroke-width",s.edgeOptions.strokeWidth),n.appendChild(S)})}}},this.render=function(a,u){if(!(u instanceof M.Camera)){console.error("PlotterRenderer.render: camera is not an instance of Camera.");return}}};A.GeomUtil=E,A.Optimize=at,A.PlotterRenderer=ue,A.Point=T,A.SVGObject=ft,A.Segment=H,A.Segments=et,A.cleanupOrphanedEdges=pt,A.clipLineOutsidePolygon=gt,A.clipLineToPolygon=ht,A.computeHiddenLines=re,A.computeHiddenLinesMultiple=Ot,A.extractNormalRegions=St,A.generatePerspectiveHatches=Et,A.optimizeEdges=yt,Object.defineProperty(A,Symbol.toStringTag,{value:"Module"})});
//# sourceMappingURL=three-plotter-renderer.umd.js.map
